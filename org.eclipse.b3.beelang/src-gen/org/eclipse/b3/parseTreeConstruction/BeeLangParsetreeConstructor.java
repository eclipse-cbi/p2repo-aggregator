/*
* generated by Xtext
*/
package org.eclipse.b3.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.b3.services.BeeLangGrammarAccess;

import com.google.inject.Inject;

public class BeeLangParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private BeeLangGrammarAccess grammarAccess;
	
	@Override	
	public BeeLangGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BeeModel_Group(this, this, 0, inst);
			case 1: return new Import_Group(this, this, 1, inst);
			case 2: return new BuildUnit_Group(this, this, 2, inst);
			case 3: return new ProvidedCapability_Group(this, this, 3, inst);
			case 4: return new RequiredCapability_Group(this, this, 4, inst);
			case 5: return new RequiredCapability_Unfiltered_Group(this, this, 5, inst);
			case 6: return new RequiredCapability_Unit_Group(this, this, 6, inst);
			case 7: return new PropertySet_Named_Group(this, this, 7, inst);
			case 8: return new PropertySet_Group(this, this, 8, inst);
			case 9: return new PropertyOperation_Alternatives(this, this, 9, inst);
			case 10: return new ConditionalPropertyOperation_Group(this, this, 10, inst);
			case 11: return new PropertyDefinitionOperation_Group(this, this, 11, inst);
			case 12: return new PropertyValDeclaration_Group(this, this, 12, inst);
			case 13: return new PropertyVarDeclaration_Group(this, this, 13, inst);
			case 14: return new PropertySetOperation_Group(this, this, 14, inst);
			case 15: return new Synchronization_Group(this, this, 15, inst);
			case 16: return new SynchronizedBuilder_Alternatives(this, this, 16, inst);
			case 17: return new PathGroup_Group(this, this, 17, inst);
			case 18: return new PathVector_Alternatives(this, this, 18, inst);
			case 19: return new BasePathVector_Group(this, this, 19, inst);
			case 20: return new UnbasedPathVector_Group(this, this, 20, inst);
			case 21: return new CompoundPathVector_Group(this, this, 21, inst);
			case 22: return new Prerequisite_Group(this, this, 22, inst);
			case 23: return new WithClause_Group(this, this, 23, inst);
			case 24: return new BuildResultReference_Alternatives(this, this, 24, inst);
			case 25: return new UnitReference_Group(this, this, 25, inst);
			case 26: return new CapabilityReference_Group(this, this, 26, inst);
			case 27: return new CompoundBuildResultReference_Group(this, this, 27, inst);
			case 28: return new Builder_Group(this, this, 28, inst);
			case 29: return new ParameterList_Group(this, this, 29, inst);
			case 30: return new FirstParameter_Alternatives(this, this, 30, inst);
			case 31: return new Parameter_Group(this, this, 31, inst);
			case 32: return new ClosureParameter_Group(this, this, 32, inst);
			case 33: return new ParameterDeclaration_Group(this, this, 33, inst);
			case 34: return new BuilderInput_Group(this, this, 34, inst);
			case 35: return new RepositoryConfiguration_Alternatives(this, this, 35, inst);
			case 36: return new RepositoryDeclaration_Group(this, this, 36, inst);
			case 37: return new ResolutionStrategy_Alternatives(this, this, 37, inst);
			case 38: return new ResolutionStrategyFirst_Group(this, this, 38, inst);
			case 39: return new ResolutionStrategyBest_Group(this, this, 39, inst);
			case 40: return new ContainerConfiguration_Group(this, this, 40, inst);
			case 41: return new Concern_Named_Group(this, this, 41, inst);
			case 42: return new Concern_Anonymous_Group(this, this, 42, inst);
			case 43: return new Function_Group(this, this, 43, inst);
			case 44: return new GuardExpression_Alternatives(this, this, 44, inst);
			case 45: return new TopLevelExpression_Alternatives(this, this, 45, inst);
			case 46: return new Expression_AssignmentExpressionParserRuleCall(this, this, 46, inst);
			case 47: return new AssignmentExpression_Group(this, this, 47, inst);
			case 48: return new VarDeclaration_Group(this, this, 48, inst);
			case 49: return new ValDeclaration_Group(this, this, 49, inst);
			case 50: return new TypeRef_Alternatives(this, this, 50, inst);
			case 51: return new SimpleTypeRef_Group(this, this, 51, inst);
			case 52: return new ClosureTypeRef_Group(this, this, 52, inst);
			case 53: return new TypeParam_Alternatives(this, this, 53, inst);
			case 54: return new TypeRefParam_TypeRefParserRuleCall(this, this, 54, inst);
			case 55: return new WildcardRefParam_Group(this, this, 55, inst);
			case 56: return new CachedExpression_Alternatives(this, this, 56, inst);
			case 57: return new OrExpression_Group(this, this, 57, inst);
			case 58: return new AndExpression_Group(this, this, 58, inst);
			case 59: return new RelationalExpression_Group(this, this, 59, inst);
			case 60: return new InstanceOfExpression_Group(this, this, 60, inst);
			case 61: return new AdditiveExpression_Group(this, this, 61, inst);
			case 62: return new MultiplicativeExpression_Group(this, this, 62, inst);
			case 63: return new SetExpression_Group(this, this, 63, inst);
			case 64: return new UnaryOrInfixExpression_Alternatives(this, this, 64, inst);
			case 65: return new UnaryExpression_Group(this, this, 65, inst);
			case 66: return new PreopExpression_Group(this, this, 66, inst);
			case 67: return new PostopExpression_Group(this, this, 67, inst);
			case 68: return new InfixExpression_Group(this, this, 68, inst);
			case 69: return new CallExpression_Group(this, this, 69, inst);
			case 70: return new PrimaryExpression_Alternatives(this, this, 70, inst);
			case 71: return new WildcardExpression_Group(this, this, 71, inst);
			case 72: return new ThrowExpression_Group(this, this, 72, inst);
			case 73: return new TryCatchExpression_Group(this, this, 73, inst);
			case 74: return new CatchBlock_Group(this, this, 74, inst);
			case 75: return new SwitchExpression_Group(this, this, 75, inst);
			case 76: return new Case_Group(this, this, 76, inst);
			case 77: return new BlockExpression_Group(this, this, 77, inst);
			case 78: return new IfExpression_Group(this, this, 78, inst);
			case 79: return new ElseIfExpression_Group(this, this, 79, inst);
			case 80: return new PropertyValue_Group(this, this, 80, inst);
			case 81: return new VariableValue_Group(this, this, 81, inst);
			case 82: return new KeywordVariables_Group(this, this, 82, inst);
			case 83: return new FeatureCall_OperationCallParserRuleCall(this, this, 83, inst);
			case 84: return new OperationCall_Group(this, this, 84, inst);
			case 85: return new ConstructorCallExpression_Group(this, this, 85, inst);
			case 86: return new ContextBlock_Group(this, this, 86, inst);
			case 87: return new ContextBlock_Creation_Group(this, this, 87, inst);
			case 88: return new FunctionDefinition_Group(this, this, 88, inst);
			case 89: return new Literal_Alternatives(this, this, 89, inst);
			case 90: return new LiteralList_Alternatives(this, this, 90, inst);
			case 91: return new LiteralMap_Alternatives(this, this, 91, inst);
			case 92: return new LiteralFunction_Group(this, this, 92, inst);
			case 93: return new ClosureExpression_Group(this, this, 93, inst);
			case 94: return new OneOrManyExpressions_Alternatives(this, this, 94, inst);
			case 95: return new BlockExpressionWithoutBrackets_Group(this, this, 95, inst);
			case 96: return new MapEntry_Group(this, this, 96, inst);
			case 97: return new KeyLiteral_Group(this, this, 97, inst);
			case 98: return new LiteralType_Group(this, this, 98, inst);
			case 99: return new ValueLiteral_Alternatives(this, this, 99, inst);
			case 100: return new BooleanLiteral_Group(this, this, 100, inst);
			case 101: return new IntegerLiteral_Group(this, this, 101, inst);
			case 102: return new UnitLiteral_Group(this, this, 102, inst);
			case 103: return new StringLiteral_Group(this, this, 103, inst);
			case 104: return new RealLiteral_Group(this, this, 104, inst);
			case 105: return new RegexpLiteral_Group(this, this, 105, inst);
			case 106: return new NullLiteral_Group(this, this, 106, inst);
			case 107: return new ParanthesizedExpression_Group(this, this, 107, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule BeeModel ****************
 *
 * BeeModel hidden ( WS , SL_COMMENT , ML_COMMENT ):
 *   imports+=Import* (functions+=Function|concern+=Concern_Named|"properties"
 *   propertySets+=PropertySet_Named)* body=BuildUnit?;
 *
 **/

// imports+=Import* (functions+=Function|concern+=Concern_Named|"properties"
// propertySets+=PropertySet_Named)* body=BuildUnit?
protected class BeeModel_Group extends GroupToken {
	
	public BeeModel_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BeeModel_BodyAssignment_2(parent, this, 0, inst);
			case 1: return new BeeModel_Alternatives_1(parent, this, 1, inst);
			case 2: return new BeeModel_ImportsAssignment_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBeeModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// imports+=Import*
protected class BeeModel_ImportsAssignment_0 extends AssignmentToken  {
	
	public BeeModel_ImportsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getImportsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("imports",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("imports");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBeeModelAccess().getImportsImportParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BeeModel_ImportsAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// (functions+=Function|concern+=Concern_Named|"properties" propertySets+=
// PropertySet_Named)*
protected class BeeModel_Alternatives_1 extends AlternativesToken {

	public BeeModel_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BeeModel_FunctionsAssignment_1_0(parent, this, 0, inst);
			case 1: return new BeeModel_ConcernAssignment_1_1(parent, this, 1, inst);
			case 2: return new BeeModel_Group_1_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// functions+=Function
protected class BeeModel_FunctionsAssignment_1_0 extends AssignmentToken  {
	
	public BeeModel_FunctionsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getFunctionsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBeeModelAccess().getFunctionsFunctionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BeeModel_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new BeeModel_ImportsAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// concern+=Concern_Named
protected class BeeModel_ConcernAssignment_1_1 extends AssignmentToken  {
	
	public BeeModel_ConcernAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getConcernAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("concern",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("concern");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcern_NamedRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBeeModelAccess().getConcernConcern_NamedParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BeeModel_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new BeeModel_ImportsAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// "properties" propertySets+=PropertySet_Named
protected class BeeModel_Group_1_2 extends GroupToken {
	
	public BeeModel_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BeeModel_PropertySetsAssignment_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "properties"
protected class BeeModel_PropertiesKeyword_1_2_0 extends KeywordToken  {
	
	public BeeModel_PropertiesKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getPropertiesKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BeeModel_Alternatives_1(parent, this, 0, inst);
			case 1: return new BeeModel_ImportsAssignment_0(parent, this, 1, inst);
			default: return parent.createParentFollower(this, index, index - 2, inst);
		}	
	}	
		
}

// propertySets+=PropertySet_Named
protected class BeeModel_PropertySetsAssignment_1_2_1 extends AssignmentToken  {
	
	public BeeModel_PropertySetsAssignment_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getPropertySetsAssignment_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("propertySets",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("propertySets");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySet_NamedRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBeeModelAccess().getPropertySetsPropertySet_NamedParserRuleCall_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BeeModel_PropertiesKeyword_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// body=BuildUnit?
protected class BeeModel_BodyAssignment_2 extends AssignmentToken  {
	
	public BeeModel_BodyAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBeeModelAccess().getBodyAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("body",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("body");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBuildUnitRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBeeModelAccess().getBodyBuildUnitParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BeeModel_Alternatives_1(parent, next, actIndex, consumed);
			case 1: return new BeeModel_ImportsAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}


/************ end Rule BeeModel ****************/


/************ begin Rule Import ****************
 *
 * Import returns be::IType:
 *   {be::B3JavaImport} reexport?="reexport"? "import" qualifiedName=QID ("as" name=ID)?
 *   ";"; 
 * 
 *         
 * 	                 
 * 	
 * 
 * // Wanted later 
 * //Import : (reexport ?='reexport')? 
 * //		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
 * //	; 
 * 
 * //JavaImporter 	: qualifiedName=QID ;
 * //NativeImporter 	: uriString = STRING ;
 *
 **/

// {be::B3JavaImport} reexport?="reexport"? "import" qualifiedName=QID ("as" name=ID)?
// ";"
protected class Import_Group extends GroupToken {
	
	public Import_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImportAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_SemicolonKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::B3JavaImport}
protected class Import_B3JavaImportAction_0 extends ActionToken  {

	public Import_B3JavaImportAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getImportAccess().getB3JavaImportAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getImportAccess().getB3JavaImportAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// reexport?="reexport"?
protected class Import_ReexportAssignment_1 extends AssignmentToken  {
	
	public Import_ReexportAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImportAccess().getReexportAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_B3JavaImportAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reexport",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reexport");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getImportAccess().getReexportReexportKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// "import"
protected class Import_ImportKeyword_2 extends KeywordToken  {
	
	public Import_ImportKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getImportAccess().getImportKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_ReexportAssignment_1(parent, this, 0, inst);
			case 1: return new Import_B3JavaImportAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// qualifiedName=QID
protected class Import_QualifiedNameAssignment_3 extends AssignmentToken  {
	
	public Import_QualifiedNameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImportAccess().getQualifiedNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_ImportKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("qualifiedName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("qualifiedName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getImportAccess().getQualifiedNameQIDParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// ("as" name=ID)?
protected class Import_Group_4 extends GroupToken {
	
	public Import_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImportAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_NameAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "as"
protected class Import_AsKeyword_4_0 extends KeywordToken  {
	
	public Import_AsKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getImportAccess().getAsKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_QualifiedNameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Import_NameAssignment_4_1 extends AssignmentToken  {
	
	public Import_NameAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImportAccess().getNameAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_AsKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getImportAccess().getNameIDTerminalRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}


// ";"
protected class Import_SemicolonKeyword_5 extends KeywordToken  {
	
	public Import_SemicolonKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getImportAccess().getSemicolonKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_Group_4(parent, this, 0, inst);
			case 1: return new Import_QualifiedNameAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Import ****************/


/************ begin Rule BuildUnit ****************
 *
 * BuildUnit returns build::BuildUnit hidden ( WS , ML_COMMENT , SL_COMMENT ):
 *   {build::BuildUnit} documentation=DOCUMENTATION? executionMode=ExecutionMode? "unit"
 *   name=UnitName? ("version" version=VersionLiteral)? ("implements" implements+=
 *   SimpleTypeRef ("," implements+=SimpleTypeRef)*)? "{" ("default" "properties"
 *   defaultProperties=PropertySet)? ("provides" "{" (unitProvidedCapabilities+=
 *   ProvidedCapability ";")+ "}"|"provides" unitProvidedCapabilities+=
 *   ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=RequiredCapability ";")
 *   + "}"|"requires" requiredCapabilities+=RequiredCapability ";"|"env" "requires" "{" (
 *   metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"env" "requires"
 *   metaRequiredCapabilities+=RequiredCapability ";"|concerns+=Concern_Named|
 *   "sequential" "{" synchronizations+=Synchronization+ "}"|"sequential"
 *   synchronizations+=Synchronization|builders+=Builder|functions+=Function|
 *   "repositories" "{" repositories+=RepositoryConfiguration* "}"|"properties"
 *   propertySets+=PropertySet_Named|"containers" "{" containers+=
 *   ContainerConfiguration* "}")* "}"; 
 * 
 * // Wanted later 
 * //Import : (reexport ?='reexport')? 
 * //		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
 * //	; 
 * 
 * //JavaImporter 	: qualifiedName=QID ;
 * //NativeImporter 	: uriString = STRING ;
 * 		
 *               
 * 	    
 * 	    
 * 	          
 * 		           
 * 	
 * 			 //-- PROPERTIES
 * 			 // goes first, because they may be used in the other clauses. TODO: can probably be relaxed
 * 			 // since linking will find them anyway.
 * 			 //
 * 			            
 * 		
 * 		 	 //-- PROVIDES
 * 			               
 * 			          
 * 			//-- REQUIRES & META REQUIRES
 * 			               
 * 			          
 * 			                  
 * 			            
 * 			//--CONCERNS
 * 			       
 * 			//--SYNCHRONIZE
 * 			                  
 * 			           
 * 			//--BUILDERS & FUNCTIONS
 * 			         			
 * 			        			
 * 			//-- REPOSITORIES
 *
 **/

// {build::BuildUnit} documentation=DOCUMENTATION? executionMode=ExecutionMode? "unit"
// name=UnitName? ("version" version=VersionLiteral)? ("implements" implements+=
// SimpleTypeRef ("," implements+=SimpleTypeRef)*)? "{" ("default" "properties"
// defaultProperties=PropertySet)? ("provides" "{" (unitProvidedCapabilities+=
// ProvidedCapability ";")+ "}"|"provides" unitProvidedCapabilities+=
// ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=RequiredCapability ";")
// + "}"|"requires" requiredCapabilities+=RequiredCapability ";"|"env" "requires" "{" (
// metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"env" "requires"
// metaRequiredCapabilities+=RequiredCapability ";"|concerns+=Concern_Named|
// "sequential" "{" synchronizations+=Synchronization+ "}"|"sequential"
// synchronizations+=Synchronization|builders+=Builder|functions+=Function|
// "repositories" "{" repositories+=RepositoryConfiguration* "}"|"properties"
// propertySets+=PropertySet_Named|"containers" "{" containers+=
// ContainerConfiguration* "}")* "}"   
// 	    
// 	    
// 	          
// 		           
// 	
// 			 //-- PROPERTIES
// 			 // goes first, because they may be used in the other clauses. TODO: can probably be relaxed
// 			 // since linking will find them anyway.
// 			 //
// 			            
// 		
// 		 	 //-- PROVIDES
// 			               
// 			          
// 			//-- REQUIRES & META REQUIRES
// 			               
// 			          
// 			                  
// 			            
// 			//--CONCERNS
// 			       
// 			//--SYNCHRONIZE
// 			                  
// 			           
// 			//--BUILDERS & FUNCTIONS
// 			         			
// 			        			
// 			//-- REPOSITORIES
protected class BuildUnit_Group extends GroupToken {
	
	public BuildUnit_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RightCurlyBracketKeyword_10(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBuildUnitRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::BuildUnit}
protected class BuildUnit_BuildUnitAction_0 extends ActionToken  {

	public BuildUnit_BuildUnitAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getBuildUnitAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBuildUnitAccess().getBuildUnitAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// documentation=DOCUMENTATION?
protected class BuildUnit_DocumentationAssignment_1 extends AssignmentToken  {
	
	public BuildUnit_DocumentationAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getDocumentationAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_BuildUnitAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("documentation",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("documentation");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBuildUnitAccess().getDocumentationDOCUMENTATIONTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// executionMode=ExecutionMode?
protected class BuildUnit_ExecutionModeAssignment_2 extends AssignmentToken  {
	
	public BuildUnit_ExecutionModeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getExecutionModeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_DocumentationAssignment_1(parent, this, 0, inst);
			case 1: return new BuildUnit_BuildUnitAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("executionMode",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("executionMode");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getBuildUnitAccess().getExecutionModeExecutionModeEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "unit"
protected class BuildUnit_UnitKeyword_3 extends KeywordToken  {
	
	public BuildUnit_UnitKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getUnitKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_ExecutionModeAssignment_2(parent, this, 0, inst);
			case 1: return new BuildUnit_DocumentationAssignment_1(parent, this, 1, inst);
			case 2: return new BuildUnit_BuildUnitAction_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// name=UnitName?
protected class BuildUnit_NameAssignment_4 extends AssignmentToken  {
	
	public BuildUnit_NameAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getNameAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_UnitKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getBuildUnitAccess().getNameUnitNameParserRuleCall_4_0();
			return obj;
		}
		return null;
	}

}

// ("version" version=VersionLiteral)?
protected class BuildUnit_Group_5 extends GroupToken {
	
	public BuildUnit_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_VersionAssignment_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "version"
protected class BuildUnit_VersionKeyword_5_0 extends KeywordToken  {
	
	public BuildUnit_VersionKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getVersionKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_NameAssignment_4(parent, this, 0, inst);
			case 1: return new BuildUnit_UnitKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// version=VersionLiteral
protected class BuildUnit_VersionAssignment_5_1 extends AssignmentToken  {
	
	public BuildUnit_VersionAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getVersionAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_VersionKeyword_5_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("version",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("version");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getBuildUnitAccess().getVersionVersionLiteralParserRuleCall_5_1_0();
			return obj;
		}
		return null;
	}

}


// ("implements" implements+=SimpleTypeRef ("," implements+=SimpleTypeRef)*)?
protected class BuildUnit_Group_6 extends GroupToken {
	
	public BuildUnit_Group_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group_6_2(parent, this, 0, inst);
			case 1: return new BuildUnit_ImplementsAssignment_6_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "implements"
protected class BuildUnit_ImplementsKeyword_6_0 extends KeywordToken  {
	
	public BuildUnit_ImplementsKeyword_6_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getImplementsKeyword_6_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group_5(parent, this, 0, inst);
			case 1: return new BuildUnit_NameAssignment_4(parent, this, 1, inst);
			case 2: return new BuildUnit_UnitKeyword_3(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// implements+=SimpleTypeRef
protected class BuildUnit_ImplementsAssignment_6_1 extends AssignmentToken  {
	
	public BuildUnit_ImplementsAssignment_6_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getImplementsAssignment_6_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("implements",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("implements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getImplementsSimpleTypeRefParserRuleCall_6_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_ImplementsKeyword_6_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," implements+=SimpleTypeRef)*
protected class BuildUnit_Group_6_2 extends GroupToken {
	
	public BuildUnit_Group_6_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_6_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_ImplementsAssignment_6_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class BuildUnit_CommaKeyword_6_2_0 extends KeywordToken  {
	
	public BuildUnit_CommaKeyword_6_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getCommaKeyword_6_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group_6_2(parent, this, 0, inst);
			case 1: return new BuildUnit_ImplementsAssignment_6_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// implements+=SimpleTypeRef
protected class BuildUnit_ImplementsAssignment_6_2_1 extends AssignmentToken  {
	
	public BuildUnit_ImplementsAssignment_6_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getImplementsAssignment_6_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("implements",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("implements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getImplementsSimpleTypeRefParserRuleCall_6_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_CommaKeyword_6_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "{"
protected class BuildUnit_LeftCurlyBracketKeyword_7 extends KeywordToken  {
	
	public BuildUnit_LeftCurlyBracketKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getLeftCurlyBracketKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group_6(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_5(parent, this, 1, inst);
			case 2: return new BuildUnit_NameAssignment_4(parent, this, 2, inst);
			case 3: return new BuildUnit_UnitKeyword_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// ("default" "properties" defaultProperties=PropertySet)?
protected class BuildUnit_Group_8 extends GroupToken {
	
	public BuildUnit_Group_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_DefaultPropertiesAssignment_8_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "default"
protected class BuildUnit_DefaultKeyword_8_0 extends KeywordToken  {
	
	public BuildUnit_DefaultKeyword_8_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getDefaultKeyword_8_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "properties"
protected class BuildUnit_PropertiesKeyword_8_1 extends KeywordToken  {
	
	public BuildUnit_PropertiesKeyword_8_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getPropertiesKeyword_8_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_DefaultKeyword_8_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// defaultProperties=PropertySet
protected class BuildUnit_DefaultPropertiesAssignment_8_2 extends AssignmentToken  {
	
	public BuildUnit_DefaultPropertiesAssignment_8_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getDefaultPropertiesAssignment_8_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("defaultProperties",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("defaultProperties");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getDefaultPropertiesPropertySetParserRuleCall_8_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_PropertiesKeyword_8_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ("provides" "{" (unitProvidedCapabilities+=ProvidedCapability ";")+ "}"|"provides"
// unitProvidedCapabilities+=ProvidedCapability ";"|"requires" "{" (
// requiredCapabilities+=RequiredCapability ";")+ "}"|"requires" requiredCapabilities
// +=RequiredCapability ";"|"env" "requires" "{" (metaRequiredCapabilities+=
// RequiredCapability ";")+ "}"|"env" "requires" metaRequiredCapabilities+=
// RequiredCapability ";"|concerns+=Concern_Named|"sequential" "{" synchronizations+=
// Synchronization+ "}"|"sequential" synchronizations+=Synchronization|builders+=
// Builder|functions+=Function|"repositories" "{" repositories+=
// RepositoryConfiguration* "}"|"properties" propertySets+=PropertySet_Named|
// "containers" "{" containers+=ContainerConfiguration* "}")* 
// 		 	 //-- PROVIDES
// 			               
// 			          
// 			//-- REQUIRES & META REQUIRES
// 			               
// 			          
// 			                  
// 			            
// 			//--CONCERNS
// 			       
// 			//--SYNCHRONIZE
// 			                  
// 			           
// 			//--BUILDERS & FUNCTIONS
// 			         			
// 			        			
// 			//-- REPOSITORIES
protected class BuildUnit_Alternatives_9 extends AlternativesToken {

	public BuildUnit_Alternatives_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getAlternatives_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group_9_0(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_9_1(parent, this, 1, inst);
			case 2: return new BuildUnit_Group_9_2(parent, this, 2, inst);
			case 3: return new BuildUnit_Group_9_3(parent, this, 3, inst);
			case 4: return new BuildUnit_Group_9_4(parent, this, 4, inst);
			case 5: return new BuildUnit_Group_9_5(parent, this, 5, inst);
			case 6: return new BuildUnit_ConcernsAssignment_9_6(parent, this, 6, inst);
			case 7: return new BuildUnit_Group_9_7(parent, this, 7, inst);
			case 8: return new BuildUnit_Group_9_8(parent, this, 8, inst);
			case 9: return new BuildUnit_BuildersAssignment_9_9(parent, this, 9, inst);
			case 10: return new BuildUnit_FunctionsAssignment_9_10(parent, this, 10, inst);
			case 11: return new BuildUnit_Group_9_11(parent, this, 11, inst);
			case 12: return new BuildUnit_Group_9_12(parent, this, 12, inst);
			case 13: return new BuildUnit_Group_9_13(parent, this, 13, inst);
			default: return null;
		}	
	}	
		
}

// "provides" "{" (unitProvidedCapabilities+=ProvidedCapability ";")+ "}"
protected class BuildUnit_Group_9_0 extends GroupToken {
	
	public BuildUnit_Group_9_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RightCurlyBracketKeyword_9_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "provides"
protected class BuildUnit_ProvidesKeyword_9_0_0 extends KeywordToken  {
	
	public BuildUnit_ProvidesKeyword_9_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getProvidesKeyword_9_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class BuildUnit_LeftCurlyBracketKeyword_9_0_1 extends KeywordToken  {
	
	public BuildUnit_LeftCurlyBracketKeyword_9_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getLeftCurlyBracketKeyword_9_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_ProvidesKeyword_9_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (unitProvidedCapabilities+=ProvidedCapability ";")+
protected class BuildUnit_Group_9_0_2 extends GroupToken {
	
	public BuildUnit_Group_9_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SemicolonKeyword_9_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// unitProvidedCapabilities+=ProvidedCapability
protected class BuildUnit_UnitProvidedCapabilitiesAssignment_9_0_2_0 extends AssignmentToken  {
	
	public BuildUnit_UnitProvidedCapabilitiesAssignment_9_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getUnitProvidedCapabilitiesAssignment_9_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("unitProvidedCapabilities",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("unitProvidedCapabilities");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getProvidedCapabilityRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getUnitProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_0_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_Group_9_0_2(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_LeftCurlyBracketKeyword_9_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BuildUnit_SemicolonKeyword_9_0_2_1 extends KeywordToken  {
	
	public BuildUnit_SemicolonKeyword_9_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSemicolonKeyword_9_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_UnitProvidedCapabilitiesAssignment_9_0_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class BuildUnit_RightCurlyBracketKeyword_9_0_3 extends KeywordToken  {
	
	public BuildUnit_RightCurlyBracketKeyword_9_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRightCurlyBracketKeyword_9_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group_9_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "provides" unitProvidedCapabilities+=ProvidedCapability ";"
protected class BuildUnit_Group_9_1 extends GroupToken {
	
	public BuildUnit_Group_9_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SemicolonKeyword_9_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "provides"
protected class BuildUnit_ProvidesKeyword_9_1_0 extends KeywordToken  {
	
	public BuildUnit_ProvidesKeyword_9_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getProvidesKeyword_9_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// unitProvidedCapabilities+=ProvidedCapability
protected class BuildUnit_UnitProvidedCapabilitiesAssignment_9_1_1 extends AssignmentToken  {
	
	public BuildUnit_UnitProvidedCapabilitiesAssignment_9_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getUnitProvidedCapabilitiesAssignment_9_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("unitProvidedCapabilities",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("unitProvidedCapabilities");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getProvidedCapabilityRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getUnitProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_ProvidesKeyword_9_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BuildUnit_SemicolonKeyword_9_1_2 extends KeywordToken  {
	
	public BuildUnit_SemicolonKeyword_9_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSemicolonKeyword_9_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_UnitProvidedCapabilitiesAssignment_9_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "requires" "{" (requiredCapabilities+=RequiredCapability ";")+ "}"
protected class BuildUnit_Group_9_2 extends GroupToken {
	
	public BuildUnit_Group_9_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RightCurlyBracketKeyword_9_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "requires"
protected class BuildUnit_RequiresKeyword_9_2_0 extends KeywordToken  {
	
	public BuildUnit_RequiresKeyword_9_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRequiresKeyword_9_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class BuildUnit_LeftCurlyBracketKeyword_9_2_1 extends KeywordToken  {
	
	public BuildUnit_LeftCurlyBracketKeyword_9_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getLeftCurlyBracketKeyword_9_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RequiresKeyword_9_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (requiredCapabilities+=RequiredCapability ";")+
protected class BuildUnit_Group_9_2_2 extends GroupToken {
	
	public BuildUnit_Group_9_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SemicolonKeyword_9_2_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// requiredCapabilities+=RequiredCapability
protected class BuildUnit_RequiredCapabilitiesAssignment_9_2_2_0 extends AssignmentToken  {
	
	public BuildUnit_RequiredCapabilitiesAssignment_9_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRequiredCapabilitiesAssignment_9_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("requiredCapabilities",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("requiredCapabilities");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRequiredCapabilityRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_2_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_Group_9_2_2(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_LeftCurlyBracketKeyword_9_2_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BuildUnit_SemicolonKeyword_9_2_2_1 extends KeywordToken  {
	
	public BuildUnit_SemicolonKeyword_9_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSemicolonKeyword_9_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RequiredCapabilitiesAssignment_9_2_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class BuildUnit_RightCurlyBracketKeyword_9_2_3 extends KeywordToken  {
	
	public BuildUnit_RightCurlyBracketKeyword_9_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRightCurlyBracketKeyword_9_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group_9_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "requires" requiredCapabilities+=RequiredCapability ";"
protected class BuildUnit_Group_9_3 extends GroupToken {
	
	public BuildUnit_Group_9_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SemicolonKeyword_9_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "requires"
protected class BuildUnit_RequiresKeyword_9_3_0 extends KeywordToken  {
	
	public BuildUnit_RequiresKeyword_9_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRequiresKeyword_9_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// requiredCapabilities+=RequiredCapability
protected class BuildUnit_RequiredCapabilitiesAssignment_9_3_1 extends AssignmentToken  {
	
	public BuildUnit_RequiredCapabilitiesAssignment_9_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRequiredCapabilitiesAssignment_9_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("requiredCapabilities",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("requiredCapabilities");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRequiredCapabilityRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_RequiresKeyword_9_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BuildUnit_SemicolonKeyword_9_3_2 extends KeywordToken  {
	
	public BuildUnit_SemicolonKeyword_9_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSemicolonKeyword_9_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RequiredCapabilitiesAssignment_9_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "env" "requires" "{" (metaRequiredCapabilities+=RequiredCapability ";")+ "}"
protected class BuildUnit_Group_9_4 extends GroupToken {
	
	public BuildUnit_Group_9_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RightCurlyBracketKeyword_9_4_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "env"
protected class BuildUnit_EnvKeyword_9_4_0 extends KeywordToken  {
	
	public BuildUnit_EnvKeyword_9_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getEnvKeyword_9_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "requires"
protected class BuildUnit_RequiresKeyword_9_4_1 extends KeywordToken  {
	
	public BuildUnit_RequiresKeyword_9_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRequiresKeyword_9_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_EnvKeyword_9_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class BuildUnit_LeftCurlyBracketKeyword_9_4_2 extends KeywordToken  {
	
	public BuildUnit_LeftCurlyBracketKeyword_9_4_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getLeftCurlyBracketKeyword_9_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RequiresKeyword_9_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (metaRequiredCapabilities+=RequiredCapability ";")+
protected class BuildUnit_Group_9_4_3 extends GroupToken {
	
	public BuildUnit_Group_9_4_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_4_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SemicolonKeyword_9_4_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// metaRequiredCapabilities+=RequiredCapability
protected class BuildUnit_MetaRequiredCapabilitiesAssignment_9_4_3_0 extends AssignmentToken  {
	
	public BuildUnit_MetaRequiredCapabilitiesAssignment_9_4_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getMetaRequiredCapabilitiesAssignment_9_4_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("metaRequiredCapabilities",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("metaRequiredCapabilities");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRequiredCapabilityRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_4_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_Group_9_4_3(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_LeftCurlyBracketKeyword_9_4_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BuildUnit_SemicolonKeyword_9_4_3_1 extends KeywordToken  {
	
	public BuildUnit_SemicolonKeyword_9_4_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSemicolonKeyword_9_4_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_MetaRequiredCapabilitiesAssignment_9_4_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class BuildUnit_RightCurlyBracketKeyword_9_4_4 extends KeywordToken  {
	
	public BuildUnit_RightCurlyBracketKeyword_9_4_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRightCurlyBracketKeyword_9_4_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Group_9_4_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "env" "requires" metaRequiredCapabilities+=RequiredCapability ";"
protected class BuildUnit_Group_9_5 extends GroupToken {
	
	public BuildUnit_Group_9_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SemicolonKeyword_9_5_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "env"
protected class BuildUnit_EnvKeyword_9_5_0 extends KeywordToken  {
	
	public BuildUnit_EnvKeyword_9_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getEnvKeyword_9_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "requires"
protected class BuildUnit_RequiresKeyword_9_5_1 extends KeywordToken  {
	
	public BuildUnit_RequiresKeyword_9_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRequiresKeyword_9_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_EnvKeyword_9_5_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// metaRequiredCapabilities+=RequiredCapability
protected class BuildUnit_MetaRequiredCapabilitiesAssignment_9_5_2 extends AssignmentToken  {
	
	public BuildUnit_MetaRequiredCapabilitiesAssignment_9_5_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getMetaRequiredCapabilitiesAssignment_9_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("metaRequiredCapabilities",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("metaRequiredCapabilities");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRequiredCapabilityRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_5_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_RequiresKeyword_9_5_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BuildUnit_SemicolonKeyword_9_5_3 extends KeywordToken  {
	
	public BuildUnit_SemicolonKeyword_9_5_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSemicolonKeyword_9_5_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_MetaRequiredCapabilitiesAssignment_9_5_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// concerns+=Concern_Named
protected class BuildUnit_ConcernsAssignment_9_6 extends AssignmentToken  {
	
	public BuildUnit_ConcernsAssignment_9_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getConcernsAssignment_9_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("concerns",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("concerns");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcern_NamedRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getConcernsConcern_NamedParserRuleCall_9_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_Group_8(parent, next, actIndex, consumed);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "sequential" "{" synchronizations+=Synchronization+ "}"
protected class BuildUnit_Group_9_7 extends GroupToken {
	
	public BuildUnit_Group_9_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RightCurlyBracketKeyword_9_7_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "sequential"
protected class BuildUnit_SequentialKeyword_9_7_0 extends KeywordToken  {
	
	public BuildUnit_SequentialKeyword_9_7_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSequentialKeyword_9_7_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class BuildUnit_LeftCurlyBracketKeyword_9_7_1 extends KeywordToken  {
	
	public BuildUnit_LeftCurlyBracketKeyword_9_7_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getLeftCurlyBracketKeyword_9_7_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SequentialKeyword_9_7_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// synchronizations+=Synchronization+
protected class BuildUnit_SynchronizationsAssignment_9_7_2 extends AssignmentToken  {
	
	public BuildUnit_SynchronizationsAssignment_9_7_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSynchronizationsAssignment_9_7_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Synchronization_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("synchronizations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("synchronizations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSynchronizationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getSynchronizationsSynchronizationParserRuleCall_9_7_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_SynchronizationsAssignment_9_7_2(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_LeftCurlyBracketKeyword_9_7_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class BuildUnit_RightCurlyBracketKeyword_9_7_3 extends KeywordToken  {
	
	public BuildUnit_RightCurlyBracketKeyword_9_7_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRightCurlyBracketKeyword_9_7_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SynchronizationsAssignment_9_7_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "sequential" synchronizations+=Synchronization
protected class BuildUnit_Group_9_8 extends GroupToken {
	
	public BuildUnit_Group_9_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_SynchronizationsAssignment_9_8_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "sequential"
protected class BuildUnit_SequentialKeyword_9_8_0 extends KeywordToken  {
	
	public BuildUnit_SequentialKeyword_9_8_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSequentialKeyword_9_8_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// synchronizations+=Synchronization
protected class BuildUnit_SynchronizationsAssignment_9_8_1 extends AssignmentToken  {
	
	public BuildUnit_SynchronizationsAssignment_9_8_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getSynchronizationsAssignment_9_8_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Synchronization_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("synchronizations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("synchronizations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSynchronizationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getSynchronizationsSynchronizationParserRuleCall_9_8_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_SequentialKeyword_9_8_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// builders+=Builder
protected class BuildUnit_BuildersAssignment_9_9 extends AssignmentToken  {
	
	public BuildUnit_BuildersAssignment_9_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getBuildersAssignment_9_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("builders",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("builders");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBuilderRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getBuildersBuilderParserRuleCall_9_9_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_Group_8(parent, next, actIndex, consumed);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// functions+=Function
protected class BuildUnit_FunctionsAssignment_9_10 extends AssignmentToken  {
	
	public BuildUnit_FunctionsAssignment_9_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getFunctionsAssignment_9_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getFunctionsFunctionParserRuleCall_9_10_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_Group_8(parent, next, actIndex, consumed);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "repositories" "{" repositories+=RepositoryConfiguration* "}"
protected class BuildUnit_Group_9_11 extends GroupToken {
	
	public BuildUnit_Group_9_11(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_11();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RightCurlyBracketKeyword_9_11_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "repositories"
protected class BuildUnit_RepositoriesKeyword_9_11_0 extends KeywordToken  {
	
	public BuildUnit_RepositoriesKeyword_9_11_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRepositoriesKeyword_9_11_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class BuildUnit_LeftCurlyBracketKeyword_9_11_1 extends KeywordToken  {
	
	public BuildUnit_LeftCurlyBracketKeyword_9_11_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getLeftCurlyBracketKeyword_9_11_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RepositoriesKeyword_9_11_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// repositories+=RepositoryConfiguration*
protected class BuildUnit_RepositoriesAssignment_9_11_2 extends AssignmentToken  {
	
	public BuildUnit_RepositoriesAssignment_9_11_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRepositoriesAssignment_9_11_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryConfiguration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("repositories",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("repositories");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRepositoryConfigurationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getRepositoriesRepositoryConfigurationParserRuleCall_9_11_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_RepositoriesAssignment_9_11_2(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_LeftCurlyBracketKeyword_9_11_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class BuildUnit_RightCurlyBracketKeyword_9_11_3 extends KeywordToken  {
	
	public BuildUnit_RightCurlyBracketKeyword_9_11_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRightCurlyBracketKeyword_9_11_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RepositoriesAssignment_9_11_2(parent, this, 0, inst);
			case 1: return new BuildUnit_LeftCurlyBracketKeyword_9_11_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// "properties" propertySets+=PropertySet_Named
protected class BuildUnit_Group_9_12 extends GroupToken {
	
	public BuildUnit_Group_9_12(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_12();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_PropertySetsAssignment_9_12_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "properties"
protected class BuildUnit_PropertiesKeyword_9_12_0 extends KeywordToken  {
	
	public BuildUnit_PropertiesKeyword_9_12_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getPropertiesKeyword_9_12_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// propertySets+=PropertySet_Named
protected class BuildUnit_PropertySetsAssignment_9_12_1 extends AssignmentToken  {
	
	public BuildUnit_PropertySetsAssignment_9_12_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getPropertySetsAssignment_9_12_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("propertySets",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("propertySets");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySet_NamedRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getPropertySetsPropertySet_NamedParserRuleCall_9_12_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_PropertiesKeyword_9_12_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "containers" "{" containers+=ContainerConfiguration* "}"
protected class BuildUnit_Group_9_13 extends GroupToken {
	
	public BuildUnit_Group_9_13(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getGroup_9_13();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_RightCurlyBracketKeyword_9_13_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "containers"
protected class BuildUnit_ContainersKeyword_9_13_0 extends KeywordToken  {
	
	public BuildUnit_ContainersKeyword_9_13_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getContainersKeyword_9_13_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class BuildUnit_LeftCurlyBracketKeyword_9_13_1 extends KeywordToken  {
	
	public BuildUnit_LeftCurlyBracketKeyword_9_13_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getLeftCurlyBracketKeyword_9_13_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_ContainersKeyword_9_13_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// containers+=ContainerConfiguration*
protected class BuildUnit_ContainersAssignment_9_13_2 extends AssignmentToken  {
	
	public BuildUnit_ContainersAssignment_9_13_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getContainersAssignment_9_13_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContainerConfiguration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("containers",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("containers");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getContainerConfigurationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuildUnitAccess().getContainersContainerConfigurationParserRuleCall_9_13_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuildUnit_ContainersAssignment_9_13_2(parent, next, actIndex, consumed);
			case 1: return new BuildUnit_LeftCurlyBracketKeyword_9_13_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class BuildUnit_RightCurlyBracketKeyword_9_13_3 extends KeywordToken  {
	
	public BuildUnit_RightCurlyBracketKeyword_9_13_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRightCurlyBracketKeyword_9_13_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_ContainersAssignment_9_13_2(parent, this, 0, inst);
			case 1: return new BuildUnit_LeftCurlyBracketKeyword_9_13_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



// "}"
protected class BuildUnit_RightCurlyBracketKeyword_10 extends KeywordToken  {
	
	public BuildUnit_RightCurlyBracketKeyword_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuildUnitAccess().getRightCurlyBracketKeyword_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildUnit_Alternatives_9(parent, this, 0, inst);
			case 1: return new BuildUnit_Group_8(parent, this, 1, inst);
			case 2: return new BuildUnit_LeftCurlyBracketKeyword_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule BuildUnit ****************/


/************ begin Rule ProvidedCapability ****************
 *
 * ProvidedCapability returns build::VersionedCapability:
 *   {build::VersionedCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
 *   InterfaceName "/" name=CapabilityName ("/" version=VersionLiteral)?;
 *
 **/

// {build::VersionedCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
// InterfaceName "/" name=CapabilityName ("/" version=VersionLiteral)?
protected class ProvidedCapability_Group extends GroupToken {
	
	public ProvidedCapability_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_Group_5(parent, this, 0, inst);
			case 1: return new ProvidedCapability_NameAssignment_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getProvidedCapabilityRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::VersionedCapability}
protected class ProvidedCapability_VersionedCapabilityAction_0 extends ActionToken  {

	public ProvidedCapability_VersionedCapabilityAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getVersionedCapabilityAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getProvidedCapabilityAccess().getVersionedCapabilityAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ("when" "(" condExpr=Expression ")")?
protected class ProvidedCapability_Group_1 extends GroupToken {
	
	public ProvidedCapability_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_RightParenthesisKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "when"
protected class ProvidedCapability_WhenKeyword_1_0 extends KeywordToken  {
	
	public ProvidedCapability_WhenKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getWhenKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_VersionedCapabilityAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class ProvidedCapability_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public ProvidedCapability_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_WhenKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// condExpr=Expression
protected class ProvidedCapability_CondExprAssignment_1_2 extends AssignmentToken  {
	
	public ProvidedCapability_CondExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getCondExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getProvidedCapabilityAccess().getCondExprExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ProvidedCapability_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class ProvidedCapability_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public ProvidedCapability_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getRightParenthesisKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_CondExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// nameSpace=InterfaceName
protected class ProvidedCapability_NameSpaceAssignment_2 extends AssignmentToken  {
	
	public ProvidedCapability_NameSpaceAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getNameSpaceAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_Group_1(parent, this, 0, inst);
			case 1: return new ProvidedCapability_VersionedCapabilityAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("nameSpace",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nameSpace");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getProvidedCapabilityAccess().getNameSpaceInterfaceNameParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "/"
protected class ProvidedCapability_SolidusKeyword_3 extends KeywordToken  {
	
	public ProvidedCapability_SolidusKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getSolidusKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_NameSpaceAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=CapabilityName
protected class ProvidedCapability_NameAssignment_4 extends AssignmentToken  {
	
	public ProvidedCapability_NameAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getNameAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_SolidusKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getProvidedCapabilityAccess().getNameCapabilityNameParserRuleCall_4_0();
			return obj;
		}
		return null;
	}

}

// ("/" version=VersionLiteral)?
protected class ProvidedCapability_Group_5 extends GroupToken {
	
	public ProvidedCapability_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_VersionAssignment_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class ProvidedCapability_SolidusKeyword_5_0 extends KeywordToken  {
	
	public ProvidedCapability_SolidusKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getSolidusKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_NameAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// version=VersionLiteral
protected class ProvidedCapability_VersionAssignment_5_1 extends AssignmentToken  {
	
	public ProvidedCapability_VersionAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getProvidedCapabilityAccess().getVersionAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_SolidusKeyword_5_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("version",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("version");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getProvidedCapabilityAccess().getVersionVersionLiteralParserRuleCall_5_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule ProvidedCapability ****************/


/************ begin Rule RequiredCapability ****************
 *
 * RequiredCapability returns build::RequiredCapability:
 *   {build::RequiredCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
 *   InterfaceName "/" name=CapabilityName ("/" versionRange=VersionRangeLiteral)?;
 *
 **/

// {build::RequiredCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
// InterfaceName "/" name=CapabilityName ("/" versionRange=VersionRangeLiteral)?
protected class RequiredCapability_Group extends GroupToken {
	
	public RequiredCapability_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Group_5(parent, this, 0, inst);
			case 1: return new RequiredCapability_NameAssignment_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRequiredCapabilityRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::RequiredCapability}
protected class RequiredCapability_RequiredCapabilityAction_0 extends ActionToken  {

	public RequiredCapability_RequiredCapabilityAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getRequiredCapabilityAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRequiredCapabilityAccess().getRequiredCapabilityAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ("when" "(" condExpr=Expression ")")?
protected class RequiredCapability_Group_1 extends GroupToken {
	
	public RequiredCapability_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_RightParenthesisKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "when"
protected class RequiredCapability_WhenKeyword_1_0 extends KeywordToken  {
	
	public RequiredCapability_WhenKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getWhenKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_RequiredCapabilityAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class RequiredCapability_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public RequiredCapability_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_WhenKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// condExpr=Expression
protected class RequiredCapability_CondExprAssignment_1_2 extends AssignmentToken  {
	
	public RequiredCapability_CondExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getCondExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRequiredCapabilityAccess().getCondExprExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RequiredCapability_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class RequiredCapability_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public RequiredCapability_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getRightParenthesisKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_CondExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// nameSpace=InterfaceName
protected class RequiredCapability_NameSpaceAssignment_2 extends AssignmentToken  {
	
	public RequiredCapability_NameSpaceAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getNameSpaceAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Group_1(parent, this, 0, inst);
			case 1: return new RequiredCapability_RequiredCapabilityAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("nameSpace",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nameSpace");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRequiredCapabilityAccess().getNameSpaceInterfaceNameParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "/"
protected class RequiredCapability_SolidusKeyword_3 extends KeywordToken  {
	
	public RequiredCapability_SolidusKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getSolidusKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_NameSpaceAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=CapabilityName
protected class RequiredCapability_NameAssignment_4 extends AssignmentToken  {
	
	public RequiredCapability_NameAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getNameAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_SolidusKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRequiredCapabilityAccess().getNameCapabilityNameParserRuleCall_4_0();
			return obj;
		}
		return null;
	}

}

// ("/" versionRange=VersionRangeLiteral)?
protected class RequiredCapability_Group_5 extends GroupToken {
	
	public RequiredCapability_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_VersionRangeAssignment_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class RequiredCapability_SolidusKeyword_5_0 extends KeywordToken  {
	
	public RequiredCapability_SolidusKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getSolidusKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_NameAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// versionRange=VersionRangeLiteral
protected class RequiredCapability_VersionRangeAssignment_5_1 extends AssignmentToken  {
	
	public RequiredCapability_VersionRangeAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiredCapabilityAccess().getVersionRangeAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_SolidusKeyword_5_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("versionRange",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("versionRange");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRequiredCapabilityAccess().getVersionRangeVersionRangeLiteralParserRuleCall_5_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule RequiredCapability ****************/


/************ begin Rule RequiredCapability_Unfiltered ****************
 *
 * RequiredCapability_Unfiltered returns build::RequiredCapability:
 *   {build::RequiredCapability} nameSpace=InterfaceName "/" name=CapabilityName ("/"
 *   versionRange=VersionRangeLiteral)?; 
 * 	
 *          
 * 	     
 * 	    
 * 	
 * 
 * // Requirement on a unit (in build unit namespace)
 *
 **/

// {build::RequiredCapability} nameSpace=InterfaceName "/" name=CapabilityName ("/"
// versionRange=VersionRangeLiteral)?
protected class RequiredCapability_Unfiltered_Group extends GroupToken {
	
	public RequiredCapability_Unfiltered_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnfilteredAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unfiltered_Group_4(parent, this, 0, inst);
			case 1: return new RequiredCapability_Unfiltered_NameAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRequiredCapability_UnfilteredRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::RequiredCapability}
protected class RequiredCapability_Unfiltered_RequiredCapabilityAction_0 extends ActionToken  {

	public RequiredCapability_Unfiltered_RequiredCapabilityAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnfilteredAccess().getRequiredCapabilityAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRequiredCapability_UnfilteredAccess().getRequiredCapabilityAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// nameSpace=InterfaceName
protected class RequiredCapability_Unfiltered_NameSpaceAssignment_1 extends AssignmentToken  {
	
	public RequiredCapability_Unfiltered_NameSpaceAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnfilteredAccess().getNameSpaceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unfiltered_RequiredCapabilityAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("nameSpace",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nameSpace");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRequiredCapability_UnfilteredAccess().getNameSpaceInterfaceNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "/"
protected class RequiredCapability_Unfiltered_SolidusKeyword_2 extends KeywordToken  {
	
	public RequiredCapability_Unfiltered_SolidusKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnfilteredAccess().getSolidusKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unfiltered_NameSpaceAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=CapabilityName
protected class RequiredCapability_Unfiltered_NameAssignment_3 extends AssignmentToken  {
	
	public RequiredCapability_Unfiltered_NameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnfilteredAccess().getNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unfiltered_SolidusKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRequiredCapability_UnfilteredAccess().getNameCapabilityNameParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// ("/" versionRange=VersionRangeLiteral)?
protected class RequiredCapability_Unfiltered_Group_4 extends GroupToken {
	
	public RequiredCapability_Unfiltered_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnfilteredAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unfiltered_VersionRangeAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class RequiredCapability_Unfiltered_SolidusKeyword_4_0 extends KeywordToken  {
	
	public RequiredCapability_Unfiltered_SolidusKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnfilteredAccess().getSolidusKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unfiltered_NameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// versionRange=VersionRangeLiteral
protected class RequiredCapability_Unfiltered_VersionRangeAssignment_4_1 extends AssignmentToken  {
	
	public RequiredCapability_Unfiltered_VersionRangeAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnfilteredAccess().getVersionRangeAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unfiltered_SolidusKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("versionRange",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("versionRange");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRequiredCapability_UnfilteredAccess().getVersionRangeVersionRangeLiteralParserRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule RequiredCapability_Unfiltered ****************/


/************ begin Rule RequiredCapability_Unit ****************
 *
 * RequiredCapability_Unit returns build::RequiredCapability:
 *   {build::RequiredCapability} (name=QID|"unit")?; 
 * 
 * // Requirement on a unit (in build unit namespace)
 *          
 * 	
 * 	
 * 	
 * // An optionally named sequence of property statements
 *
 **/

// {build::RequiredCapability} (name=QID|"unit")?
protected class RequiredCapability_Unit_Group extends GroupToken {
	
	public RequiredCapability_Unit_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnitAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unit_Alternatives_1(parent, this, 0, inst);
			case 1: return new RequiredCapability_Unit_RequiredCapabilityAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRequiredCapability_UnitRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::RequiredCapability}
protected class RequiredCapability_Unit_RequiredCapabilityAction_0 extends ActionToken  {

	public RequiredCapability_Unit_RequiredCapabilityAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnitAccess().getRequiredCapabilityAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRequiredCapability_UnitAccess().getRequiredCapabilityAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// (name=QID|"unit")?
protected class RequiredCapability_Unit_Alternatives_1 extends AlternativesToken {

	public RequiredCapability_Unit_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnitAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unit_NameAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=QID
protected class RequiredCapability_Unit_NameAssignment_1_0 extends AssignmentToken  {
	
	public RequiredCapability_Unit_NameAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiredCapability_UnitAccess().getNameAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unit_RequiredCapabilityAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRequiredCapability_UnitAccess().getNameQIDParserRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule RequiredCapability_Unit ****************/


/************ begin Rule PropertySet_Named ****************
 *
 * PropertySet_Named returns be::BPropertySet:
 *   {be::BPropertySet} name=ID ("extends" extends=[be::BPropertySet|QIDREF])? "{"
 *   operations+=PropertyOperation* "}"; 
 * 	
 * // An optionally named sequence of property statements
 *          
 * 	                         
 * 	
 * 
 * // Sequence of possibly filtered property statements
 *
 **/

// {be::BPropertySet} name=ID ("extends" extends=[be::BPropertySet|QIDREF])? "{"
// operations+=PropertyOperation* "}"
protected class PropertySet_Named_Group extends GroupToken {
	
	public PropertySet_Named_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_RightCurlyBracketKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertySet_NamedRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BPropertySet}
protected class PropertySet_Named_BPropertySetAction_0 extends ActionToken  {

	public PropertySet_Named_BPropertySetAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getBPropertySetAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPropertySet_NamedAccess().getBPropertySetAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// name=ID
protected class PropertySet_Named_NameAssignment_1 extends AssignmentToken  {
	
	public PropertySet_Named_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_BPropertySetAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPropertySet_NamedAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("extends" extends=[be::BPropertySet|QIDREF])?
protected class PropertySet_Named_Group_2 extends GroupToken {
	
	public PropertySet_Named_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_ExtendsAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class PropertySet_Named_ExtendsKeyword_2_0 extends KeywordToken  {
	
	public PropertySet_Named_ExtendsKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getExtendsKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends=[be::BPropertySet|QIDREF]
protected class PropertySet_Named_ExtendsAssignment_2_1 extends AssignmentToken  {
	
	public PropertySet_Named_ExtendsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getExtendsAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_ExtendsKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySet_NamedAccess().getExtendsBPropertySetCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getPropertySet_NamedAccess().getExtendsBPropertySetCrossReference_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


// "{"
protected class PropertySet_Named_LeftCurlyBracketKeyword_3 extends KeywordToken  {
	
	public PropertySet_Named_LeftCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getLeftCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_Group_2(parent, this, 0, inst);
			case 1: return new PropertySet_Named_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// operations+=PropertyOperation*
protected class PropertySet_Named_OperationsAssignment_4 extends AssignmentToken  {
	
	public PropertySet_Named_OperationsAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getOperationsAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyOperation_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operations",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertyOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertySet_NamedAccess().getOperationsPropertyOperationParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertySet_Named_OperationsAssignment_4(parent, next, actIndex, consumed);
			case 1: return new PropertySet_Named_LeftCurlyBracketKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class PropertySet_Named_RightCurlyBracketKeyword_5 extends KeywordToken  {
	
	public PropertySet_Named_RightCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertySet_NamedAccess().getRightCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Named_OperationsAssignment_4(parent, this, 0, inst);
			case 1: return new PropertySet_Named_LeftCurlyBracketKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule PropertySet_Named ****************/


/************ begin Rule PropertySet ****************
 *
 * PropertySet returns be::BPropertySet:
 *   {be::BPropertySet} ("extends" extends=[be::BPropertySet|QIDREF])? "{" operations+=
 *   PropertyOperation* "}"; 
 * 
 * // Sequence of possibly filtered property statements	
 *          
 * 	                    
 * 	
 * 
 * // For model generation, to get supertype correct
 *
 **/

// {be::BPropertySet} ("extends" extends=[be::BPropertySet|QIDREF])? "{" operations+=
// PropertyOperation* "}"
protected class PropertySet_Group extends GroupToken {
	
	public PropertySet_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertySetAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertySetRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BPropertySet}
protected class PropertySet_BPropertySetAction_0 extends ActionToken  {

	public PropertySet_BPropertySetAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPropertySetAccess().getBPropertySetAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPropertySetAccess().getBPropertySetAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ("extends" extends=[be::BPropertySet|QIDREF])?
protected class PropertySet_Group_1 extends GroupToken {
	
	public PropertySet_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertySetAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_ExtendsAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class PropertySet_ExtendsKeyword_1_0 extends KeywordToken  {
	
	public PropertySet_ExtendsKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertySetAccess().getExtendsKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_BPropertySetAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends=[be::BPropertySet|QIDREF]
protected class PropertySet_ExtendsAssignment_1_1 extends AssignmentToken  {
	
	public PropertySet_ExtendsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertySetAccess().getExtendsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_ExtendsKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetAccess().getExtendsBPropertySetCrossReference_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getPropertySetAccess().getExtendsBPropertySetCrossReference_1_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


// "{"
protected class PropertySet_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public PropertySet_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertySetAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Group_1(parent, this, 0, inst);
			case 1: return new PropertySet_BPropertySetAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// operations+=PropertyOperation*
protected class PropertySet_OperationsAssignment_3 extends AssignmentToken  {
	
	public PropertySet_OperationsAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertySetAccess().getOperationsAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyOperation_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operations",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertyOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertySetAccess().getOperationsPropertyOperationParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertySet_OperationsAssignment_3(parent, next, actIndex, consumed);
			case 1: return new PropertySet_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class PropertySet_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public PropertySet_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertySetAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_OperationsAssignment_3(parent, this, 0, inst);
			case 1: return new PropertySet_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule PropertySet ****************/


/************ begin Rule PropertyOperation ****************
 *
 * PropertyOperation returns be::BPropertyOperation:
 *   ConditionalPropertyOperation|PropertyDefinitionOperation|PropertySetOperation; 
 * 
 * // For model generation, to get supertype correct
 *
 **/

// ConditionalPropertyOperation|PropertyDefinitionOperation|PropertySetOperation 
// 
// // For model generation, to get supertype correct
protected class PropertyOperation_Alternatives extends AlternativesToken {

	public PropertyOperation_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPropertyOperationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyOperation_ConditionalPropertyOperationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new PropertyOperation_PropertyDefinitionOperationParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PropertyOperation_PropertySetOperationParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertyOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ConditionalPropertyOperation
protected class PropertyOperation_ConditionalPropertyOperationParserRuleCall_0 extends RuleCallToken {
	
	public PropertyOperation_ConditionalPropertyOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPropertyOperationAccess().getConditionalPropertyOperationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalPropertyOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ConditionalPropertyOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConditionalPropertyOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// PropertyDefinitionOperation
protected class PropertyOperation_PropertyDefinitionOperationParserRuleCall_1 extends RuleCallToken {
	
	public PropertyOperation_PropertyDefinitionOperationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPropertyOperationAccess().getPropertyDefinitionOperationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyDefinitionOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PropertyDefinitionOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPropertyDefinitionOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// PropertySetOperation
protected class PropertyOperation_PropertySetOperationParserRuleCall_2 extends RuleCallToken {
	
	public PropertyOperation_PropertySetOperationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPropertyOperationAccess().getPropertySetOperationParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySetOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PropertySetOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPropertySetOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule PropertyOperation ****************/


/************ begin Rule ConditionalPropertyOperation ****************
 *
 * ConditionalPropertyOperation returns be::BPropertyOperation:
 *   {be::BConditionalPropertyOperation} "when" "(" condExpr=Expression ")" (body=
 *   PropertyDefinitionOperation|body=PropertySetOperation);
 *
 **/

// {be::BConditionalPropertyOperation} "when" "(" condExpr=Expression ")" (body=
// PropertyDefinitionOperation|body=PropertySetOperation)
protected class ConditionalPropertyOperation_Group extends GroupToken {
	
	public ConditionalPropertyOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalPropertyOperation_Alternatives_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConditionalPropertyOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BConditionalPropertyOperation}
protected class ConditionalPropertyOperation_BConditionalPropertyOperationAction_0 extends ActionToken  {

	public ConditionalPropertyOperation_BConditionalPropertyOperationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getBConditionalPropertyOperationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getConditionalPropertyOperationAccess().getBConditionalPropertyOperationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "when"
protected class ConditionalPropertyOperation_WhenKeyword_1 extends KeywordToken  {
	
	public ConditionalPropertyOperation_WhenKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getWhenKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalPropertyOperation_BConditionalPropertyOperationAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class ConditionalPropertyOperation_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public ConditionalPropertyOperation_LeftParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getLeftParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalPropertyOperation_WhenKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// condExpr=Expression
protected class ConditionalPropertyOperation_CondExprAssignment_3 extends AssignmentToken  {
	
	public ConditionalPropertyOperation_CondExprAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getCondExprAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConditionalPropertyOperationAccess().getCondExprExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConditionalPropertyOperation_LeftParenthesisKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class ConditionalPropertyOperation_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public ConditionalPropertyOperation_RightParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getRightParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalPropertyOperation_CondExprAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// body=PropertyDefinitionOperation|body=PropertySetOperation
protected class ConditionalPropertyOperation_Alternatives_5 extends AlternativesToken {

	public ConditionalPropertyOperation_Alternatives_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getAlternatives_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalPropertyOperation_BodyAssignment_5_0(parent, this, 0, inst);
			case 1: return new ConditionalPropertyOperation_BodyAssignment_5_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// body=PropertyDefinitionOperation
protected class ConditionalPropertyOperation_BodyAssignment_5_0 extends AssignmentToken  {
	
	public ConditionalPropertyOperation_BodyAssignment_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getBodyAssignment_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyDefinitionOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("body",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("body");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertyDefinitionOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConditionalPropertyOperationAccess().getBodyPropertyDefinitionOperationParserRuleCall_5_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConditionalPropertyOperation_RightParenthesisKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// body=PropertySetOperation
protected class ConditionalPropertyOperation_BodyAssignment_5_1 extends AssignmentToken  {
	
	public ConditionalPropertyOperation_BodyAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionalPropertyOperationAccess().getBodyAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySetOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("body",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("body");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConditionalPropertyOperationAccess().getBodyPropertySetOperationParserRuleCall_5_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConditionalPropertyOperation_RightParenthesisKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ConditionalPropertyOperation ****************/


/************ begin Rule PropertyDefinitionOperation ****************
 *
 * PropertyDefinitionOperation returns be::BPropertyOperation:
 *   {be::BPropertyDefinitionOperation} (definition=PropertyValDeclaration|definition=
 *   PropertyVarDeclaration); 
 *         
 * 	            
 * 	
 * 		
 * // property values, must be assigned (but can be assigned null).
 *
 **/

// {be::BPropertyDefinitionOperation} (definition=PropertyValDeclaration|definition=
// PropertyVarDeclaration)
protected class PropertyDefinitionOperation_Group extends GroupToken {
	
	public PropertyDefinitionOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyDefinitionOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyDefinitionOperation_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertyDefinitionOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BPropertyDefinitionOperation}
protected class PropertyDefinitionOperation_BPropertyDefinitionOperationAction_0 extends ActionToken  {

	public PropertyDefinitionOperation_BPropertyDefinitionOperationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPropertyDefinitionOperationAccess().getBPropertyDefinitionOperationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPropertyDefinitionOperationAccess().getBPropertyDefinitionOperationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// definition=PropertyValDeclaration|definition=PropertyVarDeclaration
protected class PropertyDefinitionOperation_Alternatives_1 extends AlternativesToken {

	public PropertyDefinitionOperation_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPropertyDefinitionOperationAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyDefinitionOperation_DefinitionAssignment_1_0(parent, this, 0, inst);
			case 1: return new PropertyDefinitionOperation_DefinitionAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// definition=PropertyValDeclaration
protected class PropertyDefinitionOperation_DefinitionAssignment_1_0 extends AssignmentToken  {
	
	public PropertyDefinitionOperation_DefinitionAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyDefinitionOperationAccess().getDefinitionAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("definition",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("definition");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertyValDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyDefinitionOperationAccess().getDefinitionPropertyValDeclarationParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyDefinitionOperation_BPropertyDefinitionOperationAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// definition=PropertyVarDeclaration
protected class PropertyDefinitionOperation_DefinitionAssignment_1_1 extends AssignmentToken  {
	
	public PropertyDefinitionOperation_DefinitionAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyDefinitionOperationAccess().getDefinitionAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyVarDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("definition",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("definition");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertyVarDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyDefinitionOperationAccess().getDefinitionPropertyVarDeclarationParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyDefinitionOperation_BPropertyDefinitionOperationAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule PropertyDefinitionOperation ****************/


/************ begin Rule PropertyValDeclaration ****************
 *
 * PropertyValDeclaration returns be::BDefProperty:
 *   {be::BDefProperty} final?="final"? type=TypeRef? name=PID "=" valueExpr=Expression ";"
 * ; 
 * 		
 * // property values, must be assigned (but can be assigned null).
 *          
 * 	                    
 * 	
 * 	
 * // property variables, value optionally assigned
 *
 **/

// {be::BDefProperty} final?="final"? type=TypeRef? name=PID "=" valueExpr=Expression ";"
protected class PropertyValDeclaration_Group extends GroupToken {
	
	public PropertyValDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyValDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValDeclaration_SemicolonKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertyValDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BDefProperty}
protected class PropertyValDeclaration_BDefPropertyAction_0 extends ActionToken  {

	public PropertyValDeclaration_BDefPropertyAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPropertyValDeclarationAccess().getBDefPropertyAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPropertyValDeclarationAccess().getBDefPropertyAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// final?="final"?
protected class PropertyValDeclaration_FinalAssignment_1 extends AssignmentToken  {
	
	public PropertyValDeclaration_FinalAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyValDeclarationAccess().getFinalAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValDeclaration_BDefPropertyAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("final",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("final");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPropertyValDeclarationAccess().getFinalFinalKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// type=TypeRef?
protected class PropertyValDeclaration_TypeAssignment_2 extends AssignmentToken  {
	
	public PropertyValDeclaration_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyValDeclarationAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyValDeclarationAccess().getTypeTypeRefParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyValDeclaration_FinalAssignment_1(parent, next, actIndex, consumed);
			case 1: return new PropertyValDeclaration_BDefPropertyAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// name=PID
protected class PropertyValDeclaration_NameAssignment_3 extends AssignmentToken  {
	
	public PropertyValDeclaration_NameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyValDeclarationAccess().getNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValDeclaration_TypeAssignment_2(parent, this, 0, inst);
			case 1: return new PropertyValDeclaration_FinalAssignment_1(parent, this, 1, inst);
			case 2: return new PropertyValDeclaration_BDefPropertyAction_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPropertyValDeclarationAccess().getNamePIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class PropertyValDeclaration_EqualsSignKeyword_4 extends KeywordToken  {
	
	public PropertyValDeclaration_EqualsSignKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertyValDeclarationAccess().getEqualsSignKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValDeclaration_NameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// valueExpr=Expression
protected class PropertyValDeclaration_ValueExprAssignment_5 extends AssignmentToken  {
	
	public PropertyValDeclaration_ValueExprAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyValDeclarationAccess().getValueExprAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("valueExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("valueExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyValDeclarationAccess().getValueExprExpressionParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyValDeclaration_EqualsSignKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class PropertyValDeclaration_SemicolonKeyword_6 extends KeywordToken  {
	
	public PropertyValDeclaration_SemicolonKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertyValDeclarationAccess().getSemicolonKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValDeclaration_ValueExprAssignment_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule PropertyValDeclaration ****************/


/************ begin Rule PropertyVarDeclaration ****************
 *
 * PropertyVarDeclaration returns be::BDefProperty:
 *   {be::BDefProperty} final?="final"? mutable?="mutable" type=TypeRef? name=PID ("="
 *   valueExpr=Expression)? ";"; 
 * 	
 * // property variables, value optionally assigned
 *
 **/

// {be::BDefProperty} final?="final"? mutable?="mutable" type=TypeRef? name=PID ("="
// valueExpr=Expression)? ";"
protected class PropertyVarDeclaration_Group extends GroupToken {
	
	public PropertyVarDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyVarDeclaration_SemicolonKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertyVarDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BDefProperty}
protected class PropertyVarDeclaration_BDefPropertyAction_0 extends ActionToken  {

	public PropertyVarDeclaration_BDefPropertyAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getBDefPropertyAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPropertyVarDeclarationAccess().getBDefPropertyAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// final?="final"?
protected class PropertyVarDeclaration_FinalAssignment_1 extends AssignmentToken  {
	
	public PropertyVarDeclaration_FinalAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getFinalAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyVarDeclaration_BDefPropertyAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("final",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("final");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPropertyVarDeclarationAccess().getFinalFinalKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// mutable?="mutable"
protected class PropertyVarDeclaration_MutableAssignment_2 extends AssignmentToken  {
	
	public PropertyVarDeclaration_MutableAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getMutableAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyVarDeclaration_FinalAssignment_1(parent, this, 0, inst);
			case 1: return new PropertyVarDeclaration_BDefPropertyAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("mutable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("mutable");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPropertyVarDeclarationAccess().getMutableMutableKeyword_2_0();
			return obj;
		}
		return null;
	}

}

// type=TypeRef?
protected class PropertyVarDeclaration_TypeAssignment_3 extends AssignmentToken  {
	
	public PropertyVarDeclaration_TypeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getTypeAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyVarDeclarationAccess().getTypeTypeRefParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyVarDeclaration_MutableAssignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// name=PID
protected class PropertyVarDeclaration_NameAssignment_4 extends AssignmentToken  {
	
	public PropertyVarDeclaration_NameAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getNameAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyVarDeclaration_TypeAssignment_3(parent, this, 0, inst);
			case 1: return new PropertyVarDeclaration_MutableAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPropertyVarDeclarationAccess().getNamePIDTerminalRuleCall_4_0();
			return obj;
		}
		return null;
	}

}

// ("=" valueExpr=Expression)?
protected class PropertyVarDeclaration_Group_5 extends GroupToken {
	
	public PropertyVarDeclaration_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyVarDeclaration_ValueExprAssignment_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class PropertyVarDeclaration_EqualsSignKeyword_5_0 extends KeywordToken  {
	
	public PropertyVarDeclaration_EqualsSignKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getEqualsSignKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyVarDeclaration_NameAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// valueExpr=Expression
protected class PropertyVarDeclaration_ValueExprAssignment_5_1 extends AssignmentToken  {
	
	public PropertyVarDeclaration_ValueExprAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getValueExprAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("valueExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("valueExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyVarDeclarationAccess().getValueExprExpressionParserRuleCall_5_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyVarDeclaration_EqualsSignKeyword_5_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ";"
protected class PropertyVarDeclaration_SemicolonKeyword_6 extends KeywordToken  {
	
	public PropertyVarDeclaration_SemicolonKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPropertyVarDeclarationAccess().getSemicolonKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyVarDeclaration_Group_5(parent, this, 0, inst);
			case 1: return new PropertyVarDeclaration_NameAssignment_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule PropertyVarDeclaration ****************/


/************ begin Rule PropertySetOperation ****************
 *
 * PropertySetOperation returns be::BPropertyOperation:
 *   {be::BPropertySetOperation} propertySet=PropertySet;
 *
 **/

// {be::BPropertySetOperation} propertySet=PropertySet
protected class PropertySetOperation_Group extends GroupToken {
	
	public PropertySetOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertySetOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySetOperation_PropertySetAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertySetOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BPropertySetOperation}
protected class PropertySetOperation_BPropertySetOperationAction_0 extends ActionToken  {

	public PropertySetOperation_BPropertySetOperationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPropertySetOperationAccess().getBPropertySetOperationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPropertySetOperationAccess().getBPropertySetOperationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// propertySet=PropertySet
protected class PropertySetOperation_PropertySetAssignment_1 extends AssignmentToken  {
	
	public PropertySetOperation_PropertySetAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertySetOperationAccess().getPropertySetAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("propertySet",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("propertySet");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertySetOperationAccess().getPropertySetPropertySetParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertySetOperation_BPropertySetOperationAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule PropertySetOperation ****************/


/************ begin Rule Synchronization ****************
 *
 * Synchronization returns build::Synchronization:
 *   {build::Synchronization} builders+=SynchronizedBuilder ("," builders+=
 *   SynchronizedBuilder)+ ";";
 *
 **/

// {build::Synchronization} builders+=SynchronizedBuilder ("," builders+=
// SynchronizedBuilder)+ ";"
protected class Synchronization_Group extends GroupToken {
	
	public Synchronization_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSynchronizationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Synchronization_SemicolonKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSynchronizationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::Synchronization}
protected class Synchronization_SynchronizationAction_0 extends ActionToken  {

	public Synchronization_SynchronizationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSynchronizationAccess().getSynchronizationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSynchronizationAccess().getSynchronizationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// builders+=SynchronizedBuilder
protected class Synchronization_BuildersAssignment_1 extends AssignmentToken  {
	
	public Synchronization_BuildersAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSynchronizationAccess().getBuildersAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("builders",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("builders");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSynchronizedBuilderRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSynchronizationAccess().getBuildersSynchronizedBuilderParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Synchronization_SynchronizationAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," builders+=SynchronizedBuilder)+
protected class Synchronization_Group_2 extends GroupToken {
	
	public Synchronization_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSynchronizationAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Synchronization_BuildersAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Synchronization_CommaKeyword_2_0 extends KeywordToken  {
	
	public Synchronization_CommaKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSynchronizationAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Synchronization_Group_2(parent, this, 0, inst);
			case 1: return new Synchronization_BuildersAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// builders+=SynchronizedBuilder
protected class Synchronization_BuildersAssignment_2_1 extends AssignmentToken  {
	
	public Synchronization_BuildersAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSynchronizationAccess().getBuildersAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("builders",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("builders");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSynchronizedBuilderRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSynchronizationAccess().getBuildersSynchronizedBuilderParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Synchronization_CommaKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ";"
protected class Synchronization_SemicolonKeyword_3 extends KeywordToken  {
	
	public Synchronization_SemicolonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSynchronizationAccess().getSemicolonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Synchronization_Group_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Synchronization ****************/


/************ begin Rule SynchronizedBuilder ****************
 *
 * SynchronizedBuilder returns build::SynchronizedBuilder:
 *   {build::SynchronizedBuilder} nameSpace=EscapedQualifiedName "/" name=
 *   EscapedQualifiedName ("#" builderName=BuilderName)?|builderName=BuilderName;
 *
 **/

// {build::SynchronizedBuilder} nameSpace=EscapedQualifiedName "/" name=
// EscapedQualifiedName ("#" builderName=BuilderName)?|builderName=BuilderName
protected class SynchronizedBuilder_Alternatives extends AlternativesToken {

	public SynchronizedBuilder_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_Group_0(parent, this, 0, inst);
			case 1: return new SynchronizedBuilder_BuilderNameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSynchronizedBuilderRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::SynchronizedBuilder} nameSpace=EscapedQualifiedName "/" name=
// EscapedQualifiedName ("#" builderName=BuilderName)?
protected class SynchronizedBuilder_Group_0 extends GroupToken {
	
	public SynchronizedBuilder_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_Group_0_4(parent, this, 0, inst);
			case 1: return new SynchronizedBuilder_NameAssignment_0_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// {build::SynchronizedBuilder}
protected class SynchronizedBuilder_SynchronizedBuilderAction_0_0 extends ActionToken  {

	public SynchronizedBuilder_SynchronizedBuilderAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getSynchronizedBuilderAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSynchronizedBuilderAccess().getSynchronizedBuilderAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// nameSpace=EscapedQualifiedName
protected class SynchronizedBuilder_NameSpaceAssignment_0_1 extends AssignmentToken  {
	
	public SynchronizedBuilder_NameSpaceAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getNameSpaceAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_SynchronizedBuilderAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("nameSpace",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nameSpace");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getSynchronizedBuilderAccess().getNameSpaceEscapedQualifiedNameParserRuleCall_0_1_0();
			return obj;
		}
		return null;
	}

}

// "/"
protected class SynchronizedBuilder_SolidusKeyword_0_2 extends KeywordToken  {
	
	public SynchronizedBuilder_SolidusKeyword_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getSolidusKeyword_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_NameSpaceAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=EscapedQualifiedName
protected class SynchronizedBuilder_NameAssignment_0_3 extends AssignmentToken  {
	
	public SynchronizedBuilder_NameAssignment_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getNameAssignment_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_SolidusKeyword_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getSynchronizedBuilderAccess().getNameEscapedQualifiedNameParserRuleCall_0_3_0();
			return obj;
		}
		return null;
	}

}

// ("#" builderName=BuilderName)?
protected class SynchronizedBuilder_Group_0_4 extends GroupToken {
	
	public SynchronizedBuilder_Group_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getGroup_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_BuilderNameAssignment_0_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "#"
protected class SynchronizedBuilder_NumberSignKeyword_0_4_0 extends KeywordToken  {
	
	public SynchronizedBuilder_NumberSignKeyword_0_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getNumberSignKeyword_0_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_NameAssignment_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// builderName=BuilderName
protected class SynchronizedBuilder_BuilderNameAssignment_0_4_1 extends AssignmentToken  {
	
	public SynchronizedBuilder_BuilderNameAssignment_0_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getBuilderNameAssignment_0_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SynchronizedBuilder_NumberSignKeyword_0_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("builderName",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("builderName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getSynchronizedBuilderAccess().getBuilderNameBuilderNameParserRuleCall_0_4_1_0();
			return obj;
		}
		return null;
	}

}



// builderName=BuilderName
protected class SynchronizedBuilder_BuilderNameAssignment_1 extends AssignmentToken  {
	
	public SynchronizedBuilder_BuilderNameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSynchronizedBuilderAccess().getBuilderNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("builderName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("builderName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getSynchronizedBuilderAccess().getBuilderNameBuilderNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule SynchronizedBuilder ****************/


/************ begin Rule PathGroup ****************
 *
 * PathGroup returns build::PathGroup:
 *   {build::PathGroup} pathVectors+=PathVector+ ("annotations" annotations=PropertySet)
 *   ?;
 *
 **/

// {build::PathGroup} pathVectors+=PathVector+ ("annotations" annotations=PropertySet)
// ?
protected class PathGroup_Group extends GroupToken {
	
	public PathGroup_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPathGroupAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathGroup_Group_2(parent, this, 0, inst);
			case 1: return new PathGroup_PathVectorsAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPathGroupRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::PathGroup}
protected class PathGroup_PathGroupAction_0 extends ActionToken  {

	public PathGroup_PathGroupAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPathGroupAccess().getPathGroupAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPathGroupAccess().getPathGroupAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// pathVectors+=PathVector+
protected class PathGroup_PathVectorsAssignment_1 extends AssignmentToken  {
	
	public PathGroup_PathVectorsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPathGroupAccess().getPathVectorsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathVector_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("pathVectors",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("pathVectors");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathVectorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPathGroupAccess().getPathVectorsPathVectorParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PathGroup_PathVectorsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new PathGroup_PathGroupAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("annotations" annotations=PropertySet)?
protected class PathGroup_Group_2 extends GroupToken {
	
	public PathGroup_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPathGroupAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathGroup_AnnotationsAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "annotations"
protected class PathGroup_AnnotationsKeyword_2_0 extends KeywordToken  {
	
	public PathGroup_AnnotationsKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPathGroupAccess().getAnnotationsKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathGroup_PathVectorsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// annotations=PropertySet
protected class PathGroup_AnnotationsAssignment_2_1 extends AssignmentToken  {
	
	public PathGroup_AnnotationsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPathGroupAccess().getAnnotationsAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("annotations",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("annotations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPathGroupAccess().getAnnotationsPropertySetParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PathGroup_AnnotationsKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule PathGroup ****************/


/************ begin Rule PathVector ****************
 *
 * PathVector returns build::PathVector:
 *   BasePathVector|UnbasedPathVector|CompoundPathVector;
 *
 **/

// BasePathVector|UnbasedPathVector|CompoundPathVector
protected class PathVector_Alternatives extends AlternativesToken {

	public PathVector_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPathVectorAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathVector_BasePathVectorParserRuleCall_0(parent, this, 0, inst);
			case 1: return new PathVector_UnbasedPathVectorParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PathVector_CompoundPathVectorParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPathVectorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BasePathVector
protected class PathVector_BasePathVectorParserRuleCall_0 extends RuleCallToken {
	
	public PathVector_BasePathVectorParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPathVectorAccess().getBasePathVectorParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BasePathVector_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBasePathVectorRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// UnbasedPathVector
protected class PathVector_UnbasedPathVectorParserRuleCall_1 extends RuleCallToken {
	
	public PathVector_UnbasedPathVectorParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPathVectorAccess().getUnbasedPathVectorParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnbasedPathVector_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnbasedPathVectorRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// CompoundPathVector
protected class PathVector_CompoundPathVectorParserRuleCall_2 extends RuleCallToken {
	
	public PathVector_CompoundPathVectorParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPathVectorAccess().getCompoundPathVectorParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundPathVector_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CompoundPathVector_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCompoundPathVectorRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule PathVector ****************/


/************ begin Rule BasePathVector ****************
 *
 * BasePathVector returns build::PathVector:
 *   {build::PathVectorElement} ("when" "(" condExpr=Expression ")")? basePath=Path "[" (
 *   paths+=Path ("," paths+=Path)*)? "]" ";";
 *
 **/

// {build::PathVectorElement} ("when" "(" condExpr=Expression ")")? basePath=Path "[" (
// paths+=Path ("," paths+=Path)*)? "]" ";"
protected class BasePathVector_Group extends GroupToken {
	
	public BasePathVector_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_SemicolonKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBasePathVectorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::PathVectorElement}
protected class BasePathVector_PathVectorElementAction_0 extends ActionToken  {

	public BasePathVector_PathVectorElementAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getPathVectorElementAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBasePathVectorAccess().getPathVectorElementAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ("when" "(" condExpr=Expression ")")?
protected class BasePathVector_Group_1 extends GroupToken {
	
	public BasePathVector_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_RightParenthesisKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "when"
protected class BasePathVector_WhenKeyword_1_0 extends KeywordToken  {
	
	public BasePathVector_WhenKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getWhenKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_PathVectorElementAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class BasePathVector_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public BasePathVector_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_WhenKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// condExpr=Expression
protected class BasePathVector_CondExprAssignment_1_2 extends AssignmentToken  {
	
	public BasePathVector_CondExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getCondExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBasePathVectorAccess().getCondExprExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BasePathVector_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class BasePathVector_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public BasePathVector_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getRightParenthesisKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_CondExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// basePath=Path
protected class BasePathVector_BasePathAssignment_2 extends AssignmentToken  {
	
	public BasePathVector_BasePathAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getBasePathAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_Group_1(parent, this, 0, inst);
			case 1: return new BasePathVector_PathVectorElementAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("basePath",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("basePath");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getBasePathVectorAccess().getBasePathPathParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "["
protected class BasePathVector_LeftSquareBracketKeyword_3 extends KeywordToken  {
	
	public BasePathVector_LeftSquareBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getLeftSquareBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_BasePathAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (paths+=Path ("," paths+=Path)*)?
protected class BasePathVector_Group_4 extends GroupToken {
	
	public BasePathVector_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_Group_4_1(parent, this, 0, inst);
			case 1: return new BasePathVector_PathsAssignment_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// paths+=Path
protected class BasePathVector_PathsAssignment_4_0 extends AssignmentToken  {
	
	public BasePathVector_PathsAssignment_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getPathsAssignment_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_LeftSquareBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("paths",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("paths");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getBasePathVectorAccess().getPathsPathParserRuleCall_4_0_0();
			return obj;
		}
		return null;
	}

}

// ("," paths+=Path)*
protected class BasePathVector_Group_4_1 extends GroupToken {
	
	public BasePathVector_Group_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getGroup_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_PathsAssignment_4_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class BasePathVector_CommaKeyword_4_1_0 extends KeywordToken  {
	
	public BasePathVector_CommaKeyword_4_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getCommaKeyword_4_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_Group_4_1(parent, this, 0, inst);
			case 1: return new BasePathVector_PathsAssignment_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// paths+=Path
protected class BasePathVector_PathsAssignment_4_1_1 extends AssignmentToken  {
	
	public BasePathVector_PathsAssignment_4_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getPathsAssignment_4_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_CommaKeyword_4_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("paths",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("paths");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getBasePathVectorAccess().getPathsPathParserRuleCall_4_1_1_0();
			return obj;
		}
		return null;
	}

}



// "]"
protected class BasePathVector_RightSquareBracketKeyword_5 extends KeywordToken  {
	
	public BasePathVector_RightSquareBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getRightSquareBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_Group_4(parent, this, 0, inst);
			case 1: return new BasePathVector_LeftSquareBracketKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ";"
protected class BasePathVector_SemicolonKeyword_6 extends KeywordToken  {
	
	public BasePathVector_SemicolonKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBasePathVectorAccess().getSemicolonKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BasePathVector_RightSquareBracketKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule BasePathVector ****************/


/************ begin Rule UnbasedPathVector ****************
 *
 * UnbasedPathVector returns build::PathVector:
 *   {build::PathVectorElement} ("when" "(" condExpr=Expression ")")? paths+=Path ("," paths
 *   +=Path)* ";";
 *
 **/

// {build::PathVectorElement} ("when" "(" condExpr=Expression ")")? paths+=Path ("," paths
// +=Path)* ";"
protected class UnbasedPathVector_Group extends GroupToken {
	
	public UnbasedPathVector_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_SemicolonKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnbasedPathVectorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::PathVectorElement}
protected class UnbasedPathVector_PathVectorElementAction_0 extends ActionToken  {

	public UnbasedPathVector_PathVectorElementAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getPathVectorElementAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnbasedPathVectorAccess().getPathVectorElementAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ("when" "(" condExpr=Expression ")")?
protected class UnbasedPathVector_Group_1 extends GroupToken {
	
	public UnbasedPathVector_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_RightParenthesisKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "when"
protected class UnbasedPathVector_WhenKeyword_1_0 extends KeywordToken  {
	
	public UnbasedPathVector_WhenKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getWhenKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_PathVectorElementAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class UnbasedPathVector_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public UnbasedPathVector_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_WhenKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// condExpr=Expression
protected class UnbasedPathVector_CondExprAssignment_1_2 extends AssignmentToken  {
	
	public UnbasedPathVector_CondExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getCondExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnbasedPathVectorAccess().getCondExprExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnbasedPathVector_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class UnbasedPathVector_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public UnbasedPathVector_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getRightParenthesisKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_CondExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// paths+=Path
protected class UnbasedPathVector_PathsAssignment_2 extends AssignmentToken  {
	
	public UnbasedPathVector_PathsAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getPathsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_Group_1(parent, this, 0, inst);
			case 1: return new UnbasedPathVector_PathVectorElementAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("paths",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("paths");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getUnbasedPathVectorAccess().getPathsPathParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// ("," paths+=Path)*
protected class UnbasedPathVector_Group_3 extends GroupToken {
	
	public UnbasedPathVector_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_PathsAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class UnbasedPathVector_CommaKeyword_3_0 extends KeywordToken  {
	
	public UnbasedPathVector_CommaKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getCommaKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_Group_3(parent, this, 0, inst);
			case 1: return new UnbasedPathVector_PathsAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// paths+=Path
protected class UnbasedPathVector_PathsAssignment_3_1 extends AssignmentToken  {
	
	public UnbasedPathVector_PathsAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getPathsAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_CommaKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("paths",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("paths");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getUnbasedPathVectorAccess().getPathsPathParserRuleCall_3_1_0();
			return obj;
		}
		return null;
	}

}


// ";"
protected class UnbasedPathVector_SemicolonKeyword_4 extends KeywordToken  {
	
	public UnbasedPathVector_SemicolonKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnbasedPathVectorAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnbasedPathVector_Group_3(parent, this, 0, inst);
			case 1: return new UnbasedPathVector_PathsAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule UnbasedPathVector ****************/


/************ begin Rule CompoundPathVector ****************
 *
 * CompoundPathVector returns build::PathVector:
 *   {build::CompoundPathVector} "when" "(" condExpr=Expression ")" "{" pathVectors+=
 *   PathVector* "}"; 
 * 	
 *         
 * 	      
 * 	         
 * 	
 * 
 * // A path can be written without quotes if it consists of safe chars
 *
 **/

// {build::CompoundPathVector} "when" "(" condExpr=Expression ")" "{" pathVectors+=
// PathVector* "}"
protected class CompoundPathVector_Group extends GroupToken {
	
	public CompoundPathVector_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundPathVector_RightCurlyBracketKeyword_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompoundPathVectorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::CompoundPathVector}
protected class CompoundPathVector_CompoundPathVectorAction_0 extends ActionToken  {

	public CompoundPathVector_CompoundPathVectorAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getCompoundPathVectorAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCompoundPathVectorAccess().getCompoundPathVectorAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "when"
protected class CompoundPathVector_WhenKeyword_1 extends KeywordToken  {
	
	public CompoundPathVector_WhenKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getWhenKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundPathVector_CompoundPathVectorAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class CompoundPathVector_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public CompoundPathVector_LeftParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getLeftParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundPathVector_WhenKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// condExpr=Expression
protected class CompoundPathVector_CondExprAssignment_3 extends AssignmentToken  {
	
	public CompoundPathVector_CondExprAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getCondExprAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundPathVectorAccess().getCondExprExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompoundPathVector_LeftParenthesisKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class CompoundPathVector_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public CompoundPathVector_RightParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getRightParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundPathVector_CondExprAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class CompoundPathVector_LeftCurlyBracketKeyword_5 extends KeywordToken  {
	
	public CompoundPathVector_LeftCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getLeftCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundPathVector_RightParenthesisKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// pathVectors+=PathVector*
protected class CompoundPathVector_PathVectorsAssignment_6 extends AssignmentToken  {
	
	public CompoundPathVector_PathVectorsAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getPathVectorsAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathVector_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("pathVectors",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("pathVectors");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathVectorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundPathVectorAccess().getPathVectorsPathVectorParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompoundPathVector_PathVectorsAssignment_6(parent, next, actIndex, consumed);
			case 1: return new CompoundPathVector_LeftCurlyBracketKeyword_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class CompoundPathVector_RightCurlyBracketKeyword_7 extends KeywordToken  {
	
	public CompoundPathVector_RightCurlyBracketKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundPathVectorAccess().getRightCurlyBracketKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundPathVector_PathVectorsAssignment_6(parent, this, 0, inst);
			case 1: return new CompoundPathVector_LeftCurlyBracketKeyword_5(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule CompoundPathVector ****************/



/************ begin Rule Prerequisite ****************
 *
 * Prerequisite returns build::Prerequisite:
 *   {build::Prerequisite} ("when" "(" condExpr=Expression ")")? withExpr=WithClause?
 *   buildResult=BuildResultReference ("as" alias=ID)? ";"; 
 * 
 *          
 * 	        
 * 	    
 * 	
 * 	    
 * 	
 * 
 * // Validation checks that there is at least one of references, properties or concern.
 *
 **/

// {build::Prerequisite} ("when" "(" condExpr=Expression ")")? withExpr=WithClause?
// buildResult=BuildResultReference ("as" alias=ID)? ";"
protected class Prerequisite_Group extends GroupToken {
	
	public Prerequisite_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_SemicolonKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrerequisiteRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::Prerequisite}
protected class Prerequisite_PrerequisiteAction_0 extends ActionToken  {

	public Prerequisite_PrerequisiteAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getPrerequisiteAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPrerequisiteAccess().getPrerequisiteAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ("when" "(" condExpr=Expression ")")?
protected class Prerequisite_Group_1 extends GroupToken {
	
	public Prerequisite_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_RightParenthesisKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "when"
protected class Prerequisite_WhenKeyword_1_0 extends KeywordToken  {
	
	public Prerequisite_WhenKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getWhenKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_PrerequisiteAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class Prerequisite_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public Prerequisite_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_WhenKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// condExpr=Expression
protected class Prerequisite_CondExprAssignment_1_2 extends AssignmentToken  {
	
	public Prerequisite_CondExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getCondExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPrerequisiteAccess().getCondExprExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Prerequisite_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Prerequisite_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public Prerequisite_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getRightParenthesisKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_CondExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// withExpr=WithClause?
protected class Prerequisite_WithExprAssignment_2 extends AssignmentToken  {
	
	public Prerequisite_WithExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getWithExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("withExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("withExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getWithClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPrerequisiteAccess().getWithExprWithClauseParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Prerequisite_Group_1(parent, next, actIndex, consumed);
			case 1: return new Prerequisite_PrerequisiteAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// buildResult=BuildResultReference
protected class Prerequisite_BuildResultAssignment_3 extends AssignmentToken  {
	
	public Prerequisite_BuildResultAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getBuildResultAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildResultReference_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("buildResult",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("buildResult");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBuildResultReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPrerequisiteAccess().getBuildResultBuildResultReferenceParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Prerequisite_WithExprAssignment_2(parent, next, actIndex, consumed);
			case 1: return new Prerequisite_Group_1(parent, next, actIndex, consumed);
			case 2: return new Prerequisite_PrerequisiteAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("as" alias=ID)?
protected class Prerequisite_Group_4 extends GroupToken {
	
	public Prerequisite_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_AliasAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "as"
protected class Prerequisite_AsKeyword_4_0 extends KeywordToken  {
	
	public Prerequisite_AsKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getAsKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_BuildResultAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// alias=ID
protected class Prerequisite_AliasAssignment_4_1 extends AssignmentToken  {
	
	public Prerequisite_AliasAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getAliasAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_AsKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alias",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPrerequisiteAccess().getAliasIDTerminalRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}


// ";"
protected class Prerequisite_SemicolonKeyword_5 extends KeywordToken  {
	
	public Prerequisite_SemicolonKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrerequisiteAccess().getSemicolonKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_Group_4(parent, this, 0, inst);
			case 1: return new Prerequisite_BuildResultAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Prerequisite ****************/


/************ begin Rule WithClause ****************
 *
 * WithClause returns be::BWithExpression:
 *   {be::BWithExpression} "with" ("(" referencedAdvice+=[be::BAdvice] (","
 *   referencedAdvice+=[be::BAdvice])* ")")? ("properties" propertySets+=PropertySet|
 *   "concern" concerns+=Concern_Anonymous)*; 
 * 
 * // Validation checks that there is at least one of references, properties or concern.
 *
 **/

// {be::BWithExpression} "with" ("(" referencedAdvice+=[be::BAdvice] (","
// referencedAdvice+=[be::BAdvice])* ")")? ("properties" propertySets+=PropertySet|
// "concern" concerns+=Concern_Anonymous)*
protected class WithClause_Group extends GroupToken {
	
	public WithClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_Alternatives_3(parent, this, 0, inst);
			case 1: return new WithClause_Group_2(parent, this, 1, inst);
			case 2: return new WithClause_WithKeyword_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWithClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BWithExpression}
protected class WithClause_BWithExpressionAction_0 extends ActionToken  {

	public WithClause_BWithExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getBWithExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getWithClauseAccess().getBWithExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "with"
protected class WithClause_WithKeyword_1 extends KeywordToken  {
	
	public WithClause_WithKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getWithKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_BWithExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("(" referencedAdvice+=[be::BAdvice] ("," referencedAdvice+=[be::BAdvice])* ")")?
protected class WithClause_Group_2 extends GroupToken {
	
	public WithClause_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_RightParenthesisKeyword_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class WithClause_LeftParenthesisKeyword_2_0 extends KeywordToken  {
	
	public WithClause_LeftParenthesisKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getLeftParenthesisKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_WithKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// referencedAdvice+=[be::BAdvice]
protected class WithClause_ReferencedAdviceAssignment_2_1 extends AssignmentToken  {
	
	public WithClause_ReferencedAdviceAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getReferencedAdviceAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_LeftParenthesisKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("referencedAdvice",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referencedAdvice");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getWithClauseAccess().getReferencedAdviceBAdviceCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getWithClauseAccess().getReferencedAdviceBAdviceCrossReference_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," referencedAdvice+=[be::BAdvice])*
protected class WithClause_Group_2_2 extends GroupToken {
	
	public WithClause_Group_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getGroup_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_ReferencedAdviceAssignment_2_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class WithClause_CommaKeyword_2_2_0 extends KeywordToken  {
	
	public WithClause_CommaKeyword_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getCommaKeyword_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_Group_2_2(parent, this, 0, inst);
			case 1: return new WithClause_ReferencedAdviceAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// referencedAdvice+=[be::BAdvice]
protected class WithClause_ReferencedAdviceAssignment_2_2_1 extends AssignmentToken  {
	
	public WithClause_ReferencedAdviceAssignment_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getReferencedAdviceAssignment_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_CommaKeyword_2_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("referencedAdvice",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referencedAdvice");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getWithClauseAccess().getReferencedAdviceBAdviceCrossReference_2_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getWithClauseAccess().getReferencedAdviceBAdviceCrossReference_2_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


// ")"
protected class WithClause_RightParenthesisKeyword_2_3 extends KeywordToken  {
	
	public WithClause_RightParenthesisKeyword_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getRightParenthesisKeyword_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_Group_2_2(parent, this, 0, inst);
			case 1: return new WithClause_ReferencedAdviceAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// ("properties" propertySets+=PropertySet|"concern" concerns+=Concern_Anonymous)*
protected class WithClause_Alternatives_3 extends AlternativesToken {

	public WithClause_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_Group_3_0(parent, this, 0, inst);
			case 1: return new WithClause_Group_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "properties" propertySets+=PropertySet
protected class WithClause_Group_3_0 extends GroupToken {
	
	public WithClause_Group_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getGroup_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_PropertySetsAssignment_3_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "properties"
protected class WithClause_PropertiesKeyword_3_0_0 extends KeywordToken  {
	
	public WithClause_PropertiesKeyword_3_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getPropertiesKeyword_3_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_Alternatives_3(parent, this, 0, inst);
			case 1: return new WithClause_Group_2(parent, this, 1, inst);
			case 2: return new WithClause_WithKeyword_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// propertySets+=PropertySet
protected class WithClause_PropertySetsAssignment_3_0_1 extends AssignmentToken  {
	
	public WithClause_PropertySetsAssignment_3_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getPropertySetsAssignment_3_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("propertySets",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("propertySets");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWithClauseAccess().getPropertySetsPropertySetParserRuleCall_3_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WithClause_PropertiesKeyword_3_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "concern" concerns+=Concern_Anonymous
protected class WithClause_Group_3_1 extends GroupToken {
	
	public WithClause_Group_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getGroup_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_ConcernsAssignment_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "concern"
protected class WithClause_ConcernKeyword_3_1_0 extends KeywordToken  {
	
	public WithClause_ConcernKeyword_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getConcernKeyword_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_Alternatives_3(parent, this, 0, inst);
			case 1: return new WithClause_Group_2(parent, this, 1, inst);
			case 2: return new WithClause_WithKeyword_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// concerns+=Concern_Anonymous
protected class WithClause_ConcernsAssignment_3_1_1 extends AssignmentToken  {
	
	public WithClause_ConcernsAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getConcernsAssignment_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("concerns",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("concerns");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcern_AnonymousRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWithClauseAccess().getConcernsConcern_AnonymousParserRuleCall_3_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WithClause_ConcernKeyword_3_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule WithClause ****************/


/************ begin Rule BuildResultReference ****************
 *
 * BuildResultReference returns build::BuildResultReference:
 *   UnitReference|CapabilityReference|CompoundBuildResultReference;
 *
 **/

// UnitReference|CapabilityReference|CompoundBuildResultReference
protected class BuildResultReference_Alternatives extends AlternativesToken {

	public BuildResultReference_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBuildResultReferenceAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuildResultReference_UnitReferenceParserRuleCall_0(parent, this, 0, inst);
			case 1: return new BuildResultReference_CapabilityReferenceParserRuleCall_1(parent, this, 1, inst);
			case 2: return new BuildResultReference_CompoundBuildResultReferenceParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBuildResultReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// UnitReference
protected class BuildResultReference_UnitReferenceParserRuleCall_0 extends RuleCallToken {
	
	public BuildResultReference_UnitReferenceParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBuildResultReferenceAccess().getUnitReferenceParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnitReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnitReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnitReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// CapabilityReference
protected class BuildResultReference_CapabilityReferenceParserRuleCall_1 extends RuleCallToken {
	
	public BuildResultReference_CapabilityReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBuildResultReferenceAccess().getCapabilityReferenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CapabilityReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CapabilityReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCapabilityReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// CompoundBuildResultReference
protected class BuildResultReference_CompoundBuildResultReferenceParserRuleCall_2 extends RuleCallToken {
	
	public BuildResultReference_CompoundBuildResultReferenceParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBuildResultReferenceAccess().getCompoundBuildResultReferenceParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundBuildResultReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CompoundBuildResultReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCompoundBuildResultReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule BuildResultReference ****************/


/************ begin Rule UnitReference ****************
 *
 * UnitReference returns build::BuildResultReference:
 *   {build::BuilderReference} requiredCapability=RequiredCapability_Unit? "#"
 *   builderName=BuilderName parameters=ParameterList?;
 *
 **/

// {build::BuilderReference} requiredCapability=RequiredCapability_Unit? "#"
// builderName=BuilderName parameters=ParameterList?
protected class UnitReference_Group extends GroupToken {
	
	public UnitReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnitReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnitReference_ParametersAssignment_4(parent, this, 0, inst);
			case 1: return new UnitReference_BuilderNameAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnitReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::BuilderReference}
protected class UnitReference_BuilderReferenceAction_0 extends ActionToken  {

	public UnitReference_BuilderReferenceAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnitReferenceAccess().getBuilderReferenceAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnitReferenceAccess().getBuilderReferenceAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// requiredCapability=RequiredCapability_Unit?
protected class UnitReference_RequiredCapabilityAssignment_1 extends AssignmentToken  {
	
	public UnitReference_RequiredCapabilityAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnitReferenceAccess().getRequiredCapabilityAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unit_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("requiredCapability",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("requiredCapability");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRequiredCapability_UnitRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnitReferenceAccess().getRequiredCapabilityRequiredCapability_UnitParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnitReference_BuilderReferenceAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "#"
protected class UnitReference_NumberSignKeyword_2 extends KeywordToken  {
	
	public UnitReference_NumberSignKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnitReferenceAccess().getNumberSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnitReference_RequiredCapabilityAssignment_1(parent, this, 0, inst);
			case 1: return new UnitReference_BuilderReferenceAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// builderName=BuilderName
protected class UnitReference_BuilderNameAssignment_3 extends AssignmentToken  {
	
	public UnitReference_BuilderNameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnitReferenceAccess().getBuilderNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnitReference_NumberSignKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("builderName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("builderName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getUnitReferenceAccess().getBuilderNameBuilderNameParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// parameters=ParameterList?
protected class UnitReference_ParametersAssignment_4 extends AssignmentToken  {
	
	public UnitReference_ParametersAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnitReferenceAccess().getParametersAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnitReferenceAccess().getParametersParameterListParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnitReference_BuilderNameAssignment_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule UnitReference ****************/


/************ begin Rule CapabilityReference ****************
 *
 * CapabilityReference returns build::BuildResultReference:
 *   {build::BuilderReference} requiredCapability=RequiredCapability_Unfiltered ("#"
 *   builderName=BuilderName)? parameters=ParameterList?;
 *
 **/

// {build::BuilderReference} requiredCapability=RequiredCapability_Unfiltered ("#"
// builderName=BuilderName)? parameters=ParameterList?
protected class CapabilityReference_Group extends GroupToken {
	
	public CapabilityReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCapabilityReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CapabilityReference_ParametersAssignment_3(parent, this, 0, inst);
			case 1: return new CapabilityReference_Group_2(parent, this, 1, inst);
			case 2: return new CapabilityReference_RequiredCapabilityAssignment_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCapabilityReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::BuilderReference}
protected class CapabilityReference_BuilderReferenceAction_0 extends ActionToken  {

	public CapabilityReference_BuilderReferenceAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCapabilityReferenceAccess().getBuilderReferenceAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCapabilityReferenceAccess().getBuilderReferenceAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// requiredCapability=RequiredCapability_Unfiltered
protected class CapabilityReference_RequiredCapabilityAssignment_1 extends AssignmentToken  {
	
	public CapabilityReference_RequiredCapabilityAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCapabilityReferenceAccess().getRequiredCapabilityAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RequiredCapability_Unfiltered_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("requiredCapability",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("requiredCapability");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRequiredCapability_UnfilteredRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCapabilityReferenceAccess().getRequiredCapabilityRequiredCapability_UnfilteredParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CapabilityReference_BuilderReferenceAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("#" builderName=BuilderName)?
protected class CapabilityReference_Group_2 extends GroupToken {
	
	public CapabilityReference_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCapabilityReferenceAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CapabilityReference_BuilderNameAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "#"
protected class CapabilityReference_NumberSignKeyword_2_0 extends KeywordToken  {
	
	public CapabilityReference_NumberSignKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCapabilityReferenceAccess().getNumberSignKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CapabilityReference_RequiredCapabilityAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// builderName=BuilderName
protected class CapabilityReference_BuilderNameAssignment_2_1 extends AssignmentToken  {
	
	public CapabilityReference_BuilderNameAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCapabilityReferenceAccess().getBuilderNameAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CapabilityReference_NumberSignKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("builderName",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("builderName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getCapabilityReferenceAccess().getBuilderNameBuilderNameParserRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}


// parameters=ParameterList?
protected class CapabilityReference_ParametersAssignment_3 extends AssignmentToken  {
	
	public CapabilityReference_ParametersAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCapabilityReferenceAccess().getParametersAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCapabilityReferenceAccess().getParametersParameterListParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CapabilityReference_Group_2(parent, next, actIndex, consumed);
			case 1: return new CapabilityReference_RequiredCapabilityAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule CapabilityReference ****************/


/************ begin Rule CompoundBuildResultReference ****************
 *
 * CompoundBuildResultReference returns build::BuildResultReference:
 *   {build::CompoundBuildResultReference} "{" prerequisites+=Prerequisite* "}";
 *
 **/

// {build::CompoundBuildResultReference} "{" prerequisites+=Prerequisite* "}"
protected class CompoundBuildResultReference_Group extends GroupToken {
	
	public CompoundBuildResultReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundBuildResultReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundBuildResultReference_RightCurlyBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompoundBuildResultReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::CompoundBuildResultReference}
protected class CompoundBuildResultReference_CompoundBuildResultReferenceAction_0 extends ActionToken  {

	public CompoundBuildResultReference_CompoundBuildResultReferenceAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCompoundBuildResultReferenceAccess().getCompoundBuildResultReferenceAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCompoundBuildResultReferenceAccess().getCompoundBuildResultReferenceAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "{"
protected class CompoundBuildResultReference_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public CompoundBuildResultReference_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundBuildResultReferenceAccess().getLeftCurlyBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundBuildResultReference_CompoundBuildResultReferenceAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// prerequisites+=Prerequisite*
protected class CompoundBuildResultReference_PrerequisitesAssignment_2 extends AssignmentToken  {
	
	public CompoundBuildResultReference_PrerequisitesAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundBuildResultReferenceAccess().getPrerequisitesAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("prerequisites",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("prerequisites");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrerequisiteRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundBuildResultReferenceAccess().getPrerequisitesPrerequisiteParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompoundBuildResultReference_PrerequisitesAssignment_2(parent, next, actIndex, consumed);
			case 1: return new CompoundBuildResultReference_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class CompoundBuildResultReference_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public CompoundBuildResultReference_RightCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundBuildResultReferenceAccess().getRightCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundBuildResultReference_PrerequisitesAssignment_2(parent, this, 0, inst);
			case 1: return new CompoundBuildResultReference_LeftCurlyBracketKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule CompoundBuildResultReference ****************/


/************ begin Rule Builder ****************
 *
 * Builder returns build::Builder:
 *   {build::Builder} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
 *   ExecutionMode? final?="final"? "builder" name=BuilderName ("(" (parameters+=
 *   ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
 *   parameters+=ParameterDeclaration)?)|(varArgs?="..." parameters+=
 *   ParameterDeclaration) ")")? ("when" guard=GuardExpression)? ("provides"
 *   providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
 *   ProvidedCapability)*)? ("precondition" (":" precondExpr=Expression ";"|precondExpr=
 *   BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=
 *   BlockExpression))? "{" ("default" "properties" defaultProperties=PropertySet)? input=
 *   BuilderInput? ("output" "{" output=PathGroup "}")? funcExpr=
 *   BlockExpressionWithoutBrackets? "}"; 
 * 	
 *         
 * 	     
 * 	    
 *         
 *   	    
 * //	(cached ?= "cached")?
 *
 **/

// {build::Builder} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
// ExecutionMode? final?="final"? "builder" name=BuilderName ("(" (parameters+=
// ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
// parameters+=ParameterDeclaration)?)|(varArgs?="..." parameters+=
// ParameterDeclaration) ")")? ("when" guard=GuardExpression)? ("provides"
// providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
// ProvidedCapability)*)? ("precondition" (":" precondExpr=Expression ";"|precondExpr=
// BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=
// BlockExpression))? "{" ("default" "properties" defaultProperties=PropertySet)? input=
// BuilderInput? ("output" "{" output=PathGroup "}")? funcExpr=
// BlockExpressionWithoutBrackets? "}"   
// 	     
// 	    
//         
//   	    
// //	(cached ?= "cached")?
protected class Builder_Group extends GroupToken {
	
	public Builder_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_RightCurlyBracketKeyword_17(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBuilderRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::Builder}
protected class Builder_BuilderAction_0 extends ActionToken  {

	public Builder_BuilderAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBuilderAccess().getBuilderAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBuilderAccess().getBuilderAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// documentation=DOCUMENTATION?
protected class Builder_DocumentationAssignment_1 extends AssignmentToken  {
	
	public Builder_DocumentationAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getDocumentationAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_BuilderAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("documentation",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("documentation");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBuilderAccess().getDocumentationDOCUMENTATIONTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// visibility=Visibility?
protected class Builder_VisibilityAssignment_2 extends AssignmentToken  {
	
	public Builder_VisibilityAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getVisibilityAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_DocumentationAssignment_1(parent, this, 0, inst);
			case 1: return new Builder_BuilderAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("visibility",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("visibility");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getBuilderAccess().getVisibilityVisibilityEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// executionMode=ExecutionMode?
protected class Builder_ExecutionModeAssignment_3 extends AssignmentToken  {
	
	public Builder_ExecutionModeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getExecutionModeAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_VisibilityAssignment_2(parent, this, 0, inst);
			case 1: return new Builder_DocumentationAssignment_1(parent, this, 1, inst);
			case 2: return new Builder_BuilderAction_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("executionMode",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("executionMode");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getBuilderAccess().getExecutionModeExecutionModeEnumRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// final?="final"?
protected class Builder_FinalAssignment_4 extends AssignmentToken  {
	
	public Builder_FinalAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getFinalAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_ExecutionModeAssignment_3(parent, this, 0, inst);
			case 1: return new Builder_VisibilityAssignment_2(parent, this, 1, inst);
			case 2: return new Builder_DocumentationAssignment_1(parent, this, 2, inst);
			case 3: return new Builder_BuilderAction_0(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("final",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("final");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBuilderAccess().getFinalFinalKeyword_4_0();
			return obj;
		}
		return null;
	}

}

// "builder" 
// //	(cached ?= "cached")?
protected class Builder_BuilderKeyword_5 extends KeywordToken  {
	
	public Builder_BuilderKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getBuilderKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_FinalAssignment_4(parent, this, 0, inst);
			case 1: return new Builder_ExecutionModeAssignment_3(parent, this, 1, inst);
			case 2: return new Builder_VisibilityAssignment_2(parent, this, 2, inst);
			case 3: return new Builder_DocumentationAssignment_1(parent, this, 3, inst);
			case 4: return new Builder_BuilderAction_0(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
}

// name=BuilderName
protected class Builder_NameAssignment_6 extends AssignmentToken  {
	
	public Builder_NameAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getNameAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_BuilderKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getBuilderAccess().getNameBuilderNameParserRuleCall_6_0();
			return obj;
		}
		return null;
	}

}

// ("(" (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
// varArgs?="..." parameters+=ParameterDeclaration)?)|(varArgs?="..." parameters+=
// ParameterDeclaration) ")")?
protected class Builder_Alternatives_7 extends AlternativesToken {

	public Builder_Alternatives_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBuilderAccess().getAlternatives_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_7_0(parent, this, 0, inst);
			case 1: return new Builder_Group_7_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "(" (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
// varArgs?="..." parameters+=ParameterDeclaration)?)
protected class Builder_Group_7_0 extends GroupToken {
	
	public Builder_Group_7_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_7_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_7_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class Builder_LeftParenthesisKeyword_7_0_0 extends KeywordToken  {
	
	public Builder_LeftParenthesisKeyword_7_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getLeftParenthesisKeyword_7_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_NameAssignment_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
// varArgs?="..." parameters+=ParameterDeclaration)?
protected class Builder_Group_7_0_1 extends GroupToken {
	
	public Builder_Group_7_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_7_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_7_0_1_2(parent, this, 0, inst);
			case 1: return new Builder_Group_7_0_1_1(parent, this, 1, inst);
			case 2: return new Builder_ParametersAssignment_7_0_1_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration
protected class Builder_ParametersAssignment_7_0_1_0 extends AssignmentToken  {
	
	public Builder_ParametersAssignment_7_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getParametersAssignment_7_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getParametersParameterDeclarationParserRuleCall_7_0_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_LeftParenthesisKeyword_7_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," parameters+=ParameterDeclaration)*
protected class Builder_Group_7_0_1_1 extends GroupToken {
	
	public Builder_Group_7_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_7_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_ParametersAssignment_7_0_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Builder_CommaKeyword_7_0_1_1_0 extends KeywordToken  {
	
	public Builder_CommaKeyword_7_0_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getCommaKeyword_7_0_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_7_0_1_1(parent, this, 0, inst);
			case 1: return new Builder_ParametersAssignment_7_0_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration
protected class Builder_ParametersAssignment_7_0_1_1_1 extends AssignmentToken  {
	
	public Builder_ParametersAssignment_7_0_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getParametersAssignment_7_0_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getParametersParameterDeclarationParserRuleCall_7_0_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_CommaKeyword_7_0_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ("," varArgs?="..." parameters+=ParameterDeclaration)?
protected class Builder_Group_7_0_1_2 extends GroupToken {
	
	public Builder_Group_7_0_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_7_0_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_ParametersAssignment_7_0_1_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Builder_CommaKeyword_7_0_1_2_0 extends KeywordToken  {
	
	public Builder_CommaKeyword_7_0_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getCommaKeyword_7_0_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_7_0_1_1(parent, this, 0, inst);
			case 1: return new Builder_ParametersAssignment_7_0_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..."
protected class Builder_VarArgsAssignment_7_0_1_2_1 extends AssignmentToken  {
	
	public Builder_VarArgsAssignment_7_0_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getVarArgsAssignment_7_0_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_CommaKeyword_7_0_1_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varArgs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varArgs");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBuilderAccess().getVarArgsFullStopFullStopFullStopKeyword_7_0_1_2_1_0();
			return obj;
		}
		return null;
	}

}

// parameters+=ParameterDeclaration
protected class Builder_ParametersAssignment_7_0_1_2_2 extends AssignmentToken  {
	
	public Builder_ParametersAssignment_7_0_1_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getParametersAssignment_7_0_1_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getParametersParameterDeclarationParserRuleCall_7_0_1_2_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_VarArgsAssignment_7_0_1_2_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




// (varArgs?="..." parameters+=ParameterDeclaration) ")"
protected class Builder_Group_7_1 extends GroupToken {
	
	public Builder_Group_7_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_7_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_RightParenthesisKeyword_7_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..." parameters+=ParameterDeclaration
protected class Builder_Group_7_1_0 extends GroupToken {
	
	public Builder_Group_7_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_7_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_ParametersAssignment_7_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..."
protected class Builder_VarArgsAssignment_7_1_0_0 extends AssignmentToken  {
	
	public Builder_VarArgsAssignment_7_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getVarArgsAssignment_7_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_NameAssignment_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varArgs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varArgs");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBuilderAccess().getVarArgsFullStopFullStopFullStopKeyword_7_1_0_0_0();
			return obj;
		}
		return null;
	}

}

// parameters+=ParameterDeclaration
protected class Builder_ParametersAssignment_7_1_0_1 extends AssignmentToken  {
	
	public Builder_ParametersAssignment_7_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getParametersAssignment_7_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getParametersParameterDeclarationParserRuleCall_7_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_VarArgsAssignment_7_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class Builder_RightParenthesisKeyword_7_1_1 extends KeywordToken  {
	
	public Builder_RightParenthesisKeyword_7_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getRightParenthesisKeyword_7_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_7_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// ("when" guard=GuardExpression)?
protected class Builder_Group_8 extends GroupToken {
	
	public Builder_Group_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_GuardAssignment_8_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "when"
protected class Builder_WhenKeyword_8_0 extends KeywordToken  {
	
	public Builder_WhenKeyword_8_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getWhenKeyword_8_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Alternatives_7(parent, this, 0, inst);
			case 1: return new Builder_NameAssignment_6(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// guard=GuardExpression
protected class Builder_GuardAssignment_8_1 extends AssignmentToken  {
	
	public Builder_GuardAssignment_8_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGuardAssignment_8_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GuardExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("guard",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("guard");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGuardExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getGuardGuardExpressionParserRuleCall_8_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_WhenKeyword_8_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ("provides" providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
// ProvidedCapability)*)?
protected class Builder_Group_9 extends GroupToken {
	
	public Builder_Group_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_9_2(parent, this, 0, inst);
			case 1: return new Builder_ProvidedCapabilitiesAssignment_9_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "provides"
protected class Builder_ProvidesKeyword_9_0 extends KeywordToken  {
	
	public Builder_ProvidesKeyword_9_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getProvidesKeyword_9_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_8(parent, this, 0, inst);
			case 1: return new Builder_Alternatives_7(parent, this, 1, inst);
			case 2: return new Builder_NameAssignment_6(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// providedCapabilities+=ProvidedCapability
protected class Builder_ProvidedCapabilitiesAssignment_9_1 extends AssignmentToken  {
	
	public Builder_ProvidedCapabilitiesAssignment_9_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getProvidedCapabilitiesAssignment_9_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("providedCapabilities",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("providedCapabilities");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getProvidedCapabilityRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_ProvidesKeyword_9_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," providedCapabilities+=ProvidedCapability)*
protected class Builder_Group_9_2 extends GroupToken {
	
	public Builder_Group_9_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_9_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_ProvidedCapabilitiesAssignment_9_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Builder_CommaKeyword_9_2_0 extends KeywordToken  {
	
	public Builder_CommaKeyword_9_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getCommaKeyword_9_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_9_2(parent, this, 0, inst);
			case 1: return new Builder_ProvidedCapabilitiesAssignment_9_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// providedCapabilities+=ProvidedCapability
protected class Builder_ProvidedCapabilitiesAssignment_9_2_1 extends AssignmentToken  {
	
	public Builder_ProvidedCapabilitiesAssignment_9_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getProvidedCapabilitiesAssignment_9_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProvidedCapability_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("providedCapabilities",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("providedCapabilities");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getProvidedCapabilityRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_CommaKeyword_9_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ("precondition" (":" precondExpr=Expression ";"|precondExpr=BlockExpression))?
protected class Builder_Group_10 extends GroupToken {
	
	public Builder_Group_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Alternatives_10_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "precondition"
protected class Builder_PreconditionKeyword_10_0 extends KeywordToken  {
	
	public Builder_PreconditionKeyword_10_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getPreconditionKeyword_10_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_9(parent, this, 0, inst);
			case 1: return new Builder_Group_8(parent, this, 1, inst);
			case 2: return new Builder_Alternatives_7(parent, this, 2, inst);
			case 3: return new Builder_NameAssignment_6(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// ":" precondExpr=Expression ";"|precondExpr=BlockExpression
protected class Builder_Alternatives_10_1 extends AlternativesToken {

	public Builder_Alternatives_10_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBuilderAccess().getAlternatives_10_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_10_1_0(parent, this, 0, inst);
			case 1: return new Builder_PrecondExprAssignment_10_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":" precondExpr=Expression ";"
protected class Builder_Group_10_1_0 extends GroupToken {
	
	public Builder_Group_10_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_10_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_SemicolonKeyword_10_1_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Builder_ColonKeyword_10_1_0_0 extends KeywordToken  {
	
	public Builder_ColonKeyword_10_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getColonKeyword_10_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_PreconditionKeyword_10_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// precondExpr=Expression
protected class Builder_PrecondExprAssignment_10_1_0_1 extends AssignmentToken  {
	
	public Builder_PrecondExprAssignment_10_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getPrecondExprAssignment_10_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("precondExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("precondExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getPrecondExprExpressionParserRuleCall_10_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_ColonKeyword_10_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class Builder_SemicolonKeyword_10_1_0_2 extends KeywordToken  {
	
	public Builder_SemicolonKeyword_10_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getSemicolonKeyword_10_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_PrecondExprAssignment_10_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// precondExpr=BlockExpression
protected class Builder_PrecondExprAssignment_10_1_1 extends AssignmentToken  {
	
	public Builder_PrecondExprAssignment_10_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getPrecondExprAssignment_10_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("precondExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("precondExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getPrecondExprBlockExpressionParserRuleCall_10_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_PreconditionKeyword_10_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=BlockExpression))?
protected class Builder_Group_11 extends GroupToken {
	
	public Builder_Group_11(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_11();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Alternatives_11_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "postcondition"
protected class Builder_PostconditionKeyword_11_0 extends KeywordToken  {
	
	public Builder_PostconditionKeyword_11_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getPostconditionKeyword_11_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_10(parent, this, 0, inst);
			case 1: return new Builder_Group_9(parent, this, 1, inst);
			case 2: return new Builder_Group_8(parent, this, 2, inst);
			case 3: return new Builder_Alternatives_7(parent, this, 3, inst);
			case 4: return new Builder_NameAssignment_6(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
}

// ":" postcondExpr=Expression ";"|postcondExpr=BlockExpression
protected class Builder_Alternatives_11_1 extends AlternativesToken {

	public Builder_Alternatives_11_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBuilderAccess().getAlternatives_11_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_11_1_0(parent, this, 0, inst);
			case 1: return new Builder_PostcondExprAssignment_11_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":" postcondExpr=Expression ";"
protected class Builder_Group_11_1_0 extends GroupToken {
	
	public Builder_Group_11_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_11_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_SemicolonKeyword_11_1_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Builder_ColonKeyword_11_1_0_0 extends KeywordToken  {
	
	public Builder_ColonKeyword_11_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getColonKeyword_11_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_PostconditionKeyword_11_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// postcondExpr=Expression
protected class Builder_PostcondExprAssignment_11_1_0_1 extends AssignmentToken  {
	
	public Builder_PostcondExprAssignment_11_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getPostcondExprAssignment_11_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("postcondExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("postcondExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getPostcondExprExpressionParserRuleCall_11_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_ColonKeyword_11_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class Builder_SemicolonKeyword_11_1_0_2 extends KeywordToken  {
	
	public Builder_SemicolonKeyword_11_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getSemicolonKeyword_11_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_PostcondExprAssignment_11_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// postcondExpr=BlockExpression
protected class Builder_PostcondExprAssignment_11_1_1 extends AssignmentToken  {
	
	public Builder_PostcondExprAssignment_11_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getPostcondExprAssignment_11_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("postcondExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("postcondExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getPostcondExprBlockExpressionParserRuleCall_11_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_PostconditionKeyword_11_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "{"
protected class Builder_LeftCurlyBracketKeyword_12 extends KeywordToken  {
	
	public Builder_LeftCurlyBracketKeyword_12(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getLeftCurlyBracketKeyword_12();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group_11(parent, this, 0, inst);
			case 1: return new Builder_Group_10(parent, this, 1, inst);
			case 2: return new Builder_Group_9(parent, this, 2, inst);
			case 3: return new Builder_Group_8(parent, this, 3, inst);
			case 4: return new Builder_Alternatives_7(parent, this, 4, inst);
			case 5: return new Builder_NameAssignment_6(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
}

// ("default" "properties" defaultProperties=PropertySet)?
protected class Builder_Group_13 extends GroupToken {
	
	public Builder_Group_13(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_13();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_DefaultPropertiesAssignment_13_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "default"
protected class Builder_DefaultKeyword_13_0 extends KeywordToken  {
	
	public Builder_DefaultKeyword_13_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getDefaultKeyword_13_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_LeftCurlyBracketKeyword_12(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "properties"
protected class Builder_PropertiesKeyword_13_1 extends KeywordToken  {
	
	public Builder_PropertiesKeyword_13_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getPropertiesKeyword_13_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_DefaultKeyword_13_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// defaultProperties=PropertySet
protected class Builder_DefaultPropertiesAssignment_13_2 extends AssignmentToken  {
	
	public Builder_DefaultPropertiesAssignment_13_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getDefaultPropertiesAssignment_13_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("defaultProperties",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("defaultProperties");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getDefaultPropertiesPropertySetParserRuleCall_13_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_PropertiesKeyword_13_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// input=BuilderInput?
protected class Builder_InputAssignment_14 extends AssignmentToken  {
	
	public Builder_InputAssignment_14(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getInputAssignment_14();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("input",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("input");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBuilderInputRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getInputBuilderInputParserRuleCall_14_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_Group_13(parent, next, actIndex, consumed);
			case 1: return new Builder_LeftCurlyBracketKeyword_12(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("output" "{" output=PathGroup "}")?
protected class Builder_Group_15 extends GroupToken {
	
	public Builder_Group_15(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderAccess().getGroup_15();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_RightCurlyBracketKeyword_15_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "output"
protected class Builder_OutputKeyword_15_0 extends KeywordToken  {
	
	public Builder_OutputKeyword_15_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getOutputKeyword_15_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_InputAssignment_14(parent, this, 0, inst);
			case 1: return new Builder_Group_13(parent, this, 1, inst);
			case 2: return new Builder_LeftCurlyBracketKeyword_12(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class Builder_LeftCurlyBracketKeyword_15_1 extends KeywordToken  {
	
	public Builder_LeftCurlyBracketKeyword_15_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getLeftCurlyBracketKeyword_15_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_OutputKeyword_15_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// output=PathGroup
protected class Builder_OutputAssignment_15_2 extends AssignmentToken  {
	
	public Builder_OutputAssignment_15_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getOutputAssignment_15_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathGroup_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("output",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("output");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPathGroupRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getOutputPathGroupParserRuleCall_15_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_LeftCurlyBracketKeyword_15_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Builder_RightCurlyBracketKeyword_15_3 extends KeywordToken  {
	
	public Builder_RightCurlyBracketKeyword_15_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getRightCurlyBracketKeyword_15_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_OutputAssignment_15_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// funcExpr=BlockExpressionWithoutBrackets?
protected class Builder_FuncExprAssignment_16 extends AssignmentToken  {
	
	public Builder_FuncExprAssignment_16(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderAccess().getFuncExprAssignment_16();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpressionWithoutBrackets_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("funcExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("funcExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionWithoutBracketsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderAccess().getFuncExprBlockExpressionWithoutBracketsParserRuleCall_16_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Builder_Group_15(parent, next, actIndex, consumed);
			case 1: return new Builder_InputAssignment_14(parent, next, actIndex, consumed);
			case 2: return new Builder_Group_13(parent, next, actIndex, consumed);
			case 3: return new Builder_LeftCurlyBracketKeyword_12(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Builder_RightCurlyBracketKeyword_17 extends KeywordToken  {
	
	public Builder_RightCurlyBracketKeyword_17(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderAccess().getRightCurlyBracketKeyword_17();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_FuncExprAssignment_16(parent, this, 0, inst);
			case 1: return new Builder_Group_15(parent, this, 1, inst);
			case 2: return new Builder_InputAssignment_14(parent, this, 2, inst);
			case 3: return new Builder_Group_13(parent, this, 3, inst);
			case 4: return new Builder_LeftCurlyBracketKeyword_12(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Builder ****************/


/************ begin Rule ParameterList ****************
 *
 * ParameterList returns be::BParameterList:
 *   {be::BParameterList} parameters+=FirstParameter ("," parameters+=FirstParameter)*;
 *
 **/

// {be::BParameterList} parameters+=FirstParameter ("," parameters+=FirstParameter)*
protected class ParameterList_Group extends GroupToken {
	
	public ParameterList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group_2(parent, this, 0, inst);
			case 1: return new ParameterList_ParametersAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BParameterList}
protected class ParameterList_BParameterListAction_0 extends ActionToken  {

	public ParameterList_BParameterListAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getParameterListAccess().getBParameterListAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getParameterListAccess().getBParameterListAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// parameters+=FirstParameter
protected class ParameterList_ParametersAssignment_1 extends AssignmentToken  {
	
	public ParameterList_ParametersAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterListAccess().getParametersAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FirstParameter_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFirstParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterListAccess().getParametersFirstParameterParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ParameterList_BParameterListAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," parameters+=FirstParameter)*
protected class ParameterList_Group_2 extends GroupToken {
	
	public ParameterList_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterListAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_ParametersAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ParameterList_CommaKeyword_2_0 extends KeywordToken  {
	
	public ParameterList_CommaKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParameterListAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group_2(parent, this, 0, inst);
			case 1: return new ParameterList_ParametersAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=FirstParameter
protected class ParameterList_ParametersAssignment_2_1 extends AssignmentToken  {
	
	public ParameterList_ParametersAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterListAccess().getParametersAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FirstParameter_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFirstParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterListAccess().getParametersFirstParameterParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ParameterList_CommaKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ParameterList ****************/


/************ begin Rule FirstParameter ****************
 *
 * FirstParameter returns be::BParameter:
 *   ClosureParameter|Parameter;
 *
 **/

// ClosureParameter|Parameter
protected class FirstParameter_Alternatives extends AlternativesToken {

	public FirstParameter_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFirstParameterAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FirstParameter_ClosureParameterParserRuleCall_0(parent, this, 0, inst);
			case 1: return new FirstParameter_ParameterParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFirstParameterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ClosureParameter
protected class FirstParameter_ClosureParameterParserRuleCall_0 extends RuleCallToken {
	
	public FirstParameter_ClosureParameterParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFirstParameterAccess().getClosureParameterParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ClosureParameter_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getClosureParameterRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Parameter
protected class FirstParameter_ParameterParserRuleCall_1 extends RuleCallToken {
	
	public FirstParameter_ParameterParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFirstParameterAccess().getParameterParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Parameter_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule FirstParameter ****************/


/************ begin Rule Parameter ****************
 *
 * Parameter returns be::BParameter:
 *   {be::BParameter} expr=Expression;
 *
 **/

// {be::BParameter} expr=Expression
protected class Parameter_Group extends GroupToken {
	
	public Parameter_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_ExprAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BParameter}
protected class Parameter_BParameterAction_0 extends ActionToken  {

	public Parameter_BParameterAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getParameterAccess().getBParameterAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getParameterAccess().getBParameterAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// expr=Expression
protected class Parameter_ExprAssignment_1 extends AssignmentToken  {
	
	public Parameter_ExprAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getExprAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterAccess().getExprExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Parameter_BParameterAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Parameter ****************/


/************ begin Rule ClosureParameter ****************
 *
 * ClosureParameter returns be::BParameter:
 *   {be::BParameter} expr=ClosureExpression;
 *
 **/

// {be::BParameter} expr=ClosureExpression
protected class ClosureParameter_Group extends GroupToken {
	
	public ClosureParameter_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureParameterAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureParameter_ExprAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getClosureParameterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BParameter}
protected class ClosureParameter_BParameterAction_0 extends ActionToken  {

	public ClosureParameter_BParameterAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getClosureParameterAccess().getBParameterAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getClosureParameterAccess().getBParameterAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// expr=ClosureExpression
protected class ClosureParameter_ExprAssignment_1 extends AssignmentToken  {
	
	public ClosureParameter_ExprAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureParameterAccess().getExprAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClosureExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureParameterAccess().getExprClosureExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ClosureParameter_BParameterAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ClosureParameter ****************/


/************ begin Rule ParameterDeclaration ****************
 *
 * ParameterDeclaration returns be::BParameterDeclaration:
 *   {be::BParameterDeclaration} (type=TypeRef? name=ID);
 *
 **/

// {be::BParameterDeclaration} (type=TypeRef? name=ID)
protected class ParameterDeclaration_Group extends GroupToken {
	
	public ParameterDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BParameterDeclaration}
protected class ParameterDeclaration_BParameterDeclarationAction_0 extends ActionToken  {

	public ParameterDeclaration_BParameterDeclarationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getParameterDeclarationAccess().getBParameterDeclarationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getParameterDeclarationAccess().getBParameterDeclarationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// type=TypeRef? name=ID
protected class ParameterDeclaration_Group_1 extends GroupToken {
	
	public ParameterDeclaration_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterDeclarationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_NameAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef?
protected class ParameterDeclaration_TypeAssignment_1_0 extends AssignmentToken  {
	
	public ParameterDeclaration_TypeAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterDeclarationAccess().getTypeAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParameterDeclarationAccess().getTypeTypeRefParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ParameterDeclaration_BParameterDeclarationAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// name=ID
protected class ParameterDeclaration_NameAssignment_1_1 extends AssignmentToken  {
	
	public ParameterDeclaration_NameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterDeclarationAccess().getNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_TypeAssignment_1_0(parent, this, 0, inst);
			case 1: return new ParameterDeclaration_BParameterDeclarationAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getParameterDeclarationAccess().getNameIDTerminalRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule ParameterDeclaration ****************/


/************ begin Rule BuilderInput ****************
 *
 * BuilderInput returns build::BuilderInput:
 *   {build::BuilderInput} "input" ("precondition" (":" precondExpr=Expression ";"|
 *   precondExpr=BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|
 *   postcondExpr=BlockExpression))? "{" prerequisites+=Prerequisite+ "}";
 *
 **/

// {build::BuilderInput} "input" ("precondition" (":" precondExpr=Expression ";"|
// precondExpr=BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|
// postcondExpr=BlockExpression))? "{" prerequisites+=Prerequisite+ "}"
protected class BuilderInput_Group extends GroupToken {
	
	public BuilderInput_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_RightCurlyBracketKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBuilderInputRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::BuilderInput}
protected class BuilderInput_BuilderInputAction_0 extends ActionToken  {

	public BuilderInput_BuilderInputAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getBuilderInputAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBuilderInputAccess().getBuilderInputAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "input"
protected class BuilderInput_InputKeyword_1 extends KeywordToken  {
	
	public BuilderInput_InputKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getInputKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_BuilderInputAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("precondition" (":" precondExpr=Expression ";"|precondExpr=BlockExpression))?
protected class BuilderInput_Group_2 extends GroupToken {
	
	public BuilderInput_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_Alternatives_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "precondition"
protected class BuilderInput_PreconditionKeyword_2_0 extends KeywordToken  {
	
	public BuilderInput_PreconditionKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getPreconditionKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_InputKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":" precondExpr=Expression ";"|precondExpr=BlockExpression
protected class BuilderInput_Alternatives_2_1 extends AlternativesToken {

	public BuilderInput_Alternatives_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getAlternatives_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_Group_2_1_0(parent, this, 0, inst);
			case 1: return new BuilderInput_PrecondExprAssignment_2_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":" precondExpr=Expression ";"
protected class BuilderInput_Group_2_1_0 extends GroupToken {
	
	public BuilderInput_Group_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getGroup_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_SemicolonKeyword_2_1_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class BuilderInput_ColonKeyword_2_1_0_0 extends KeywordToken  {
	
	public BuilderInput_ColonKeyword_2_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getColonKeyword_2_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_PreconditionKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// precondExpr=Expression
protected class BuilderInput_PrecondExprAssignment_2_1_0_1 extends AssignmentToken  {
	
	public BuilderInput_PrecondExprAssignment_2_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getPrecondExprAssignment_2_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("precondExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("precondExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderInputAccess().getPrecondExprExpressionParserRuleCall_2_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuilderInput_ColonKeyword_2_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BuilderInput_SemicolonKeyword_2_1_0_2 extends KeywordToken  {
	
	public BuilderInput_SemicolonKeyword_2_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getSemicolonKeyword_2_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_PrecondExprAssignment_2_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// precondExpr=BlockExpression
protected class BuilderInput_PrecondExprAssignment_2_1_1 extends AssignmentToken  {
	
	public BuilderInput_PrecondExprAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getPrecondExprAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("precondExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("precondExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderInputAccess().getPrecondExprBlockExpressionParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuilderInput_PreconditionKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=BlockExpression))?
protected class BuilderInput_Group_3 extends GroupToken {
	
	public BuilderInput_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_Alternatives_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "postcondition"
protected class BuilderInput_PostconditionKeyword_3_0 extends KeywordToken  {
	
	public BuilderInput_PostconditionKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getPostconditionKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_Group_2(parent, this, 0, inst);
			case 1: return new BuilderInput_InputKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":" postcondExpr=Expression ";"|postcondExpr=BlockExpression
protected class BuilderInput_Alternatives_3_1 extends AlternativesToken {

	public BuilderInput_Alternatives_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getAlternatives_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_Group_3_1_0(parent, this, 0, inst);
			case 1: return new BuilderInput_PostcondExprAssignment_3_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":" postcondExpr=Expression ";"
protected class BuilderInput_Group_3_1_0 extends GroupToken {
	
	public BuilderInput_Group_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getGroup_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_SemicolonKeyword_3_1_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class BuilderInput_ColonKeyword_3_1_0_0 extends KeywordToken  {
	
	public BuilderInput_ColonKeyword_3_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getColonKeyword_3_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_PostconditionKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// postcondExpr=Expression
protected class BuilderInput_PostcondExprAssignment_3_1_0_1 extends AssignmentToken  {
	
	public BuilderInput_PostcondExprAssignment_3_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getPostcondExprAssignment_3_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("postcondExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("postcondExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderInputAccess().getPostcondExprExpressionParserRuleCall_3_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuilderInput_ColonKeyword_3_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BuilderInput_SemicolonKeyword_3_1_0_2 extends KeywordToken  {
	
	public BuilderInput_SemicolonKeyword_3_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getSemicolonKeyword_3_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_PostcondExprAssignment_3_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// postcondExpr=BlockExpression
protected class BuilderInput_PostcondExprAssignment_3_1_1 extends AssignmentToken  {
	
	public BuilderInput_PostcondExprAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getPostcondExprAssignment_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("postcondExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("postcondExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderInputAccess().getPostcondExprBlockExpressionParserRuleCall_3_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuilderInput_PostconditionKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "{"
protected class BuilderInput_LeftCurlyBracketKeyword_4 extends KeywordToken  {
	
	public BuilderInput_LeftCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getLeftCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_Group_3(parent, this, 0, inst);
			case 1: return new BuilderInput_Group_2(parent, this, 1, inst);
			case 2: return new BuilderInput_InputKeyword_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// prerequisites+=Prerequisite+
protected class BuilderInput_PrerequisitesAssignment_5 extends AssignmentToken  {
	
	public BuilderInput_PrerequisitesAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getPrerequisitesAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Prerequisite_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("prerequisites",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("prerequisites");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrerequisiteRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBuilderInputAccess().getPrerequisitesPrerequisiteParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuilderInput_PrerequisitesAssignment_5(parent, next, actIndex, consumed);
			case 1: return new BuilderInput_LeftCurlyBracketKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class BuilderInput_RightCurlyBracketKeyword_6 extends KeywordToken  {
	
	public BuilderInput_RightCurlyBracketKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuilderInputAccess().getRightCurlyBracketKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BuilderInput_PrerequisitesAssignment_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule BuilderInput ****************/


/************ begin Rule RepositoryConfiguration ****************
 *
 * RepositoryConfiguration returns build::RepositoryConfiguration:
 *   RepositoryDeclaration|ResolutionStrategy;
 *
 **/

// RepositoryDeclaration|ResolutionStrategy
protected class RepositoryConfiguration_Alternatives extends AlternativesToken {

	public RepositoryConfiguration_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRepositoryConfigurationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryConfiguration_RepositoryDeclarationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new RepositoryConfiguration_ResolutionStrategyParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRepositoryConfigurationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// RepositoryDeclaration
protected class RepositoryConfiguration_RepositoryDeclarationParserRuleCall_0 extends RuleCallToken {
	
	public RepositoryConfiguration_RepositoryDeclarationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRepositoryConfigurationAccess().getRepositoryDeclarationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RepositoryDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRepositoryDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ResolutionStrategy
protected class RepositoryConfiguration_ResolutionStrategyParserRuleCall_1 extends RuleCallToken {
	
	public RepositoryConfiguration_ResolutionStrategyParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRepositoryConfigurationAccess().getResolutionStrategyParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategy_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ResolutionStrategy_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getResolutionStrategyRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule RepositoryConfiguration ****************/


/************ begin Rule RepositoryDeclaration ****************
 *
 * RepositoryDeclaration returns build::RepositoryDeclaration:
 *   {build::RepositoryDeclaration} documentation=DOCUMENTATION? (location=URI|
 *   "repository" resolverType=TypeRef) contextBlock=ContextBlock_Creation?;
 *
 **/

// {build::RepositoryDeclaration} documentation=DOCUMENTATION? (location=URI|
// "repository" resolverType=TypeRef) contextBlock=ContextBlock_Creation?
protected class RepositoryDeclaration_Group extends GroupToken {
	
	public RepositoryDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryDeclaration_ContextBlockAssignment_3(parent, this, 0, inst);
			case 1: return new RepositoryDeclaration_Alternatives_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRepositoryDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::RepositoryDeclaration}
protected class RepositoryDeclaration_RepositoryDeclarationAction_0 extends ActionToken  {

	public RepositoryDeclaration_RepositoryDeclarationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getRepositoryDeclarationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRepositoryDeclarationAccess().getRepositoryDeclarationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// documentation=DOCUMENTATION?
protected class RepositoryDeclaration_DocumentationAssignment_1 extends AssignmentToken  {
	
	public RepositoryDeclaration_DocumentationAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getDocumentationAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryDeclaration_RepositoryDeclarationAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("documentation",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("documentation");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRepositoryDeclarationAccess().getDocumentationDOCUMENTATIONTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// location=URI|"repository" resolverType=TypeRef
protected class RepositoryDeclaration_Alternatives_2 extends AlternativesToken {

	public RepositoryDeclaration_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryDeclaration_LocationAssignment_2_0(parent, this, 0, inst);
			case 1: return new RepositoryDeclaration_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// location=URI
protected class RepositoryDeclaration_LocationAssignment_2_0 extends AssignmentToken  {
	
	public RepositoryDeclaration_LocationAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getLocationAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryDeclaration_DocumentationAssignment_1(parent, this, 0, inst);
			case 1: return new RepositoryDeclaration_RepositoryDeclarationAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("location",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("location");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRepositoryDeclarationAccess().getLocationURIParserRuleCall_2_0_0();
			return obj;
		}
		return null;
	}

}

// "repository" resolverType=TypeRef
protected class RepositoryDeclaration_Group_2_1 extends GroupToken {
	
	public RepositoryDeclaration_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryDeclaration_ResolverTypeAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "repository"
protected class RepositoryDeclaration_RepositoryKeyword_2_1_0 extends KeywordToken  {
	
	public RepositoryDeclaration_RepositoryKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getRepositoryKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryDeclaration_DocumentationAssignment_1(parent, this, 0, inst);
			case 1: return new RepositoryDeclaration_RepositoryDeclarationAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// resolverType=TypeRef
protected class RepositoryDeclaration_ResolverTypeAssignment_2_1_1 extends AssignmentToken  {
	
	public RepositoryDeclaration_ResolverTypeAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getResolverTypeAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("resolverType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("resolverType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRepositoryDeclarationAccess().getResolverTypeTypeRefParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RepositoryDeclaration_RepositoryKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// contextBlock=ContextBlock_Creation?
protected class RepositoryDeclaration_ContextBlockAssignment_3 extends AssignmentToken  {
	
	public RepositoryDeclaration_ContextBlockAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRepositoryDeclarationAccess().getContextBlockAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Creation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("contextBlock",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("contextBlock");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getContextBlock_CreationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRepositoryDeclarationAccess().getContextBlockContextBlock_CreationParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RepositoryDeclaration_Alternatives_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule RepositoryDeclaration ****************/


/************ begin Rule ResolutionStrategy ****************
 *
 * ResolutionStrategy returns build::ResolutionStrategy:
 *   ResolutionStrategyFirst|ResolutionStrategyBest;
 *
 **/

// ResolutionStrategyFirst|ResolutionStrategyBest
protected class ResolutionStrategy_Alternatives extends AlternativesToken {

	public ResolutionStrategy_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getResolutionStrategyAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategy_ResolutionStrategyFirstParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ResolutionStrategy_ResolutionStrategyBestParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getResolutionStrategyRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ResolutionStrategyFirst
protected class ResolutionStrategy_ResolutionStrategyFirstParserRuleCall_0 extends RuleCallToken {
	
	public ResolutionStrategy_ResolutionStrategyFirstParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getResolutionStrategyAccess().getResolutionStrategyFirstParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyFirst_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ResolutionStrategyFirst_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getResolutionStrategyFirstRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ResolutionStrategyBest
protected class ResolutionStrategy_ResolutionStrategyBestParserRuleCall_1 extends RuleCallToken {
	
	public ResolutionStrategy_ResolutionStrategyBestParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getResolutionStrategyAccess().getResolutionStrategyBestParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyBest_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ResolutionStrategyBest_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getResolutionStrategyBestRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ResolutionStrategy ****************/


/************ begin Rule ResolutionStrategyFirst ****************
 *
 * ResolutionStrategyFirst returns build::ResolutionStrategyFirst:
 *   {build::ResolutionStrategyFirst} "select-first" "{" repositories+=
 *   RepositoryConfiguration* "}";
 *
 **/

// {build::ResolutionStrategyFirst} "select-first" "{" repositories+=
// RepositoryConfiguration* "}"
protected class ResolutionStrategyFirst_Group extends GroupToken {
	
	public ResolutionStrategyFirst_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getResolutionStrategyFirstAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyFirst_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getResolutionStrategyFirstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::ResolutionStrategyFirst}
protected class ResolutionStrategyFirst_ResolutionStrategyFirstAction_0 extends ActionToken  {

	public ResolutionStrategyFirst_ResolutionStrategyFirstAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getResolutionStrategyFirstAccess().getResolutionStrategyFirstAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getResolutionStrategyFirstAccess().getResolutionStrategyFirstAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "select-first"
protected class ResolutionStrategyFirst_SelectFirstKeyword_1 extends KeywordToken  {
	
	public ResolutionStrategyFirst_SelectFirstKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getResolutionStrategyFirstAccess().getSelectFirstKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyFirst_ResolutionStrategyFirstAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class ResolutionStrategyFirst_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public ResolutionStrategyFirst_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getResolutionStrategyFirstAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyFirst_SelectFirstKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// repositories+=RepositoryConfiguration*
protected class ResolutionStrategyFirst_RepositoriesAssignment_3 extends AssignmentToken  {
	
	public ResolutionStrategyFirst_RepositoriesAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getResolutionStrategyFirstAccess().getRepositoriesAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryConfiguration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("repositories",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("repositories");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRepositoryConfigurationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getResolutionStrategyFirstAccess().getRepositoriesRepositoryConfigurationParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ResolutionStrategyFirst_RepositoriesAssignment_3(parent, next, actIndex, consumed);
			case 1: return new ResolutionStrategyFirst_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class ResolutionStrategyFirst_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public ResolutionStrategyFirst_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getResolutionStrategyFirstAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyFirst_RepositoriesAssignment_3(parent, this, 0, inst);
			case 1: return new ResolutionStrategyFirst_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ResolutionStrategyFirst ****************/


/************ begin Rule ResolutionStrategyBest ****************
 *
 * ResolutionStrategyBest returns build::ResolutionStrategyBest:
 *   {build::ResolutionStrategyBest} "select-best" "{" repositories+=
 *   RepositoryConfiguration* "}";
 *
 **/

// {build::ResolutionStrategyBest} "select-best" "{" repositories+=
// RepositoryConfiguration* "}"
protected class ResolutionStrategyBest_Group extends GroupToken {
	
	public ResolutionStrategyBest_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getResolutionStrategyBestAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyBest_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getResolutionStrategyBestRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::ResolutionStrategyBest}
protected class ResolutionStrategyBest_ResolutionStrategyBestAction_0 extends ActionToken  {

	public ResolutionStrategyBest_ResolutionStrategyBestAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getResolutionStrategyBestAccess().getResolutionStrategyBestAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getResolutionStrategyBestAccess().getResolutionStrategyBestAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "select-best"
protected class ResolutionStrategyBest_SelectBestKeyword_1 extends KeywordToken  {
	
	public ResolutionStrategyBest_SelectBestKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getResolutionStrategyBestAccess().getSelectBestKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyBest_ResolutionStrategyBestAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class ResolutionStrategyBest_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public ResolutionStrategyBest_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getResolutionStrategyBestAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyBest_SelectBestKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// repositories+=RepositoryConfiguration*
protected class ResolutionStrategyBest_RepositoriesAssignment_3 extends AssignmentToken  {
	
	public ResolutionStrategyBest_RepositoriesAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getResolutionStrategyBestAccess().getRepositoriesAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RepositoryConfiguration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("repositories",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("repositories");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRepositoryConfigurationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getResolutionStrategyBestAccess().getRepositoriesRepositoryConfigurationParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ResolutionStrategyBest_RepositoriesAssignment_3(parent, next, actIndex, consumed);
			case 1: return new ResolutionStrategyBest_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class ResolutionStrategyBest_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public ResolutionStrategyBest_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getResolutionStrategyBestAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ResolutionStrategyBest_RepositoriesAssignment_3(parent, this, 0, inst);
			case 1: return new ResolutionStrategyBest_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ResolutionStrategyBest ****************/


/************ begin Rule ContainerConfiguration ****************
 *
 * ContainerConfiguration returns build::ContainerConfiguration:
 *   {build::ContainerConfiguration} documentation=DOCUMENTATION? "container" name=ID
 *   "agent" agentType=TypeRef contextBlock=ContextBlock_Creation?;
 *
 **/

// {build::ContainerConfiguration} documentation=DOCUMENTATION? "container" name=ID
// "agent" agentType=TypeRef contextBlock=ContextBlock_Creation?
protected class ContainerConfiguration_Group extends GroupToken {
	
	public ContainerConfiguration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getContainerConfigurationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContainerConfiguration_ContextBlockAssignment_6(parent, this, 0, inst);
			case 1: return new ContainerConfiguration_AgentTypeAssignment_5(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getContainerConfigurationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {build::ContainerConfiguration}
protected class ContainerConfiguration_ContainerConfigurationAction_0 extends ActionToken  {

	public ContainerConfiguration_ContainerConfigurationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getContainerConfigurationAccess().getContainerConfigurationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getContainerConfigurationAccess().getContainerConfigurationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// documentation=DOCUMENTATION?
protected class ContainerConfiguration_DocumentationAssignment_1 extends AssignmentToken  {
	
	public ContainerConfiguration_DocumentationAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getContainerConfigurationAccess().getDocumentationAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContainerConfiguration_ContainerConfigurationAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("documentation",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("documentation");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getContainerConfigurationAccess().getDocumentationDOCUMENTATIONTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "container"
protected class ContainerConfiguration_ContainerKeyword_2 extends KeywordToken  {
	
	public ContainerConfiguration_ContainerKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getContainerConfigurationAccess().getContainerKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContainerConfiguration_DocumentationAssignment_1(parent, this, 0, inst);
			case 1: return new ContainerConfiguration_ContainerConfigurationAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class ContainerConfiguration_NameAssignment_3 extends AssignmentToken  {
	
	public ContainerConfiguration_NameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getContainerConfigurationAccess().getNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContainerConfiguration_ContainerKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getContainerConfigurationAccess().getNameIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// "agent"
protected class ContainerConfiguration_AgentKeyword_4 extends KeywordToken  {
	
	public ContainerConfiguration_AgentKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getContainerConfigurationAccess().getAgentKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContainerConfiguration_NameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// agentType=TypeRef
protected class ContainerConfiguration_AgentTypeAssignment_5 extends AssignmentToken  {
	
	public ContainerConfiguration_AgentTypeAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getContainerConfigurationAccess().getAgentTypeAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("agentType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("agentType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getContainerConfigurationAccess().getAgentTypeTypeRefParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ContainerConfiguration_AgentKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// contextBlock=ContextBlock_Creation?
protected class ContainerConfiguration_ContextBlockAssignment_6 extends AssignmentToken  {
	
	public ContainerConfiguration_ContextBlockAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getContainerConfigurationAccess().getContextBlockAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Creation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("contextBlock",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("contextBlock");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getContextBlock_CreationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getContainerConfigurationAccess().getContextBlockContextBlock_CreationParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ContainerConfiguration_AgentTypeAssignment_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ContainerConfiguration ****************/



/************ begin Rule Concern_Named ****************
 *
 * Concern_Named returns be::BConcern:
 *   {be::BConcern} documentation=DOCUMENTATION? "concern" name=ID ("extends"
 *   superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)? "{" (
 *   "properties" propertySets+=PropertySet|functions+=Function|functions+=Builder)*
 *   "}";
 *
 **/

// {be::BConcern} documentation=DOCUMENTATION? "concern" name=ID ("extends"
// superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)? "{" (
// "properties" propertySets+=PropertySet|functions+=Function|functions+=Builder)*
// "}"
protected class Concern_Named_Group extends GroupToken {
	
	public Concern_Named_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_RightCurlyBracketKeyword_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConcern_NamedRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BConcern}
protected class Concern_Named_BConcernAction_0 extends ActionToken  {

	public Concern_Named_BConcernAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getBConcernAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getConcern_NamedAccess().getBConcernAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// documentation=DOCUMENTATION?
protected class Concern_Named_DocumentationAssignment_1 extends AssignmentToken  {
	
	public Concern_Named_DocumentationAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getDocumentationAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_BConcernAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("documentation",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("documentation");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getConcern_NamedAccess().getDocumentationDOCUMENTATIONTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "concern"
protected class Concern_Named_ConcernKeyword_2 extends KeywordToken  {
	
	public Concern_Named_ConcernKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getConcernKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_DocumentationAssignment_1(parent, this, 0, inst);
			case 1: return new Concern_Named_BConcernAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Concern_Named_NameAssignment_3 extends AssignmentToken  {
	
	public Concern_Named_NameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_ConcernKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getConcern_NamedAccess().getNameIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// ("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)?
protected class Concern_Named_Group_4 extends GroupToken {
	
	public Concern_Named_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_Group_4_2(parent, this, 0, inst);
			case 1: return new Concern_Named_SuperConcernsAssignment_4_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class Concern_Named_ExtendsKeyword_4_0 extends KeywordToken  {
	
	public Concern_Named_ExtendsKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getExtendsKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_NameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// superConcerns+=[be::BConcern]
protected class Concern_Named_SuperConcernsAssignment_4_1 extends AssignmentToken  {
	
	public Concern_Named_SuperConcernsAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getSuperConcernsAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_ExtendsKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("superConcerns",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("superConcerns");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcern_NamedAccess().getSuperConcernsBConcernCrossReference_4_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getConcern_NamedAccess().getSuperConcernsBConcernCrossReference_4_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," superConcerns+=[be::BConcern])*
protected class Concern_Named_Group_4_2 extends GroupToken {
	
	public Concern_Named_Group_4_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getGroup_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_SuperConcernsAssignment_4_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Concern_Named_CommaKeyword_4_2_0 extends KeywordToken  {
	
	public Concern_Named_CommaKeyword_4_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getCommaKeyword_4_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_Group_4_2(parent, this, 0, inst);
			case 1: return new Concern_Named_SuperConcernsAssignment_4_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// superConcerns+=[be::BConcern]
protected class Concern_Named_SuperConcernsAssignment_4_2_1 extends AssignmentToken  {
	
	public Concern_Named_SuperConcernsAssignment_4_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getSuperConcernsAssignment_4_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_CommaKeyword_4_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("superConcerns",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("superConcerns");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcern_NamedAccess().getSuperConcernsBConcernCrossReference_4_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getConcern_NamedAccess().getSuperConcernsBConcernCrossReference_4_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}



// "{"
protected class Concern_Named_LeftCurlyBracketKeyword_5 extends KeywordToken  {
	
	public Concern_Named_LeftCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getLeftCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_Group_4(parent, this, 0, inst);
			case 1: return new Concern_Named_NameAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ("properties" propertySets+=PropertySet|functions+=Function|functions+=Builder)*
protected class Concern_Named_Alternatives_6 extends AlternativesToken {

	public Concern_Named_Alternatives_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getAlternatives_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_Group_6_0(parent, this, 0, inst);
			case 1: return new Concern_Named_FunctionsAssignment_6_1(parent, this, 1, inst);
			case 2: return new Concern_Named_FunctionsAssignment_6_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "properties" propertySets+=PropertySet
protected class Concern_Named_Group_6_0 extends GroupToken {
	
	public Concern_Named_Group_6_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getGroup_6_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_PropertySetsAssignment_6_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "properties"
protected class Concern_Named_PropertiesKeyword_6_0_0 extends KeywordToken  {
	
	public Concern_Named_PropertiesKeyword_6_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getPropertiesKeyword_6_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_Alternatives_6(parent, this, 0, inst);
			case 1: return new Concern_Named_LeftCurlyBracketKeyword_5(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// propertySets+=PropertySet
protected class Concern_Named_PropertySetsAssignment_6_0_1 extends AssignmentToken  {
	
	public Concern_Named_PropertySetsAssignment_6_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getPropertySetsAssignment_6_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("propertySets",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("propertySets");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConcern_NamedAccess().getPropertySetsPropertySetParserRuleCall_6_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Concern_Named_PropertiesKeyword_6_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// functions+=Function
protected class Concern_Named_FunctionsAssignment_6_1 extends AssignmentToken  {
	
	public Concern_Named_FunctionsAssignment_6_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getFunctionsAssignment_6_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConcern_NamedAccess().getFunctionsFunctionParserRuleCall_6_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Concern_Named_Alternatives_6(parent, next, actIndex, consumed);
			case 1: return new Concern_Named_LeftCurlyBracketKeyword_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// functions+=Builder
protected class Concern_Named_FunctionsAssignment_6_2 extends AssignmentToken  {
	
	public Concern_Named_FunctionsAssignment_6_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getFunctionsAssignment_6_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBuilderRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConcern_NamedAccess().getFunctionsBuilderParserRuleCall_6_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Concern_Named_Alternatives_6(parent, next, actIndex, consumed);
			case 1: return new Concern_Named_LeftCurlyBracketKeyword_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class Concern_Named_RightCurlyBracketKeyword_7 extends KeywordToken  {
	
	public Concern_Named_RightCurlyBracketKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_NamedAccess().getRightCurlyBracketKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Named_Alternatives_6(parent, this, 0, inst);
			case 1: return new Concern_Named_LeftCurlyBracketKeyword_5(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Concern_Named ****************/


/************ begin Rule Concern_Anonymous ****************
 *
 * Concern_Anonymous returns be::BConcern:
 *   {be::BConcern} ("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::
 *   BConcern])*)? "{" ("properties" propertySets+=PropertySet|functions+=Function|
 *   functions+=Builder)* "}";
 *
 **/

// {be::BConcern} ("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::
// BConcern])*)? "{" ("properties" propertySets+=PropertySet|functions+=Function|
// functions+=Builder)* "}"
protected class Concern_Anonymous_Group extends GroupToken {
	
	public Concern_Anonymous_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConcern_AnonymousRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BConcern}
protected class Concern_Anonymous_BConcernAction_0 extends ActionToken  {

	public Concern_Anonymous_BConcernAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getBConcernAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getConcern_AnonymousAccess().getBConcernAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)?
protected class Concern_Anonymous_Group_1 extends GroupToken {
	
	public Concern_Anonymous_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_Group_1_2(parent, this, 0, inst);
			case 1: return new Concern_Anonymous_SuperConcernsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class Concern_Anonymous_ExtendsKeyword_1_0 extends KeywordToken  {
	
	public Concern_Anonymous_ExtendsKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getExtendsKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_BConcernAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// superConcerns+=[be::BConcern]
protected class Concern_Anonymous_SuperConcernsAssignment_1_1 extends AssignmentToken  {
	
	public Concern_Anonymous_SuperConcernsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getSuperConcernsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_ExtendsKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("superConcerns",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("superConcerns");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcern_AnonymousAccess().getSuperConcernsBConcernCrossReference_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getConcern_AnonymousAccess().getSuperConcernsBConcernCrossReference_1_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," superConcerns+=[be::BConcern])*
protected class Concern_Anonymous_Group_1_2 extends GroupToken {
	
	public Concern_Anonymous_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_SuperConcernsAssignment_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Concern_Anonymous_CommaKeyword_1_2_0 extends KeywordToken  {
	
	public Concern_Anonymous_CommaKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getCommaKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_Group_1_2(parent, this, 0, inst);
			case 1: return new Concern_Anonymous_SuperConcernsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// superConcerns+=[be::BConcern]
protected class Concern_Anonymous_SuperConcernsAssignment_1_2_1 extends AssignmentToken  {
	
	public Concern_Anonymous_SuperConcernsAssignment_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getSuperConcernsAssignment_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_CommaKeyword_1_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("superConcerns",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("superConcerns");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcern_AnonymousAccess().getSuperConcernsBConcernCrossReference_1_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getConcern_AnonymousAccess().getSuperConcernsBConcernCrossReference_1_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}



// "{"
protected class Concern_Anonymous_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public Concern_Anonymous_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_Group_1(parent, this, 0, inst);
			case 1: return new Concern_Anonymous_BConcernAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ("properties" propertySets+=PropertySet|functions+=Function|functions+=Builder)*
protected class Concern_Anonymous_Alternatives_3 extends AlternativesToken {

	public Concern_Anonymous_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_Group_3_0(parent, this, 0, inst);
			case 1: return new Concern_Anonymous_FunctionsAssignment_3_1(parent, this, 1, inst);
			case 2: return new Concern_Anonymous_FunctionsAssignment_3_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "properties" propertySets+=PropertySet
protected class Concern_Anonymous_Group_3_0 extends GroupToken {
	
	public Concern_Anonymous_Group_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getGroup_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_PropertySetsAssignment_3_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "properties"
protected class Concern_Anonymous_PropertiesKeyword_3_0_0 extends KeywordToken  {
	
	public Concern_Anonymous_PropertiesKeyword_3_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getPropertiesKeyword_3_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_Alternatives_3(parent, this, 0, inst);
			case 1: return new Concern_Anonymous_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// propertySets+=PropertySet
protected class Concern_Anonymous_PropertySetsAssignment_3_0_1 extends AssignmentToken  {
	
	public Concern_Anonymous_PropertySetsAssignment_3_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getPropertySetsAssignment_3_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertySet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("propertySets",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("propertySets");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPropertySetRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConcern_AnonymousAccess().getPropertySetsPropertySetParserRuleCall_3_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Concern_Anonymous_PropertiesKeyword_3_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// functions+=Function
protected class Concern_Anonymous_FunctionsAssignment_3_1 extends AssignmentToken  {
	
	public Concern_Anonymous_FunctionsAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getFunctionsAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConcern_AnonymousAccess().getFunctionsFunctionParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Concern_Anonymous_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new Concern_Anonymous_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// functions+=Builder
protected class Concern_Anonymous_FunctionsAssignment_3_2 extends AssignmentToken  {
	
	public Concern_Anonymous_FunctionsAssignment_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getFunctionsAssignment_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Builder_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBuilderRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConcern_AnonymousAccess().getFunctionsBuilderParserRuleCall_3_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Concern_Anonymous_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new Concern_Anonymous_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class Concern_Anonymous_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public Concern_Anonymous_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcern_AnonymousAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concern_Anonymous_Alternatives_3(parent, this, 0, inst);
			case 1: return new Concern_Anonymous_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Concern_Anonymous ****************/


/************ begin Rule Function ****************
 *
 * Function returns be::B3Function:
 *   {be::B3Function} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
 *   ExecutionMode? final?="final"? "function" returnType=TypeRef? name=ID ("(" (parameters
 *   +=ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
 *   parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
 *   ParameterDeclaration)? ")")? ("when" guard=GuardExpression)? (":" funcExpr=Expression
 *   ";"|funcExpr=BlockExpression); 
 * 
 *         
 * 	    
 *    	    
 *         	   	
 *    	    
 *    	
 *    	    
 *    	 
 * //   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
 *
 **/

// {be::B3Function} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
// ExecutionMode? final?="final"? "function" returnType=TypeRef? name=ID ("(" (parameters
// +=ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
// parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
// ParameterDeclaration)? ")")? ("when" guard=GuardExpression)? (":" funcExpr=Expression
// ";"|funcExpr=BlockExpression)   
// 	    
//    	    
//         	   	
//    	    
//    	
//    	    
//    	 
// //   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
protected class Function_Group extends GroupToken {
	
	public Function_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Alternatives_10(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::B3Function}
protected class Function_B3FunctionAction_0 extends ActionToken  {

	public Function_B3FunctionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFunctionAccess().getB3FunctionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFunctionAccess().getB3FunctionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// documentation=DOCUMENTATION?
protected class Function_DocumentationAssignment_1 extends AssignmentToken  {
	
	public Function_DocumentationAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getDocumentationAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_B3FunctionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("documentation",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("documentation");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFunctionAccess().getDocumentationDOCUMENTATIONTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// visibility=Visibility?
protected class Function_VisibilityAssignment_2 extends AssignmentToken  {
	
	public Function_VisibilityAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getVisibilityAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_DocumentationAssignment_1(parent, this, 0, inst);
			case 1: return new Function_B3FunctionAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("visibility",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("visibility");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getFunctionAccess().getVisibilityVisibilityEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// executionMode=ExecutionMode?
protected class Function_ExecutionModeAssignment_3 extends AssignmentToken  {
	
	public Function_ExecutionModeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getExecutionModeAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_VisibilityAssignment_2(parent, this, 0, inst);
			case 1: return new Function_DocumentationAssignment_1(parent, this, 1, inst);
			case 2: return new Function_B3FunctionAction_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("executionMode",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("executionMode");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getFunctionAccess().getExecutionModeExecutionModeEnumRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// final?="final"?
protected class Function_FinalAssignment_4 extends AssignmentToken  {
	
	public Function_FinalAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getFinalAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_ExecutionModeAssignment_3(parent, this, 0, inst);
			case 1: return new Function_VisibilityAssignment_2(parent, this, 1, inst);
			case 2: return new Function_DocumentationAssignment_1(parent, this, 2, inst);
			case 3: return new Function_B3FunctionAction_0(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("final",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("final");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFunctionAccess().getFinalFinalKeyword_4_0();
			return obj;
		}
		return null;
	}

}

// "function"
protected class Function_FunctionKeyword_5 extends KeywordToken  {
	
	public Function_FunctionKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getFunctionKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_FinalAssignment_4(parent, this, 0, inst);
			case 1: return new Function_ExecutionModeAssignment_3(parent, this, 1, inst);
			case 2: return new Function_VisibilityAssignment_2(parent, this, 2, inst);
			case 3: return new Function_DocumentationAssignment_1(parent, this, 3, inst);
			case 4: return new Function_B3FunctionAction_0(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
}

// returnType=TypeRef?
protected class Function_ReturnTypeAssignment_6 extends AssignmentToken  {
	
	public Function_ReturnTypeAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getReturnTypeAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("returnType",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("returnType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getReturnTypeTypeRefParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_FunctionKeyword_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// name=ID 
//    	 
// //   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
protected class Function_NameAssignment_7 extends AssignmentToken  {
	
	public Function_NameAssignment_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getNameAssignment_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_ReturnTypeAssignment_6(parent, this, 0, inst);
			case 1: return new Function_FunctionKeyword_5(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFunctionAccess().getNameIDTerminalRuleCall_7_0();
			return obj;
		}
		return null;
	}

}

// ("(" (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
// varArgs?="..." parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
// ParameterDeclaration)? ")")?
protected class Function_Group_8 extends GroupToken {
	
	public Function_Group_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_RightParenthesisKeyword_8_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class Function_LeftParenthesisKeyword_8_0 extends KeywordToken  {
	
	public Function_LeftParenthesisKeyword_8_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getLeftParenthesisKeyword_8_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_NameAssignment_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
// varArgs?="..." parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
// ParameterDeclaration)?
protected class Function_Alternatives_8_1 extends AlternativesToken {

	public Function_Alternatives_8_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFunctionAccess().getAlternatives_8_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_8_1_0(parent, this, 0, inst);
			case 1: return new Function_Group_8_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
// varArgs?="..." parameters+=ParameterDeclaration)?
protected class Function_Group_8_1_0 extends GroupToken {
	
	public Function_Group_8_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_8_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_8_1_0_2(parent, this, 0, inst);
			case 1: return new Function_Group_8_1_0_1(parent, this, 1, inst);
			case 2: return new Function_ParametersAssignment_8_1_0_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration
protected class Function_ParametersAssignment_8_1_0_0 extends AssignmentToken  {
	
	public Function_ParametersAssignment_8_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getParametersAssignment_8_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getParametersParameterDeclarationParserRuleCall_8_1_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_LeftParenthesisKeyword_8_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," parameters+=ParameterDeclaration)*
protected class Function_Group_8_1_0_1 extends GroupToken {
	
	public Function_Group_8_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_8_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_ParametersAssignment_8_1_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Function_CommaKeyword_8_1_0_1_0 extends KeywordToken  {
	
	public Function_CommaKeyword_8_1_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getCommaKeyword_8_1_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_8_1_0_1(parent, this, 0, inst);
			case 1: return new Function_ParametersAssignment_8_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration
protected class Function_ParametersAssignment_8_1_0_1_1 extends AssignmentToken  {
	
	public Function_ParametersAssignment_8_1_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getParametersAssignment_8_1_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getParametersParameterDeclarationParserRuleCall_8_1_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_CommaKeyword_8_1_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ("," varArgs?="..." parameters+=ParameterDeclaration)?
protected class Function_Group_8_1_0_2 extends GroupToken {
	
	public Function_Group_8_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_8_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_ParametersAssignment_8_1_0_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Function_CommaKeyword_8_1_0_2_0 extends KeywordToken  {
	
	public Function_CommaKeyword_8_1_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getCommaKeyword_8_1_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_8_1_0_1(parent, this, 0, inst);
			case 1: return new Function_ParametersAssignment_8_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..."
protected class Function_VarArgsAssignment_8_1_0_2_1 extends AssignmentToken  {
	
	public Function_VarArgsAssignment_8_1_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getVarArgsAssignment_8_1_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_CommaKeyword_8_1_0_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varArgs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varArgs");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFunctionAccess().getVarArgsFullStopFullStopFullStopKeyword_8_1_0_2_1_0();
			return obj;
		}
		return null;
	}

}

// parameters+=ParameterDeclaration
protected class Function_ParametersAssignment_8_1_0_2_2 extends AssignmentToken  {
	
	public Function_ParametersAssignment_8_1_0_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getParametersAssignment_8_1_0_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getParametersParameterDeclarationParserRuleCall_8_1_0_2_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_VarArgsAssignment_8_1_0_2_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// varArgs?="..." parameters+=ParameterDeclaration
protected class Function_Group_8_1_1 extends GroupToken {
	
	public Function_Group_8_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_8_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_ParametersAssignment_8_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..."
protected class Function_VarArgsAssignment_8_1_1_0 extends AssignmentToken  {
	
	public Function_VarArgsAssignment_8_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getVarArgsAssignment_8_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_LeftParenthesisKeyword_8_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varArgs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varArgs");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFunctionAccess().getVarArgsFullStopFullStopFullStopKeyword_8_1_1_0_0();
			return obj;
		}
		return null;
	}

}

// parameters+=ParameterDeclaration
protected class Function_ParametersAssignment_8_1_1_1 extends AssignmentToken  {
	
	public Function_ParametersAssignment_8_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getParametersAssignment_8_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getParametersParameterDeclarationParserRuleCall_8_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_VarArgsAssignment_8_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class Function_RightParenthesisKeyword_8_2 extends KeywordToken  {
	
	public Function_RightParenthesisKeyword_8_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getRightParenthesisKeyword_8_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Alternatives_8_1(parent, this, 0, inst);
			case 1: return new Function_LeftParenthesisKeyword_8_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// ("when" guard=GuardExpression)?
protected class Function_Group_9 extends GroupToken {
	
	public Function_Group_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_GuardAssignment_9_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "when"
protected class Function_WhenKeyword_9_0 extends KeywordToken  {
	
	public Function_WhenKeyword_9_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getWhenKeyword_9_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_8(parent, this, 0, inst);
			case 1: return new Function_NameAssignment_7(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// guard=GuardExpression
protected class Function_GuardAssignment_9_1 extends AssignmentToken  {
	
	public Function_GuardAssignment_9_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGuardAssignment_9_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GuardExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("guard",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("guard");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGuardExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getGuardGuardExpressionParserRuleCall_9_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_WhenKeyword_9_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ":" funcExpr=Expression ";"|funcExpr=BlockExpression
protected class Function_Alternatives_10 extends AlternativesToken {

	public Function_Alternatives_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFunctionAccess().getAlternatives_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_10_0(parent, this, 0, inst);
			case 1: return new Function_FuncExprAssignment_10_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":" funcExpr=Expression ";"
protected class Function_Group_10_0 extends GroupToken {
	
	public Function_Group_10_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_10_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_SemicolonKeyword_10_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Function_ColonKeyword_10_0_0 extends KeywordToken  {
	
	public Function_ColonKeyword_10_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getColonKeyword_10_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_9(parent, this, 0, inst);
			case 1: return new Function_Group_8(parent, this, 1, inst);
			case 2: return new Function_NameAssignment_7(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// funcExpr=Expression
protected class Function_FuncExprAssignment_10_0_1 extends AssignmentToken  {
	
	public Function_FuncExprAssignment_10_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getFuncExprAssignment_10_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("funcExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("funcExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getFuncExprExpressionParserRuleCall_10_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_ColonKeyword_10_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class Function_SemicolonKeyword_10_0_2 extends KeywordToken  {
	
	public Function_SemicolonKeyword_10_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getSemicolonKeyword_10_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_FuncExprAssignment_10_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// funcExpr=BlockExpression
protected class Function_FuncExprAssignment_10_1 extends AssignmentToken  {
	
	public Function_FuncExprAssignment_10_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getFuncExprAssignment_10_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("funcExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("funcExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getFuncExprBlockExpressionParserRuleCall_10_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_Group_9(parent, next, actIndex, consumed);
			case 1: return new Function_Group_8(parent, next, actIndex, consumed);
			case 2: return new Function_NameAssignment_7(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Function ****************/


/************ begin Rule GuardExpression ****************
 *
 * GuardExpression returns be::BGuardExpression:
 *   {be::BGuardExpression} (":" guardExpr=Expression ";")|guardExpr=BlockExpression; 
 * 	
 *         
 * 	                
 * 	
 * //TypeParamDeclaration 
 * //	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
 * //	;
 * 		
 * / * EXPRESSIONS * /
 *
 **/

// {be::BGuardExpression} (":" guardExpr=Expression ";")|guardExpr=BlockExpression 
// 	
//         
// 	                
// 	
// //TypeParamDeclaration 
// //	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
// //	;
// 		
// / * EXPRESSIONS * /
protected class GuardExpression_Alternatives extends AlternativesToken {

	public GuardExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GuardExpression_Group_0(parent, this, 0, inst);
			case 1: return new GuardExpression_GuardExprAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGuardExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BGuardExpression} (":" guardExpr=Expression ";")
protected class GuardExpression_Group_0 extends GroupToken {
	
	public GuardExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GuardExpression_Group_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BGuardExpression}
protected class GuardExpression_BGuardExpressionAction_0_0 extends ActionToken  {

	public GuardExpression_BGuardExpressionAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getBGuardExpressionAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getGuardExpressionAccess().getBGuardExpressionAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ":" guardExpr=Expression ";"
protected class GuardExpression_Group_0_1 extends GroupToken {
	
	public GuardExpression_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GuardExpression_SemicolonKeyword_0_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class GuardExpression_ColonKeyword_0_1_0 extends KeywordToken  {
	
	public GuardExpression_ColonKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getColonKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GuardExpression_BGuardExpressionAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// guardExpr=Expression
protected class GuardExpression_GuardExprAssignment_0_1_1 extends AssignmentToken  {
	
	public GuardExpression_GuardExprAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getGuardExprAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("guardExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("guardExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGuardExpressionAccess().getGuardExprExpressionParserRuleCall_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new GuardExpression_ColonKeyword_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class GuardExpression_SemicolonKeyword_0_1_2 extends KeywordToken  {
	
	public GuardExpression_SemicolonKeyword_0_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getSemicolonKeyword_0_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GuardExpression_GuardExprAssignment_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// guardExpr=BlockExpression
protected class GuardExpression_GuardExprAssignment_1 extends AssignmentToken  {
	
	public GuardExpression_GuardExprAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getGuardExprAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("guardExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("guardExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGuardExpressionAccess().getGuardExprBlockExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}


/************ end Rule GuardExpression ****************/




/************ begin Rule TopLevelExpression ****************
 *
 * TopLevelExpression returns be::BExpression:
 *   VarDeclaration|ValDeclaration|AssignmentExpression; 
 * 
 * // All expressions, including variable and value definitions. Note: order of rules is significant.
 *      
 * 	   
 * 	  
 * 	   
 * 	
 * 
 * // All expressions except variable and value definitions
 *
 **/

// VarDeclaration|ValDeclaration|AssignmentExpression 
// 
// // All expressions, including variable and value definitions. Note: order of rules is significant.
//      
// 	   
// 	  
// 	   
// 	
// 
// // All expressions except variable and value definitions
protected class TopLevelExpression_Alternatives extends AlternativesToken {

	public TopLevelExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTopLevelExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TopLevelExpression_VarDeclarationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TopLevelExpression_ValDeclarationParserRuleCall_1(parent, this, 1, inst);
			case 2: return new TopLevelExpression_AssignmentExpressionParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTopLevelExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VarDeclaration
protected class TopLevelExpression_VarDeclarationParserRuleCall_0 extends RuleCallToken {
	
	public TopLevelExpression_VarDeclarationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTopLevelExpressionAccess().getVarDeclarationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VarDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVarDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ValDeclaration
protected class TopLevelExpression_ValDeclarationParserRuleCall_1 extends RuleCallToken {
	
	public TopLevelExpression_ValDeclarationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTopLevelExpressionAccess().getValDeclarationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// AssignmentExpression
protected class TopLevelExpression_AssignmentExpressionParserRuleCall_2 extends RuleCallToken {
	
	public TopLevelExpression_AssignmentExpressionParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTopLevelExpressionAccess().getAssignmentExpressionParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignmentExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AssignmentExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TopLevelExpression ****************/


/************ begin Rule Expression ****************
 *
 * Expression returns be::BExpression:
 *   AssignmentExpression; 
 * 
 * // All expressions except variable and value definitions
 *
 **/

// AssignmentExpression
protected class Expression_AssignmentExpressionParserRuleCall extends RuleCallToken {
	
	public Expression_AssignmentExpressionParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAssignmentExpressionParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignmentExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AssignmentExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule Expression ****************/


/************ begin Rule AssignmentExpression ****************
 *
 * AssignmentExpression returns be::BExpression:
 *   CachedExpression ({be::BAssignmentExpression.leftExpr=current} functionName=
 *   AssignmentOperator rightExpr=AssignmentExpression)?;
 *
 **/

// CachedExpression ({be::BAssignmentExpression.leftExpr=current} functionName=
// AssignmentOperator rightExpr=AssignmentExpression)?
protected class AssignmentExpression_Group extends GroupToken {
	
	public AssignmentExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignmentExpression_Group_1(parent, this, 0, inst);
			case 1: return new AssignmentExpression_CachedExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// CachedExpression
protected class AssignmentExpression_CachedExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AssignmentExpression_CachedExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignmentExpressionAccess().getCachedExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CachedExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CachedExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCachedExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BAssignmentExpression.leftExpr=current} functionName=AssignmentOperator
// rightExpr=AssignmentExpression)?
protected class AssignmentExpression_Group_1 extends GroupToken {
	
	public AssignmentExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignmentExpression_RightExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BAssignmentExpression.leftExpr=current}
protected class AssignmentExpression_BAssignmentExpressionLeftExprAction_1_0 extends ActionToken  {

	public AssignmentExpression_BAssignmentExpressionLeftExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAssignmentExpressionAccess().getBAssignmentExpressionLeftExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignmentExpression_CachedExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentExpressionAccess().getBAssignmentExpressionLeftExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("leftExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("leftExpr")) return null;
		return getDescr((EObject) val);
	}
}

// functionName=AssignmentOperator
protected class AssignmentExpression_FunctionNameAssignment_1_1 extends AssignmentToken  {
	
	public AssignmentExpression_FunctionNameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentExpressionAccess().getFunctionNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignmentExpression_BAssignmentExpressionLeftExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getAssignmentExpressionAccess().getFunctionNameAssignmentOperatorParserRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// rightExpr=AssignmentExpression
protected class AssignmentExpression_RightExprAssignment_1_2 extends AssignmentToken  {
	
	public AssignmentExpression_RightExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentExpressionAccess().getRightExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignmentExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignmentExpressionAccess().getRightExprAssignmentExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AssignmentExpression_FunctionNameAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AssignmentExpression ****************/


/************ begin Rule VarDeclaration ****************
 *
 * VarDeclaration returns be::BExpression:
 *   {be::BDefValue} final?="final"? (("var"|type=TypeRef) name=ID) ("=" valueExpr=
 *   Expression)?;
 *
 **/

// {be::BDefValue} final?="final"? (("var"|type=TypeRef) name=ID) ("=" valueExpr=
// Expression)?
protected class VarDeclaration_Group extends GroupToken {
	
	public VarDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_Group_3(parent, this, 0, inst);
			case 1: return new VarDeclaration_Group_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVarDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BDefValue}
protected class VarDeclaration_BDefValueAction_0 extends ActionToken  {

	public VarDeclaration_BDefValueAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getBDefValueAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getVarDeclarationAccess().getBDefValueAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// final?="final"?
protected class VarDeclaration_FinalAssignment_1 extends AssignmentToken  {
	
	public VarDeclaration_FinalAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getFinalAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_BDefValueAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("final",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("final");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getVarDeclarationAccess().getFinalFinalKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// ("var"|type=TypeRef) name=ID
protected class VarDeclaration_Group_2 extends GroupToken {
	
	public VarDeclaration_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_NameAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "var"|type=TypeRef
protected class VarDeclaration_Alternatives_2_0 extends AlternativesToken {

	public VarDeclaration_Alternatives_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getAlternatives_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_VarKeyword_2_0_0(parent, this, 0, inst);
			case 1: return new VarDeclaration_TypeAssignment_2_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "var"
protected class VarDeclaration_VarKeyword_2_0_0 extends KeywordToken  {
	
	public VarDeclaration_VarKeyword_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getVarKeyword_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_FinalAssignment_1(parent, this, 0, inst);
			case 1: return new VarDeclaration_BDefValueAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class VarDeclaration_TypeAssignment_2_0_1 extends AssignmentToken  {
	
	public VarDeclaration_TypeAssignment_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getTypeAssignment_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVarDeclarationAccess().getTypeTypeRefParserRuleCall_2_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VarDeclaration_FinalAssignment_1(parent, next, actIndex, consumed);
			case 1: return new VarDeclaration_BDefValueAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// name=ID
protected class VarDeclaration_NameAssignment_2_1 extends AssignmentToken  {
	
	public VarDeclaration_NameAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getNameAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_Alternatives_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVarDeclarationAccess().getNameIDTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}


// ("=" valueExpr=Expression)?
protected class VarDeclaration_Group_3 extends GroupToken {
	
	public VarDeclaration_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_ValueExprAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class VarDeclaration_EqualsSignKeyword_3_0 extends KeywordToken  {
	
	public VarDeclaration_EqualsSignKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getEqualsSignKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VarDeclaration_Group_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// valueExpr=Expression
protected class VarDeclaration_ValueExprAssignment_3_1 extends AssignmentToken  {
	
	public VarDeclaration_ValueExprAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVarDeclarationAccess().getValueExprAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("valueExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("valueExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVarDeclarationAccess().getValueExprExpressionParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VarDeclaration_EqualsSignKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule VarDeclaration ****************/


/************ begin Rule ValDeclaration ****************
 *
 * ValDeclaration returns be::BExpression:
 *   {be::BDefValue} final?="final"? immutable?="val" type=TypeRef? name=ID "=" valueExpr=
 *   Expression; 
 * 
 *         
 * 	     
 * 	         
 * 	      
 * 	
 * 
 * // TODO: typereference is simplified to only the name of a java type - for model imports
 * // the model is imported with name == namespace, and types in the model are referenced after
 * // '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
 * // referenced as mymodel::mytype
 * // There is more work required to link a reference to such a type and it is therefore deferred
 * // until we are up on Xtext 0.8 with better scoping and linking.
 * // For now, this is just proof of concept.
 * //
 *
 **/

// {be::BDefValue} final?="final"? immutable?="val" type=TypeRef? name=ID "=" valueExpr=
// Expression
protected class ValDeclaration_Group extends GroupToken {
	
	public ValDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getValDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValDeclaration_ValueExprAssignment_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BDefValue}
protected class ValDeclaration_BDefValueAction_0 extends ActionToken  {

	public ValDeclaration_BDefValueAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getValDeclarationAccess().getBDefValueAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getValDeclarationAccess().getBDefValueAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// final?="final"?
protected class ValDeclaration_FinalAssignment_1 extends AssignmentToken  {
	
	public ValDeclaration_FinalAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getValDeclarationAccess().getFinalAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValDeclaration_BDefValueAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("final",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("final");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getValDeclarationAccess().getFinalFinalKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// immutable?="val"
protected class ValDeclaration_ImmutableAssignment_2 extends AssignmentToken  {
	
	public ValDeclaration_ImmutableAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getValDeclarationAccess().getImmutableAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValDeclaration_FinalAssignment_1(parent, this, 0, inst);
			case 1: return new ValDeclaration_BDefValueAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("immutable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("immutable");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getValDeclarationAccess().getImmutableValKeyword_2_0();
			return obj;
		}
		return null;
	}

}

// type=TypeRef?
protected class ValDeclaration_TypeAssignment_3 extends AssignmentToken  {
	
	public ValDeclaration_TypeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getValDeclarationAccess().getTypeAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getValDeclarationAccess().getTypeTypeRefParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ValDeclaration_ImmutableAssignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// name=ID
protected class ValDeclaration_NameAssignment_4 extends AssignmentToken  {
	
	public ValDeclaration_NameAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getValDeclarationAccess().getNameAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValDeclaration_TypeAssignment_3(parent, this, 0, inst);
			case 1: return new ValDeclaration_ImmutableAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getValDeclarationAccess().getNameIDTerminalRuleCall_4_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class ValDeclaration_EqualsSignKeyword_5 extends KeywordToken  {
	
	public ValDeclaration_EqualsSignKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getValDeclarationAccess().getEqualsSignKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValDeclaration_NameAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// valueExpr=Expression
protected class ValDeclaration_ValueExprAssignment_6 extends AssignmentToken  {
	
	public ValDeclaration_ValueExprAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getValDeclarationAccess().getValueExprAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("valueExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("valueExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getValDeclarationAccess().getValueExprExpressionParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ValDeclaration_EqualsSignKeyword_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ValDeclaration ****************/


/************ begin Rule TypeRef ****************
 *
 * TypeRef returns be::IType:
 *   ClosureTypeRef|SimpleTypeRef; 
 * 
 * // TODO: typereference is simplified to only the name of a java type - for model imports
 * // the model is imported with name == namespace, and types in the model are referenced after
 * // '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
 * // referenced as mymodel::mytype
 * // There is more work required to link a reference to such a type and it is therefore deferred
 * // until we are up on Xtext 0.8 with better scoping and linking.
 * // For now, this is just proof of concept.
 * //
 *
 **/

// ClosureTypeRef|SimpleTypeRef 
// 
// // TODO: typereference is simplified to only the name of a java type - for model imports
// // the model is imported with name == namespace, and types in the model are referenced after
// // '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
// // referenced as mymodel::mytype
// // There is more work required to link a reference to such a type and it is therefore deferred
// // until we are up on Xtext 0.8 with better scoping and linking.
// // For now, this is just proof of concept.
// //
protected class TypeRef_Alternatives extends AlternativesToken {

	public TypeRef_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_ClosureTypeRefParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypeRef_SimpleTypeRefParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ClosureTypeRef
protected class TypeRef_ClosureTypeRefParserRuleCall_0 extends RuleCallToken {
	
	public TypeRef_ClosureTypeRefParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getClosureTypeRefParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ClosureTypeRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getClosureTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SimpleTypeRef
protected class TypeRef_SimpleTypeRefParserRuleCall_1 extends RuleCallToken {
	
	public TypeRef_SimpleTypeRefParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getSimpleTypeRefParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SimpleTypeRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSimpleTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TypeRef ****************/


/************ begin Rule SimpleTypeRef ****************
 *
 * SimpleTypeRef returns be::IType:
 *   {be::B3ParameterizedType} rawType=[be::B3JavaImport] ("<" actualArgumentsList+=[be
 *   ::B3JavaImport] ("," actualArgumentsList+=[be::B3JavaImport])* ">")?;  
 * 	
 *          
 * 	     
 * 		                  
 * //		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
 * 	 
 * 	
 * 
 * // ClosureTypeRef declares parameters and return type	
 * // TODO: use TypeRef instead of direct reference to imported class
 *
 **/

// {be::B3ParameterizedType} rawType=[be::B3JavaImport] ("<" actualArgumentsList+=[be
// ::B3JavaImport] ("," actualArgumentsList+=[be::B3JavaImport])* ">")?    
// 	     
// 		                  
// //		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
protected class SimpleTypeRef_Group extends GroupToken {
	
	public SimpleTypeRef_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_2(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_RawTypeAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSimpleTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::B3ParameterizedType}
protected class SimpleTypeRef_B3ParameterizedTypeAction_0 extends ActionToken  {

	public SimpleTypeRef_B3ParameterizedTypeAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getB3ParameterizedTypeAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSimpleTypeRefAccess().getB3ParameterizedTypeAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// rawType=[be::B3JavaImport]
protected class SimpleTypeRef_RawTypeAssignment_1 extends AssignmentToken  {
	
	public SimpleTypeRef_RawTypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getRawTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_B3ParameterizedTypeAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rawType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rawType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleTypeRefAccess().getRawTypeB3JavaImportCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSimpleTypeRefAccess().getRawTypeB3JavaImportCrossReference_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("<" actualArgumentsList+=[be::B3JavaImport] ("," actualArgumentsList+=[be::
// B3JavaImport])* ">")?
protected class SimpleTypeRef_Group_2 extends GroupToken {
	
	public SimpleTypeRef_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_GreaterThanSignKeyword_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class SimpleTypeRef_LessThanSignKeyword_2_0 extends KeywordToken  {
	
	public SimpleTypeRef_LessThanSignKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getLessThanSignKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_RawTypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// actualArgumentsList+=[be::B3JavaImport]
protected class SimpleTypeRef_ActualArgumentsListAssignment_2_1 extends AssignmentToken  {
	
	public SimpleTypeRef_ActualArgumentsListAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getActualArgumentsListAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_LessThanSignKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("actualArgumentsList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("actualArgumentsList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleTypeRefAccess().getActualArgumentsListB3JavaImportCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSimpleTypeRefAccess().getActualArgumentsListB3JavaImportCrossReference_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," actualArgumentsList+=[be::B3JavaImport])*
protected class SimpleTypeRef_Group_2_2 extends GroupToken {
	
	public SimpleTypeRef_Group_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_ActualArgumentsListAssignment_2_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class SimpleTypeRef_CommaKeyword_2_2_0 extends KeywordToken  {
	
	public SimpleTypeRef_CommaKeyword_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getCommaKeyword_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_2_2(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_ActualArgumentsListAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// actualArgumentsList+=[be::B3JavaImport]
protected class SimpleTypeRef_ActualArgumentsListAssignment_2_2_1 extends AssignmentToken  {
	
	public SimpleTypeRef_ActualArgumentsListAssignment_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getActualArgumentsListAssignment_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_CommaKeyword_2_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("actualArgumentsList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("actualArgumentsList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleTypeRefAccess().getActualArgumentsListB3JavaImportCrossReference_2_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSimpleTypeRefAccess().getActualArgumentsListB3JavaImportCrossReference_2_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


// ">"
protected class SimpleTypeRef_GreaterThanSignKeyword_2_3 extends KeywordToken  {
	
	public SimpleTypeRef_GreaterThanSignKeyword_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGreaterThanSignKeyword_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_2_2(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_ActualArgumentsListAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule SimpleTypeRef ****************/


/************ begin Rule ClosureTypeRef ****************
 *
 * ClosureTypeRef returns be::IType:
 *   {be::B3FunctionType} ("(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[
 *   be::B3JavaImport])* ("," varArgs?="..." parameterTypes+=[be::B3JavaImport])?|
 *   varArgs?="..." parameterTypes+=[be::B3JavaImport])? ")" "=>" returnType=[be::
 *   B3JavaImport]); 
 * 	
 * 
 * // ClosureTypeRef declares parameters and return type	
 * // TODO: use TypeRef instead of direct reference to imported class
 *          
 * 	
 * 		                     
 * 			                
 * 		 	                    
 * 		 
 * 	              
 * 	
 * 
 * // TODO: TypeParam's and Wildcard refs currently unused. Support should be added
 * //
 *
 **/

// {be::B3FunctionType} ("(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[
// be::B3JavaImport])* ("," varArgs?="..." parameterTypes+=[be::B3JavaImport])?|
// varArgs?="..." parameterTypes+=[be::B3JavaImport])? ")" "=>" returnType=[be::
// B3JavaImport])
protected class ClosureTypeRef_Group extends GroupToken {
	
	public ClosureTypeRef_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getClosureTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::B3FunctionType}
protected class ClosureTypeRef_B3FunctionTypeAction_0 extends ActionToken  {

	public ClosureTypeRef_B3FunctionTypeAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getB3FunctionTypeAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getClosureTypeRefAccess().getB3FunctionTypeAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[be::B3JavaImport])* (
// "," varArgs?="..." parameterTypes+=[be::B3JavaImport])?|varArgs?="..."
// parameterTypes+=[be::B3JavaImport])? ")" "=>" returnType=[be::B3JavaImport]
protected class ClosureTypeRef_Group_1 extends GroupToken {
	
	public ClosureTypeRef_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_ReturnTypeAssignment_1_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class ClosureTypeRef_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public ClosureTypeRef_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_B3FunctionTypeAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[be::B3JavaImport])* (","
// varArgs?="..." parameterTypes+=[be::B3JavaImport])?|varArgs?="..." parameterTypes
// +=[be::B3JavaImport])?
protected class ClosureTypeRef_Alternatives_1_1 extends AlternativesToken {

	public ClosureTypeRef_Alternatives_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getAlternatives_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_Group_1_1_0(parent, this, 0, inst);
			case 1: return new ClosureTypeRef_Group_1_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[be::B3JavaImport])* (","
// varArgs?="..." parameterTypes+=[be::B3JavaImport])?
protected class ClosureTypeRef_Group_1_1_0 extends GroupToken {
	
	public ClosureTypeRef_Group_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getGroup_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_Group_1_1_0_2(parent, this, 0, inst);
			case 1: return new ClosureTypeRef_Group_1_1_0_1(parent, this, 1, inst);
			case 2: return new ClosureTypeRef_ParameterTypesAssignment_1_1_0_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// parameterTypes+=[be::B3JavaImport]
protected class ClosureTypeRef_ParameterTypesAssignment_1_1_0_0 extends AssignmentToken  {
	
	public ClosureTypeRef_ParameterTypesAssignment_1_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getParameterTypesAssignment_1_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_LeftParenthesisKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameterTypes",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameterTypes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClosureTypeRefAccess().getParameterTypesB3JavaImportCrossReference_1_1_0_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getClosureTypeRefAccess().getParameterTypesB3JavaImportCrossReference_1_1_0_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," parameterTypes+=[be::B3JavaImport])*
protected class ClosureTypeRef_Group_1_1_0_1 extends GroupToken {
	
	public ClosureTypeRef_Group_1_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getGroup_1_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_ParameterTypesAssignment_1_1_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ClosureTypeRef_CommaKeyword_1_1_0_1_0 extends KeywordToken  {
	
	public ClosureTypeRef_CommaKeyword_1_1_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getCommaKeyword_1_1_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_Group_1_1_0_1(parent, this, 0, inst);
			case 1: return new ClosureTypeRef_ParameterTypesAssignment_1_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameterTypes+=[be::B3JavaImport]
protected class ClosureTypeRef_ParameterTypesAssignment_1_1_0_1_1 extends AssignmentToken  {
	
	public ClosureTypeRef_ParameterTypesAssignment_1_1_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getParameterTypesAssignment_1_1_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_CommaKeyword_1_1_0_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameterTypes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameterTypes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClosureTypeRefAccess().getParameterTypesB3JavaImportCrossReference_1_1_0_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getClosureTypeRefAccess().getParameterTypesB3JavaImportCrossReference_1_1_0_1_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


// ("," varArgs?="..." parameterTypes+=[be::B3JavaImport])?
protected class ClosureTypeRef_Group_1_1_0_2 extends GroupToken {
	
	public ClosureTypeRef_Group_1_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getGroup_1_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_ParameterTypesAssignment_1_1_0_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ClosureTypeRef_CommaKeyword_1_1_0_2_0 extends KeywordToken  {
	
	public ClosureTypeRef_CommaKeyword_1_1_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getCommaKeyword_1_1_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_Group_1_1_0_1(parent, this, 0, inst);
			case 1: return new ClosureTypeRef_ParameterTypesAssignment_1_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..."
protected class ClosureTypeRef_VarArgsAssignment_1_1_0_2_1 extends AssignmentToken  {
	
	public ClosureTypeRef_VarArgsAssignment_1_1_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getVarArgsAssignment_1_1_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_CommaKeyword_1_1_0_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varArgs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varArgs");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getClosureTypeRefAccess().getVarArgsFullStopFullStopFullStopKeyword_1_1_0_2_1_0();
			return obj;
		}
		return null;
	}

}

// parameterTypes+=[be::B3JavaImport]
protected class ClosureTypeRef_ParameterTypesAssignment_1_1_0_2_2 extends AssignmentToken  {
	
	public ClosureTypeRef_ParameterTypesAssignment_1_1_0_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getParameterTypesAssignment_1_1_0_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_VarArgsAssignment_1_1_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameterTypes",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameterTypes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClosureTypeRefAccess().getParameterTypesB3JavaImportCrossReference_1_1_0_2_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getClosureTypeRefAccess().getParameterTypesB3JavaImportCrossReference_1_1_0_2_2_0(); 
				return obj;
			}
		}
		return null;
	}

}



// varArgs?="..." parameterTypes+=[be::B3JavaImport]
protected class ClosureTypeRef_Group_1_1_1 extends GroupToken {
	
	public ClosureTypeRef_Group_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getGroup_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_ParameterTypesAssignment_1_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..."
protected class ClosureTypeRef_VarArgsAssignment_1_1_1_0 extends AssignmentToken  {
	
	public ClosureTypeRef_VarArgsAssignment_1_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getVarArgsAssignment_1_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_LeftParenthesisKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varArgs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varArgs");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getClosureTypeRefAccess().getVarArgsFullStopFullStopFullStopKeyword_1_1_1_0_0();
			return obj;
		}
		return null;
	}

}

// parameterTypes+=[be::B3JavaImport]
protected class ClosureTypeRef_ParameterTypesAssignment_1_1_1_1 extends AssignmentToken  {
	
	public ClosureTypeRef_ParameterTypesAssignment_1_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getParameterTypesAssignment_1_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_VarArgsAssignment_1_1_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameterTypes",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameterTypes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClosureTypeRefAccess().getParameterTypesB3JavaImportCrossReference_1_1_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getClosureTypeRefAccess().getParameterTypesB3JavaImportCrossReference_1_1_1_1_0(); 
				return obj;
			}
		}
		return null;
	}

}



// ")"
protected class ClosureTypeRef_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public ClosureTypeRef_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_Alternatives_1_1(parent, this, 0, inst);
			case 1: return new ClosureTypeRef_LeftParenthesisKeyword_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "=>"
protected class ClosureTypeRef_EqualsSignGreaterThanSignKeyword_1_3 extends KeywordToken  {
	
	public ClosureTypeRef_EqualsSignGreaterThanSignKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getEqualsSignGreaterThanSignKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// returnType=[be::B3JavaImport]
protected class ClosureTypeRef_ReturnTypeAssignment_1_4 extends AssignmentToken  {
	
	public ClosureTypeRef_ReturnTypeAssignment_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureTypeRefAccess().getReturnTypeAssignment_1_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureTypeRef_EqualsSignGreaterThanSignKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("returnType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("returnType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClosureTypeRefAccess().getReturnTypeB3JavaImportCrossReference_1_4_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getClosureTypeRefAccess().getReturnTypeB3JavaImportCrossReference_1_4_0(); 
				return obj;
			}
		}
		return null;
	}

}



/************ end Rule ClosureTypeRef ****************/


/************ begin Rule TypeParam ****************
 *
 * TypeParam returns be::IType:
 *   TypeRefParam|WildcardRefParam; 
 * 
 * // TODO: TypeParam's and Wildcard refs currently unused. Support should be added
 * //
 *
 **/

// TypeRefParam|WildcardRefParam 
// 
// // TODO: TypeParam's and Wildcard refs currently unused. Support should be added
// //
protected class TypeParam_Alternatives extends AlternativesToken {

	public TypeParam_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParam_TypeRefParamParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypeParam_WildcardRefParamParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeParamRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TypeRefParam
protected class TypeParam_TypeRefParamParserRuleCall_0 extends RuleCallToken {
	
	public TypeParam_TypeRefParamParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getTypeRefParamParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRefParam_TypeRefParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypeRefParam_TypeRefParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeRefParamRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// WildcardRefParam
protected class TypeParam_WildcardRefParamParserRuleCall_1 extends RuleCallToken {
	
	public TypeParam_WildcardRefParamParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getWildcardRefParamParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(WildcardRefParam_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getWildcardRefParamRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TypeParam ****************/


/************ begin Rule TypeRefParam ****************
 *
 * TypeRefParam returns be::IType:
 *   TypeRef;
 *
 **/

// TypeRef
protected class TypeRefParam_TypeRefParserRuleCall extends RuleCallToken {
	
	public TypeRefParam_TypeRefParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeRefParamAccess().getTypeRefParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeRefParamRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypeRef_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule TypeRefParam ****************/


/************ begin Rule WildcardRefParam ****************
 *
 * WildcardRefParam returns be::IType:
 *   {be::B3WildcardType} "?" ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=
 *   TypeRef)*|"super" lowerBoundsList+=TypeRef)?;
 *
 **/

// {be::B3WildcardType} "?" ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=
// TypeRef)*|"super" lowerBoundsList+=TypeRef)?
protected class WildcardRefParam_Group extends GroupToken {
	
	public WildcardRefParam_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_Alternatives_2(parent, this, 0, inst);
			case 1: return new WildcardRefParam_QuestionMarkKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWildcardRefParamRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::B3WildcardType}
protected class WildcardRefParam_B3WildcardTypeAction_0 extends ActionToken  {

	public WildcardRefParam_B3WildcardTypeAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getB3WildcardTypeAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getWildcardRefParamAccess().getB3WildcardTypeAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "?"
protected class WildcardRefParam_QuestionMarkKeyword_1 extends KeywordToken  {
	
	public WildcardRefParam_QuestionMarkKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getQuestionMarkKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_B3WildcardTypeAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=TypeRef)*|"super"
// lowerBoundsList+=TypeRef)?
protected class WildcardRefParam_Alternatives_2 extends AlternativesToken {

	public WildcardRefParam_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_Group_2_0(parent, this, 0, inst);
			case 1: return new WildcardRefParam_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends" upperBoundsList+=TypeRef ("," upperBoundsList+=TypeRef)*
protected class WildcardRefParam_Group_2_0 extends GroupToken {
	
	public WildcardRefParam_Group_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getGroup_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_Group_2_0_2(parent, this, 0, inst);
			case 1: return new WildcardRefParam_UpperBoundsListAssignment_2_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class WildcardRefParam_ExtendsKeyword_2_0_0 extends KeywordToken  {
	
	public WildcardRefParam_ExtendsKeyword_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getExtendsKeyword_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_QuestionMarkKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// upperBoundsList+=TypeRef
protected class WildcardRefParam_UpperBoundsListAssignment_2_0_1 extends AssignmentToken  {
	
	public WildcardRefParam_UpperBoundsListAssignment_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getUpperBoundsListAssignment_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("upperBoundsList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("upperBoundsList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWildcardRefParamAccess().getUpperBoundsListTypeRefParserRuleCall_2_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WildcardRefParam_ExtendsKeyword_2_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," upperBoundsList+=TypeRef)*
protected class WildcardRefParam_Group_2_0_2 extends GroupToken {
	
	public WildcardRefParam_Group_2_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getGroup_2_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_UpperBoundsListAssignment_2_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class WildcardRefParam_CommaKeyword_2_0_2_0 extends KeywordToken  {
	
	public WildcardRefParam_CommaKeyword_2_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getCommaKeyword_2_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_Group_2_0_2(parent, this, 0, inst);
			case 1: return new WildcardRefParam_UpperBoundsListAssignment_2_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// upperBoundsList+=TypeRef
protected class WildcardRefParam_UpperBoundsListAssignment_2_0_2_1 extends AssignmentToken  {
	
	public WildcardRefParam_UpperBoundsListAssignment_2_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getUpperBoundsListAssignment_2_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("upperBoundsList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("upperBoundsList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWildcardRefParamAccess().getUpperBoundsListTypeRefParserRuleCall_2_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WildcardRefParam_CommaKeyword_2_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "super" lowerBoundsList+=TypeRef
protected class WildcardRefParam_Group_2_1 extends GroupToken {
	
	public WildcardRefParam_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_LowerBoundsListAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "super"
protected class WildcardRefParam_SuperKeyword_2_1_0 extends KeywordToken  {
	
	public WildcardRefParam_SuperKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getSuperKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardRefParam_QuestionMarkKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// lowerBoundsList+=TypeRef
protected class WildcardRefParam_LowerBoundsListAssignment_2_1_1 extends AssignmentToken  {
	
	public WildcardRefParam_LowerBoundsListAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWildcardRefParamAccess().getLowerBoundsListAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("lowerBoundsList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("lowerBoundsList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWildcardRefParamAccess().getLowerBoundsListTypeRefParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WildcardRefParam_SuperKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule WildcardRefParam ****************/


/************ begin Rule CachedExpression ****************
 *
 * CachedExpression returns be::BExpression:
 *   {be::BCachedExpression} "cached" expr=OrExpression|OrExpression;
 *
 **/

// {be::BCachedExpression} "cached" expr=OrExpression|OrExpression
protected class CachedExpression_Alternatives extends AlternativesToken {

	public CachedExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCachedExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CachedExpression_Group_0(parent, this, 0, inst);
			case 1: return new CachedExpression_OrExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCachedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BCachedExpression} "cached" expr=OrExpression
protected class CachedExpression_Group_0 extends GroupToken {
	
	public CachedExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCachedExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CachedExpression_ExprAssignment_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BCachedExpression}
protected class CachedExpression_BCachedExpressionAction_0_0 extends ActionToken  {

	public CachedExpression_BCachedExpressionAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCachedExpressionAccess().getBCachedExpressionAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCachedExpressionAccess().getBCachedExpressionAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "cached"
protected class CachedExpression_CachedKeyword_0_1 extends KeywordToken  {
	
	public CachedExpression_CachedKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCachedExpressionAccess().getCachedKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CachedExpression_BCachedExpressionAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expr=OrExpression
protected class CachedExpression_ExprAssignment_0_2 extends AssignmentToken  {
	
	public CachedExpression_ExprAssignment_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCachedExpressionAccess().getExprAssignment_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCachedExpressionAccess().getExprOrExpressionParserRuleCall_0_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CachedExpression_CachedKeyword_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// OrExpression
protected class CachedExpression_OrExpressionParserRuleCall_1 extends RuleCallToken {
	
	public CachedExpression_OrExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCachedExpressionAccess().getOrExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule CachedExpression ****************/


/************ begin Rule OrExpression ****************
 *
 * OrExpression returns be::BExpression:
 *   AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*;
 *
 **/

// AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*
protected class OrExpression_Group extends GroupToken {
	
	public OrExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(parent, this, 0, inst);
			case 1: return new OrExpression_AndExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndExpression
protected class OrExpression_AndExpressionParserRuleCall_0 extends RuleCallToken {
	
	public OrExpression_AndExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getAndExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*
protected class OrExpression_Group_1 extends GroupToken {
	
	public OrExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_RightExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BOrExpression.leftExpr=current}
protected class OrExpression_BOrExpressionLeftExprAction_1_0 extends ActionToken  {

	public OrExpression_BOrExpressionLeftExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getBOrExpressionLeftExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(parent, this, 0, inst);
			case 1: return new OrExpression_AndExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOrExpressionAccess().getBOrExpressionLeftExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("leftExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("leftExpr")) return null;
		return getDescr((EObject) val);
	}
}

// "||"
protected class OrExpression_VerticalLineVerticalLineKeyword_1_1 extends KeywordToken  {
	
	public OrExpression_VerticalLineVerticalLineKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getVerticalLineVerticalLineKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_BOrExpressionLeftExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rightExpr=AndExpression
protected class OrExpression_RightExprAssignment_1_2 extends AssignmentToken  {
	
	public OrExpression_RightExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getRightExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrExpressionAccess().getRightExprAndExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrExpression_VerticalLineVerticalLineKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrExpression ****************/


/************ begin Rule AndExpression ****************
 *
 * AndExpression returns be::BExpression:
 *   RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
 *   RelationalExpression)*; 
 * 	
 *       
 * 	      
 * 	
 * 
 * // DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
 * // use the backend for some other language with a different grammar).
 * // BitwiseExpression returns be::BExpression :
 * // RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
 *
 **/

// RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
// RelationalExpression)*
protected class AndExpression_Group extends GroupToken {
	
	public AndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_RelationalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// RelationalExpression
protected class AndExpression_RelationalExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndExpression_RelationalExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getRelationalExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RelationalExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BAndExpression.leftExpr=current} "&&" rightExpr=RelationalExpression)*
protected class AndExpression_Group_1 extends GroupToken {
	
	public AndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_RightExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BAndExpression.leftExpr=current}
protected class AndExpression_BAndExpressionLeftExprAction_1_0 extends ActionToken  {

	public AndExpression_BAndExpressionLeftExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getBAndExpressionLeftExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_RelationalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionAccess().getBAndExpressionLeftExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("leftExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("leftExpr")) return null;
		return getDescr((EObject) val);
	}
}

// "&&"
protected class AndExpression_AmpersandAmpersandKeyword_1_1 extends KeywordToken  {
	
	public AndExpression_AmpersandAmpersandKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getAmpersandAmpersandKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_BAndExpressionLeftExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rightExpr=RelationalExpression
protected class AndExpression_RightExprAssignment_1_2 extends AssignmentToken  {
	
	public AndExpression_RightExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getRightExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndExpressionAccess().getRightExprRelationalExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndExpression_AmpersandAmpersandKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndExpression ****************/


/************ begin Rule RelationalExpression ****************
 *
 * RelationalExpression returns be::BExpression:
 *   InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
 *   RelationalOperator rightExpr=InstanceOfExpression)*; 
 * 
 * // DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
 * // use the backend for some other language with a different grammar).
 * // BitwiseExpression returns be::BExpression :
 * // RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
 *
 **/

// InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
// RelationalOperator rightExpr=InstanceOfExpression)*
protected class RelationalExpression_Group extends GroupToken {
	
	public RelationalExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_InstanceOfExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// InstanceOfExpression
protected class RelationalExpression_InstanceOfExpressionParserRuleCall_0 extends RuleCallToken {
	
	public RelationalExpression_InstanceOfExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstanceOfExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(InstanceOfExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getInstanceOfExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BBinaryOpExpression.leftExpr=current} functionName=RelationalOperator
// rightExpr=InstanceOfExpression)*
protected class RelationalExpression_Group_1 extends GroupToken {
	
	public RelationalExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_RightExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BBinaryOpExpression.leftExpr=current}
protected class RelationalExpression_BBinaryOpExpressionLeftExprAction_1_0 extends ActionToken  {

	public RelationalExpression_BBinaryOpExpressionLeftExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_InstanceOfExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("leftExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("leftExpr")) return null;
		return getDescr((EObject) val);
	}
}

// functionName=RelationalOperator
protected class RelationalExpression_FunctionNameAssignment_1_1 extends AssignmentToken  {
	
	public RelationalExpression_FunctionNameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getFunctionNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_BBinaryOpExpressionLeftExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRelationalExpressionAccess().getFunctionNameRelationalOperatorParserRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// rightExpr=InstanceOfExpression
protected class RelationalExpression_RightExprAssignment_1_2 extends AssignmentToken  {
	
	public RelationalExpression_RightExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getRightExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstanceOfExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstanceOfExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getRightExprInstanceOfExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_FunctionNameAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule RelationalExpression ****************/


/************ begin Rule InstanceOfExpression ****************
 *
 * InstanceOfExpression returns be::BExpression:
 *   AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
 *   "instanceof" rightExpr=LiteralType)*; 
 * 
 *       
 * 	        
 * 	
 * 
 * // DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
 * // use the backend for some other language with a different grammar).
 * // ShiftExpression returns be::BExpression:
 * // AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
 *
 **/

// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
// "instanceof" rightExpr=LiteralType)*
protected class InstanceOfExpression_Group extends GroupToken {
	
	public InstanceOfExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInstanceOfExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstanceOfExpression_Group_1(parent, this, 0, inst);
			case 1: return new InstanceOfExpression_AdditiveExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInstanceOfExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AdditiveExpression
protected class InstanceOfExpression_AdditiveExpressionParserRuleCall_0 extends RuleCallToken {
	
	public InstanceOfExpression_AdditiveExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstanceOfExpressionAccess().getAdditiveExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AdditiveExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BBinaryOpExpression.leftExpr=current} functionName="instanceof" rightExpr=
// LiteralType)*
protected class InstanceOfExpression_Group_1 extends GroupToken {
	
	public InstanceOfExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInstanceOfExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstanceOfExpression_RightExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BBinaryOpExpression.leftExpr=current}
protected class InstanceOfExpression_BBinaryOpExpressionLeftExprAction_1_0 extends ActionToken  {

	public InstanceOfExpression_BBinaryOpExpressionLeftExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getInstanceOfExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstanceOfExpression_Group_1(parent, this, 0, inst);
			case 1: return new InstanceOfExpression_AdditiveExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getInstanceOfExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("leftExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("leftExpr")) return null;
		return getDescr((EObject) val);
	}
}

// functionName="instanceof"
protected class InstanceOfExpression_FunctionNameAssignment_1_1 extends AssignmentToken  {
	
	public InstanceOfExpression_FunctionNameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInstanceOfExpressionAccess().getFunctionNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InstanceOfExpression_BBinaryOpExpressionLeftExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("instanceof".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getInstanceOfExpressionAccess().getFunctionNameInstanceofKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// rightExpr=LiteralType
protected class InstanceOfExpression_RightExprAssignment_1_2 extends AssignmentToken  {
	
	public InstanceOfExpression_RightExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInstanceOfExpressionAccess().getRightExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralType_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLiteralTypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInstanceOfExpressionAccess().getRightExprLiteralTypeParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InstanceOfExpression_FunctionNameAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule InstanceOfExpression ****************/


/************ begin Rule AdditiveExpression ****************
 *
 * AdditiveExpression returns be::BExpression:
 *   MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
 *   ( "+" | "-" ) rightExpr=MultiplicativeExpression)*; 
 * 
 * // DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
 * // use the backend for some other language with a different grammar).
 * // ShiftExpression returns be::BExpression:
 * // AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
 *
 **/

// MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
// ( "+" | "-" ) rightExpr=MultiplicativeExpression)*
protected class AdditiveExpression_Group extends GroupToken {
	
	public AdditiveExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// MultiplicativeExpression
protected class AdditiveExpression_MultiplicativeExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getMultiplicativeExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(MultiplicativeExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BBinaryOpExpression.leftExpr=current} functionName=( "+" | "-" ) rightExpr=
// MultiplicativeExpression)*
protected class AdditiveExpression_Group_1 extends GroupToken {
	
	public AdditiveExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_RightExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BBinaryOpExpression.leftExpr=current}
protected class AdditiveExpression_BBinaryOpExpressionLeftExprAction_1_0 extends ActionToken  {

	public AdditiveExpression_BBinaryOpExpressionLeftExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("leftExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("leftExpr")) return null;
		return getDescr((EObject) val);
	}
}

// functionName=( "+" | "-" )
protected class AdditiveExpression_FunctionNameAssignment_1_1 extends AssignmentToken  {
	
	public AdditiveExpression_FunctionNameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getFunctionNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_BBinaryOpExpressionLeftExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditiveExpressionAccess().getFunctionNamePlusSignKeyword_1_1_0_0();
			return obj;
		}
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditiveExpressionAccess().getFunctionNameHyphenMinusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// rightExpr=MultiplicativeExpression
protected class AdditiveExpression_RightExprAssignment_1_2 extends AssignmentToken  {
	
	public AdditiveExpression_RightExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getRightExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getRightExprMultiplicativeExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AdditiveExpression_FunctionNameAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AdditiveExpression ****************/


/************ begin Rule MultiplicativeExpression ****************
 *
 * MultiplicativeExpression returns be::BExpression:
 *   SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" |
 *   "%" ) rightExpr=SetExpression)*;
 *
 **/

// SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" |
// "%" ) rightExpr=SetExpression)*
protected class MultiplicativeExpression_Group extends GroupToken {
	
	public MultiplicativeExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeExpression_SetExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// SetExpression
protected class MultiplicativeExpression_SetExpressionParserRuleCall_0 extends RuleCallToken {
	
	public MultiplicativeExpression_SetExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getSetExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SetExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSetExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" | "%" ) rightExpr=
// SetExpression)*
protected class MultiplicativeExpression_Group_1 extends GroupToken {
	
	public MultiplicativeExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_RightExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BBinaryOpExpression.leftExpr=current}
protected class MultiplicativeExpression_BBinaryOpExpressionLeftExprAction_1_0 extends ActionToken  {

	public MultiplicativeExpression_BBinaryOpExpressionLeftExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeExpression_SetExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("leftExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("leftExpr")) return null;
		return getDescr((EObject) val);
	}
}

// functionName=( "*" | "/" | "%" )
protected class MultiplicativeExpression_FunctionNameAssignment_1_1 extends AssignmentToken  {
	
	public MultiplicativeExpression_FunctionNameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getFunctionNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_BBinaryOpExpressionLeftExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeExpressionAccess().getFunctionNameAsteriskKeyword_1_1_0_0();
			return obj;
		}
		if("/".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeExpressionAccess().getFunctionNameSolidusKeyword_1_1_0_1();
			return obj;
		}
		if("%".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeExpressionAccess().getFunctionNamePercentSignKeyword_1_1_0_2();
			return obj;
		}
		return null;
	}

}

// rightExpr=SetExpression
protected class MultiplicativeExpression_RightExprAssignment_1_2 extends AssignmentToken  {
	
	public MultiplicativeExpression_RightExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getRightExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSetExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplicativeExpressionAccess().getRightExprSetExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MultiplicativeExpression_FunctionNameAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule MultiplicativeExpression ****************/


/************ begin Rule SetExpression ****************
 *
 * SetExpression returns be::BExpression:
 *   UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
 *   ".." rightExpr=UnaryOrInfixExpression)*;
 *
 **/

// UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
// ".." rightExpr=UnaryOrInfixExpression)*
protected class SetExpression_Group extends GroupToken {
	
	public SetExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSetExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetExpression_Group_1(parent, this, 0, inst);
			case 1: return new SetExpression_UnaryOrInfixExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSetExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// UnaryOrInfixExpression
protected class SetExpression_UnaryOrInfixExpressionParserRuleCall_0 extends RuleCallToken {
	
	public SetExpression_UnaryOrInfixExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getSetExpressionAccess().getUnaryOrInfixExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOrInfixExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnaryOrInfixExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnaryOrInfixExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BBinaryOpExpression.leftExpr=current} functionName=".." rightExpr=
// UnaryOrInfixExpression)*
protected class SetExpression_Group_1 extends GroupToken {
	
	public SetExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSetExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetExpression_RightExprAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BBinaryOpExpression.leftExpr=current}
protected class SetExpression_BBinaryOpExpressionLeftExprAction_1_0 extends ActionToken  {

	public SetExpression_BBinaryOpExpressionLeftExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSetExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetExpression_Group_1(parent, this, 0, inst);
			case 1: return new SetExpression_UnaryOrInfixExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSetExpressionAccess().getBBinaryOpExpressionLeftExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("leftExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("leftExpr")) return null;
		return getDescr((EObject) val);
	}
}

// functionName=".."
protected class SetExpression_FunctionNameAssignment_1_1 extends AssignmentToken  {
	
	public SetExpression_FunctionNameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSetExpressionAccess().getFunctionNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetExpression_BBinaryOpExpressionLeftExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("..".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getSetExpressionAccess().getFunctionNameFullStopFullStopKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// rightExpr=UnaryOrInfixExpression
protected class SetExpression_RightExprAssignment_1_2 extends AssignmentToken  {
	
	public SetExpression_RightExprAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSetExpressionAccess().getRightExprAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOrInfixExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rightExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryOrInfixExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSetExpressionAccess().getRightExprUnaryOrInfixExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SetExpression_FunctionNameAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule SetExpression ****************/


/************ begin Rule UnaryOrInfixExpression ****************
 *
 * UnaryOrInfixExpression returns be::BExpression:
 *   PostopExpression|UnaryExpression|PreopExpression; 
 * 
 *     
 * 	   
 * 	  
 * 	  
 * 	 
 * 	
 * // DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
 * // use the backend for some other language with a different grammar).
 * // Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
 * // UnaryExpression returns be::BExpression:
 * //	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
 *
 **/

// PostopExpression|UnaryExpression|PreopExpression 
// 
//     
// 	   
// 	  
// 	  
// 	 
// 	
// // DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
// // use the backend for some other language with a different grammar).
// // Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
// // UnaryExpression returns be::BExpression:
// //	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
protected class UnaryOrInfixExpression_Alternatives extends AlternativesToken {

	public UnaryOrInfixExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getUnaryOrInfixExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOrInfixExpression_PostopExpressionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new UnaryOrInfixExpression_UnaryExpressionParserRuleCall_1(parent, this, 1, inst);
			case 2: return new UnaryOrInfixExpression_PreopExpressionParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnaryOrInfixExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// PostopExpression
protected class UnaryOrInfixExpression_PostopExpressionParserRuleCall_0 extends RuleCallToken {
	
	public UnaryOrInfixExpression_PostopExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryOrInfixExpressionAccess().getPostopExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PostopExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PostopExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPostopExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// UnaryExpression
protected class UnaryOrInfixExpression_UnaryExpressionParserRuleCall_1 extends RuleCallToken {
	
	public UnaryOrInfixExpression_UnaryExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryOrInfixExpressionAccess().getUnaryExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnaryExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// PreopExpression
protected class UnaryOrInfixExpression_PreopExpressionParserRuleCall_2 extends RuleCallToken {
	
	public UnaryOrInfixExpression_PreopExpressionParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryOrInfixExpressionAccess().getPreopExpressionParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PreopExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PreopExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPreopExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule UnaryOrInfixExpression ****************/


/************ begin Rule UnaryExpression ****************
 *
 * UnaryExpression returns be::BExpression:
 *   {be::BUnaryOpExpression} functionName=( "!" | "-" ) expr=InfixExpression;  
 * 	
 * // DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
 * // use the backend for some other language with a different grammar).
 * // Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
 * // UnaryExpression returns be::BExpression:
 * //	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
 *
 **/

// {be::BUnaryOpExpression} functionName=( "!" | "-" ) expr=InfixExpression
protected class UnaryExpression_Group extends GroupToken {
	
	public UnaryExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_ExprAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BUnaryOpExpression}
protected class UnaryExpression_BUnaryOpExpressionAction_0 extends ActionToken  {

	public UnaryExpression_BUnaryOpExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getBUnaryOpExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnaryExpressionAccess().getBUnaryOpExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// functionName=( "!" | "-" )
protected class UnaryExpression_FunctionNameAssignment_1 extends AssignmentToken  {
	
	public UnaryExpression_FunctionNameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getFunctionNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_BUnaryOpExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("!".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryExpressionAccess().getFunctionNameExclamationMarkKeyword_1_0_0();
			return obj;
		}
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryExpressionAccess().getFunctionNameHyphenMinusKeyword_1_0_1();
			return obj;
		}
		return null;
	}

}

// expr=InfixExpression
protected class UnaryExpression_ExprAssignment_2 extends AssignmentToken  {
	
	public UnaryExpression_ExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInfixExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryExpressionAccess().getExprInfixExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryExpression_FunctionNameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule UnaryExpression ****************/


/************ begin Rule PreopExpression ****************
 *
 * PreopExpression returns be::BExpression:
 *   {be::BUnaryPreOpExpression} functionName=( "++" | "--" ) expr=InfixExpression;
 *
 **/

// {be::BUnaryPreOpExpression} functionName=( "++" | "--" ) expr=InfixExpression
protected class PreopExpression_Group extends GroupToken {
	
	public PreopExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPreopExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PreopExpression_ExprAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPreopExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BUnaryPreOpExpression}
protected class PreopExpression_BUnaryPreOpExpressionAction_0 extends ActionToken  {

	public PreopExpression_BUnaryPreOpExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPreopExpressionAccess().getBUnaryPreOpExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPreopExpressionAccess().getBUnaryPreOpExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// functionName=( "++" | "--" )
protected class PreopExpression_FunctionNameAssignment_1 extends AssignmentToken  {
	
	public PreopExpression_FunctionNameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPreopExpressionAccess().getFunctionNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PreopExpression_BUnaryPreOpExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("++".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPreopExpressionAccess().getFunctionNamePlusSignPlusSignKeyword_1_0_0();
			return obj;
		}
		if("--".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPreopExpressionAccess().getFunctionNameHyphenMinusHyphenMinusKeyword_1_0_1();
			return obj;
		}
		return null;
	}

}

// expr=InfixExpression
protected class PreopExpression_ExprAssignment_2 extends AssignmentToken  {
	
	public PreopExpression_ExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPreopExpressionAccess().getExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInfixExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPreopExpressionAccess().getExprInfixExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PreopExpression_FunctionNameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule PreopExpression ****************/


/************ begin Rule PostopExpression ****************
 *
 * PostopExpression returns be::BExpression:
 *   InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++"
 *   ))?;
 *
 **/

// InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++"
// ))?
protected class PostopExpression_Group extends GroupToken {
	
	public PostopExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPostopExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PostopExpression_Group_1(parent, this, 0, inst);
			case 1: return new PostopExpression_InfixExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPostopExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// InfixExpression
protected class PostopExpression_InfixExpressionParserRuleCall_0 extends RuleCallToken {
	
	public PostopExpression_InfixExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPostopExpressionAccess().getInfixExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(InfixExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getInfixExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++" ))?
protected class PostopExpression_Group_1 extends GroupToken {
	
	public PostopExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPostopExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PostopExpression_FunctionNameAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BUnaryPostOpExpression.expr=current}
protected class PostopExpression_BUnaryPostOpExpressionExprAction_1_0 extends ActionToken  {

	public PostopExpression_BUnaryPostOpExpressionExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPostopExpressionAccess().getBUnaryPostOpExpressionExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PostopExpression_InfixExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPostopExpressionAccess().getBUnaryPostOpExpressionExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("expr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("expr")) return null;
		return getDescr((EObject) val);
	}
}

// functionName=( "--" | "++" )
protected class PostopExpression_FunctionNameAssignment_1_1 extends AssignmentToken  {
	
	public PostopExpression_FunctionNameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPostopExpressionAccess().getFunctionNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PostopExpression_BUnaryPostOpExpressionExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("--".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPostopExpressionAccess().getFunctionNameHyphenMinusHyphenMinusKeyword_1_1_0_0();
			return obj;
		}
		if("++".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPostopExpressionAccess().getFunctionNamePlusSignPlusSignKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}



/************ end Rule PostopExpression ****************/


/************ begin Rule InfixExpression ****************
 *
 * InfixExpression returns be::BExpression:
 *   CallExpression ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=
 *   ParameterList? ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|
 *   {be::BFeatureExpression.objExpr=current} "." featureName=ID)*;
 *
 **/

// CallExpression ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=
// ParameterList? ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|
// {be::BFeatureExpression.objExpr=current} "." featureName=ID)*
protected class InfixExpression_Group extends GroupToken {
	
	public InfixExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_Alternatives_1(parent, this, 0, inst);
			case 1: return new InfixExpression_CallExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInfixExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// CallExpression
protected class InfixExpression_CallExpressionParserRuleCall_0 extends RuleCallToken {
	
	public InfixExpression_CallExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getCallExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CallExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCallExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=ParameterList?
// ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|{be::
// BFeatureExpression.objExpr=current} "." featureName=ID)*
protected class InfixExpression_Alternatives_1 extends AlternativesToken {

	public InfixExpression_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_Group_1_0(parent, this, 0, inst);
			case 1: return new InfixExpression_Group_1_1(parent, this, 1, inst);
			case 2: return new InfixExpression_Group_1_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// {be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=ParameterList?
// ")"
protected class InfixExpression_Group_1_0 extends GroupToken {
	
	public InfixExpression_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_RightParenthesisKeyword_1_0_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BCallExpression.funcExpr=current}
protected class InfixExpression_BCallExpressionFuncExprAction_1_0_0 extends ActionToken  {

	public InfixExpression_BCallExpressionFuncExprAction_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getBCallExpressionFuncExprAction_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_Alternatives_1(parent, this, 0, inst);
			case 1: return new InfixExpression_CallExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getInfixExpressionAccess().getBCallExpressionFuncExprAction_1_0_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("funcExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("funcExpr")) return null;
		return getDescr((EObject) val);
	}
}

// "."
protected class InfixExpression_FullStopKeyword_1_0_1 extends KeywordToken  {
	
	public InfixExpression_FullStopKeyword_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getFullStopKeyword_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_BCallExpressionFuncExprAction_1_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class InfixExpression_NameAssignment_1_0_2 extends AssignmentToken  {
	
	public InfixExpression_NameAssignment_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getNameAssignment_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_FullStopKeyword_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getInfixExpressionAccess().getNameIDTerminalRuleCall_1_0_2_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class InfixExpression_LeftParenthesisKeyword_1_0_3 extends KeywordToken  {
	
	public InfixExpression_LeftParenthesisKeyword_1_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getLeftParenthesisKeyword_1_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_NameAssignment_1_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parameterList=ParameterList?
protected class InfixExpression_ParameterListAssignment_1_0_4 extends AssignmentToken  {
	
	public InfixExpression_ParameterListAssignment_1_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getParameterListAssignment_1_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameterList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameterList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInfixExpressionAccess().getParameterListParameterListParserRuleCall_1_0_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InfixExpression_LeftParenthesisKeyword_1_0_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class InfixExpression_RightParenthesisKeyword_1_0_5 extends KeywordToken  {
	
	public InfixExpression_RightParenthesisKeyword_1_0_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getRightParenthesisKeyword_1_0_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_ParameterListAssignment_1_0_4(parent, this, 0, inst);
			case 1: return new InfixExpression_LeftParenthesisKeyword_1_0_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// {be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"
protected class InfixExpression_Group_1_1 extends GroupToken {
	
	public InfixExpression_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_RightSquareBracketKeyword_1_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BAtExpression.objExpr=current}
protected class InfixExpression_BAtExpressionObjExprAction_1_1_0 extends ActionToken  {

	public InfixExpression_BAtExpressionObjExprAction_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getBAtExpressionObjExprAction_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_Alternatives_1(parent, this, 0, inst);
			case 1: return new InfixExpression_CallExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getInfixExpressionAccess().getBAtExpressionObjExprAction_1_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("objExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("objExpr")) return null;
		return getDescr((EObject) val);
	}
}

// "["
protected class InfixExpression_LeftSquareBracketKeyword_1_1_1 extends KeywordToken  {
	
	public InfixExpression_LeftSquareBracketKeyword_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getLeftSquareBracketKeyword_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_BAtExpressionObjExprAction_1_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// indexExpr=Expression
protected class InfixExpression_IndexExprAssignment_1_1_2 extends AssignmentToken  {
	
	public InfixExpression_IndexExprAssignment_1_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getIndexExprAssignment_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("indexExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("indexExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInfixExpressionAccess().getIndexExprExpressionParserRuleCall_1_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InfixExpression_LeftSquareBracketKeyword_1_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class InfixExpression_RightSquareBracketKeyword_1_1_3 extends KeywordToken  {
	
	public InfixExpression_RightSquareBracketKeyword_1_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getRightSquareBracketKeyword_1_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_IndexExprAssignment_1_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// {be::BFeatureExpression.objExpr=current} "." featureName=ID
protected class InfixExpression_Group_1_2 extends GroupToken {
	
	public InfixExpression_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_FeatureNameAssignment_1_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BFeatureExpression.objExpr=current}
protected class InfixExpression_BFeatureExpressionObjExprAction_1_2_0 extends ActionToken  {

	public InfixExpression_BFeatureExpressionObjExprAction_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getBFeatureExpressionObjExprAction_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_Alternatives_1(parent, this, 0, inst);
			case 1: return new InfixExpression_CallExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getInfixExpressionAccess().getBFeatureExpressionObjExprAction_1_2_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("objExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("objExpr")) return null;
		return getDescr((EObject) val);
	}
}

// "."
protected class InfixExpression_FullStopKeyword_1_2_1 extends KeywordToken  {
	
	public InfixExpression_FullStopKeyword_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getFullStopKeyword_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_BFeatureExpressionObjExprAction_1_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// featureName=ID
protected class InfixExpression_FeatureNameAssignment_1_2_2 extends AssignmentToken  {
	
	public InfixExpression_FeatureNameAssignment_1_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInfixExpressionAccess().getFeatureNameAssignment_1_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InfixExpression_FullStopKeyword_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("featureName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("featureName");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getInfixExpressionAccess().getFeatureNameIDTerminalRuleCall_1_2_2_0();
			return obj;
		}
		return null;
	}

}




/************ end Rule InfixExpression ****************/


/************ begin Rule CallExpression ****************
 *
 * CallExpression returns be::BExpression:
 *   PrimaryExpression ({be::BCallExpression.funcExpr=current} "(" parameterList=
 *   ParameterList? ")")*;
 *
 **/

// PrimaryExpression ({be::BCallExpression.funcExpr=current} "(" parameterList=
// ParameterList? ")")*
protected class CallExpression_Group extends GroupToken {
	
	public CallExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpression_Group_1(parent, this, 0, inst);
			case 1: return new CallExpression_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCallExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// PrimaryExpression
protected class CallExpression_PrimaryExpressionParserRuleCall_0 extends RuleCallToken {
	
	public CallExpression_PrimaryExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCallExpressionAccess().getPrimaryExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimaryExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({be::BCallExpression.funcExpr=current} "(" parameterList=ParameterList? ")")*
protected class CallExpression_Group_1 extends GroupToken {
	
	public CallExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpression_RightParenthesisKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BCallExpression.funcExpr=current}
protected class CallExpression_BCallExpressionFuncExprAction_1_0 extends ActionToken  {

	public CallExpression_BCallExpressionFuncExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCallExpressionAccess().getBCallExpressionFuncExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpression_Group_1(parent, this, 0, inst);
			case 1: return new CallExpression_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCallExpressionAccess().getBCallExpressionFuncExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("funcExpr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("funcExpr")) return null;
		return getDescr((EObject) val);
	}
}

// "("
protected class CallExpression_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public CallExpression_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallExpressionAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpression_BCallExpressionFuncExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parameterList=ParameterList?
protected class CallExpression_ParameterListAssignment_1_2 extends AssignmentToken  {
	
	public CallExpression_ParameterListAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallExpressionAccess().getParameterListAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameterList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameterList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCallExpressionAccess().getParameterListParameterListParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CallExpression_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class CallExpression_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public CallExpression_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallExpressionAccess().getRightParenthesisKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpression_ParameterListAssignment_1_2(parent, this, 0, inst);
			case 1: return new CallExpression_LeftParenthesisKeyword_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule CallExpression ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression returns be::BExpression:
 *   FeatureCall|ConstructorCallExpression|VariableValue|Literal|PropertyValue|
 *   KeywordVariables|ParanthesizedExpression|IfExpression|BlockExpression|
 *   SwitchExpression|ThrowExpression|TryCatchExpression|WildcardExpression; 
 * 		
 *     
 * 	  
 * 	  
 * 	  
 * 	   
 * 	  
 * 	  
 * 	  
 * 	  
 * 	  
 * 	  
 * 	  
 * 	  
 * 	  
 * //	| WithExpression
 * 	 
 * 	
 * //WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
 * //WithClauseExpression returns Expression : {WithClauseExpression} 
 * //	withclause=WithClause expr = BlockExpression 
 * //	;
 * //WithContextExpression returns Expresion : {WithContextExpression } 
 * //	"with" "context" context = Expression expr = BlockExpression
 * //	;
 *
 **/

// FeatureCall|ConstructorCallExpression|VariableValue|Literal|PropertyValue|
// KeywordVariables|ParanthesizedExpression|IfExpression|BlockExpression|
// SwitchExpression|ThrowExpression|TryCatchExpression|WildcardExpression 
// 		
//     
// 	  
// 	  
// 	  
// 	   
// 	  
// 	  
// 	  
// 	  
// 	  
// 	  
// 	  
// 	  
// 	  
// //	| WithExpression
// 	 
// 	
// //WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
// //WithClauseExpression returns Expression : {WithClauseExpression} 
// //	withclause=WithClause expr = BlockExpression 
// //	;
// //WithContextExpression returns Expresion : {WithContextExpression } 
// //	"with" "context" context = Expression expr = BlockExpression
// //	;
protected class PrimaryExpression_Alternatives extends AlternativesToken {

	public PrimaryExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_FeatureCallParserRuleCall_0(parent, this, 0, inst);
			case 1: return new PrimaryExpression_ConstructorCallExpressionParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PrimaryExpression_VariableValueParserRuleCall_2(parent, this, 2, inst);
			case 3: return new PrimaryExpression_LiteralParserRuleCall_3(parent, this, 3, inst);
			case 4: return new PrimaryExpression_PropertyValueParserRuleCall_4(parent, this, 4, inst);
			case 5: return new PrimaryExpression_KeywordVariablesParserRuleCall_5(parent, this, 5, inst);
			case 6: return new PrimaryExpression_ParanthesizedExpressionParserRuleCall_6(parent, this, 6, inst);
			case 7: return new PrimaryExpression_IfExpressionParserRuleCall_7(parent, this, 7, inst);
			case 8: return new PrimaryExpression_BlockExpressionParserRuleCall_8(parent, this, 8, inst);
			case 9: return new PrimaryExpression_SwitchExpressionParserRuleCall_9(parent, this, 9, inst);
			case 10: return new PrimaryExpression_ThrowExpressionParserRuleCall_10(parent, this, 10, inst);
			case 11: return new PrimaryExpression_TryCatchExpressionParserRuleCall_11(parent, this, 11, inst);
			case 12: return new PrimaryExpression_WildcardExpressionParserRuleCall_12(parent, this, 12, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// FeatureCall
protected class PrimaryExpression_FeatureCallParserRuleCall_0 extends RuleCallToken {
	
	public PrimaryExpression_FeatureCallParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getFeatureCallParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_OperationCallParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FeatureCall_OperationCallParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFeatureCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ConstructorCallExpression
protected class PrimaryExpression_ConstructorCallExpressionParserRuleCall_1 extends RuleCallToken {
	
	public PrimaryExpression_ConstructorCallExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getConstructorCallExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ConstructorCallExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConstructorCallExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VariableValue
protected class PrimaryExpression_VariableValueParserRuleCall_2 extends RuleCallToken {
	
	public PrimaryExpression_VariableValueParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getVariableValueParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableValue_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableValue_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableValueRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Literal
protected class PrimaryExpression_LiteralParserRuleCall_3 extends RuleCallToken {
	
	public PrimaryExpression_LiteralParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getLiteralParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Literal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Literal_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// PropertyValue
protected class PrimaryExpression_PropertyValueParserRuleCall_4 extends RuleCallToken {
	
	public PrimaryExpression_PropertyValueParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getPropertyValueParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValue_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PropertyValue_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPropertyValueRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// KeywordVariables
protected class PrimaryExpression_KeywordVariablesParserRuleCall_5 extends RuleCallToken {
	
	public PrimaryExpression_KeywordVariablesParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getKeywordVariablesParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new KeywordVariables_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(KeywordVariables_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordVariablesRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ParanthesizedExpression
protected class PrimaryExpression_ParanthesizedExpressionParserRuleCall_6 extends RuleCallToken {
	
	public PrimaryExpression_ParanthesizedExpressionParserRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getParanthesizedExpressionParserRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesizedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParanthesizedExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParanthesizedExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// IfExpression
protected class PrimaryExpression_IfExpressionParserRuleCall_7 extends RuleCallToken {
	
	public PrimaryExpression_IfExpressionParserRuleCall_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getIfExpressionParserRuleCall_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IfExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIfExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BlockExpression
protected class PrimaryExpression_BlockExpressionParserRuleCall_8 extends RuleCallToken {
	
	public PrimaryExpression_BlockExpressionParserRuleCall_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBlockExpressionParserRuleCall_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BlockExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SwitchExpression
protected class PrimaryExpression_SwitchExpressionParserRuleCall_9 extends RuleCallToken {
	
	public PrimaryExpression_SwitchExpressionParserRuleCall_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getSwitchExpressionParserRuleCall_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SwitchExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSwitchExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ThrowExpression
protected class PrimaryExpression_ThrowExpressionParserRuleCall_10 extends RuleCallToken {
	
	public PrimaryExpression_ThrowExpressionParserRuleCall_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getThrowExpressionParserRuleCall_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ThrowExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ThrowExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getThrowExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// TryCatchExpression
protected class PrimaryExpression_TryCatchExpressionParserRuleCall_11 extends RuleCallToken {
	
	public PrimaryExpression_TryCatchExpressionParserRuleCall_11(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getTryCatchExpressionParserRuleCall_11();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TryCatchExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TryCatchExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTryCatchExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// WildcardExpression   
// //	| WithExpression
protected class PrimaryExpression_WildcardExpressionParserRuleCall_12 extends RuleCallToken {
	
	public PrimaryExpression_WildcardExpressionParserRuleCall_12(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getWildcardExpressionParserRuleCall_12();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(WildcardExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getWildcardExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule PrimaryExpression ****************/


/************ begin Rule WildcardExpression ****************
 *
 * WildcardExpression returns be::BExpression:
 *   {be::BLiteralAny} "_"; 
 * 	
 * //WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
 * //WithClauseExpression returns Expression : {WithClauseExpression} 
 * //	withclause=WithClause expr = BlockExpression 
 * //	;
 * //WithContextExpression returns Expresion : {WithContextExpression } 
 * //	"with" "context" context = Expression expr = BlockExpression
 * //	;
 *
 **/

// {be::BLiteralAny} "_"
protected class WildcardExpression_Group extends GroupToken {
	
	public WildcardExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardExpression__Keyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWildcardExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralAny}
protected class WildcardExpression_BLiteralAnyAction_0 extends ActionToken  {

	public WildcardExpression_BLiteralAnyAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getWildcardExpressionAccess().getBLiteralAnyAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getWildcardExpressionAccess().getBLiteralAnyAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "_"
protected class WildcardExpression__Keyword_1 extends KeywordToken  {
	
	public WildcardExpression__Keyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardExpressionAccess().get_Keyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardExpression_BLiteralAnyAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule WildcardExpression ****************/


/************ begin Rule ThrowExpression ****************
 *
 * ThrowExpression returns be::BExpression:
 *   {be::BThrowExpression} "throw" expr=Expression;
 *
 **/

// {be::BThrowExpression} "throw" expr=Expression
protected class ThrowExpression_Group extends GroupToken {
	
	public ThrowExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getThrowExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ThrowExpression_ExprAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getThrowExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BThrowExpression}
protected class ThrowExpression_BThrowExpressionAction_0 extends ActionToken  {

	public ThrowExpression_BThrowExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getThrowExpressionAccess().getBThrowExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getThrowExpressionAccess().getBThrowExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "throw"
protected class ThrowExpression_ThrowKeyword_1 extends KeywordToken  {
	
	public ThrowExpression_ThrowKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getThrowExpressionAccess().getThrowKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ThrowExpression_BThrowExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expr=Expression
protected class ThrowExpression_ExprAssignment_2 extends AssignmentToken  {
	
	public ThrowExpression_ExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getThrowExpressionAccess().getExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getThrowExpressionAccess().getExprExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ThrowExpression_ThrowKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ThrowExpression ****************/


/************ begin Rule TryCatchExpression ****************
 *
 * TryCatchExpression returns be::BExpression:
 *   {be::BTryExpression} "try" tryExpr=Expression catchBlocks+=CatchBlock* ("finally"
 *   finallyExpr=Expression)? "endtry";
 *
 **/

// {be::BTryExpression} "try" tryExpr=Expression catchBlocks+=CatchBlock* ("finally"
// finallyExpr=Expression)? "endtry"
protected class TryCatchExpression_Group extends GroupToken {
	
	public TryCatchExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TryCatchExpression_EndtryKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTryCatchExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BTryExpression}
protected class TryCatchExpression_BTryExpressionAction_0 extends ActionToken  {

	public TryCatchExpression_BTryExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getBTryExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getTryCatchExpressionAccess().getBTryExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "try"
protected class TryCatchExpression_TryKeyword_1 extends KeywordToken  {
	
	public TryCatchExpression_TryKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getTryKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TryCatchExpression_BTryExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// tryExpr=Expression
protected class TryCatchExpression_TryExprAssignment_2 extends AssignmentToken  {
	
	public TryCatchExpression_TryExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getTryExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("tryExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("tryExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTryCatchExpressionAccess().getTryExprExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TryCatchExpression_TryKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// catchBlocks+=CatchBlock*
protected class TryCatchExpression_CatchBlocksAssignment_3 extends AssignmentToken  {
	
	public TryCatchExpression_CatchBlocksAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getCatchBlocksAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CatchBlock_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("catchBlocks",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("catchBlocks");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCatchBlockRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTryCatchExpressionAccess().getCatchBlocksCatchBlockParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TryCatchExpression_CatchBlocksAssignment_3(parent, next, actIndex, consumed);
			case 1: return new TryCatchExpression_TryExprAssignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("finally" finallyExpr=Expression)?
protected class TryCatchExpression_Group_4 extends GroupToken {
	
	public TryCatchExpression_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TryCatchExpression_FinallyExprAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "finally"
protected class TryCatchExpression_FinallyKeyword_4_0 extends KeywordToken  {
	
	public TryCatchExpression_FinallyKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getFinallyKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TryCatchExpression_CatchBlocksAssignment_3(parent, this, 0, inst);
			case 1: return new TryCatchExpression_TryExprAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// finallyExpr=Expression
protected class TryCatchExpression_FinallyExprAssignment_4_1 extends AssignmentToken  {
	
	public TryCatchExpression_FinallyExprAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getFinallyExprAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("finallyExpr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("finallyExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTryCatchExpressionAccess().getFinallyExprExpressionParserRuleCall_4_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TryCatchExpression_FinallyKeyword_4_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "endtry"
protected class TryCatchExpression_EndtryKeyword_5 extends KeywordToken  {
	
	public TryCatchExpression_EndtryKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTryCatchExpressionAccess().getEndtryKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TryCatchExpression_Group_4(parent, this, 0, inst);
			case 1: return new TryCatchExpression_CatchBlocksAssignment_3(parent, this, 1, inst);
			case 2: return new TryCatchExpression_TryExprAssignment_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule TryCatchExpression ****************/


/************ begin Rule CatchBlock ****************
 *
 * CatchBlock returns be::BCatch:
 *   {be::BCatch} "catch" exceptionType=TypeRef varname=ID ":" catchExpr=Expression;
 *
 **/

// {be::BCatch} "catch" exceptionType=TypeRef varname=ID ":" catchExpr=Expression
protected class CatchBlock_Group extends GroupToken {
	
	public CatchBlock_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCatchBlockAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CatchBlock_CatchExprAssignment_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCatchBlockRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BCatch}
protected class CatchBlock_BCatchAction_0 extends ActionToken  {

	public CatchBlock_BCatchAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCatchBlockAccess().getBCatchAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCatchBlockAccess().getBCatchAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "catch"
protected class CatchBlock_CatchKeyword_1 extends KeywordToken  {
	
	public CatchBlock_CatchKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCatchBlockAccess().getCatchKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CatchBlock_BCatchAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// exceptionType=TypeRef
protected class CatchBlock_ExceptionTypeAssignment_2 extends AssignmentToken  {
	
	public CatchBlock_ExceptionTypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCatchBlockAccess().getExceptionTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("exceptionType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("exceptionType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCatchBlockAccess().getExceptionTypeTypeRefParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CatchBlock_CatchKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// varname=ID
protected class CatchBlock_VarnameAssignment_3 extends AssignmentToken  {
	
	public CatchBlock_VarnameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCatchBlockAccess().getVarnameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CatchBlock_ExceptionTypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varname",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varname");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getCatchBlockAccess().getVarnameIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class CatchBlock_ColonKeyword_4 extends KeywordToken  {
	
	public CatchBlock_ColonKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCatchBlockAccess().getColonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CatchBlock_VarnameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// catchExpr=Expression
protected class CatchBlock_CatchExprAssignment_5 extends AssignmentToken  {
	
	public CatchBlock_CatchExprAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCatchBlockAccess().getCatchExprAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("catchExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("catchExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCatchBlockAccess().getCatchExprExpressionParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CatchBlock_ColonKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule CatchBlock ****************/


/************ begin Rule SwitchExpression ****************
 *
 * SwitchExpression returns be::BExpression:
 *   {be::BSwitchExpression} "switch" switchExpression=Expression? caseList+=Case+
 *   "endswitch";
 *
 **/

// {be::BSwitchExpression} "switch" switchExpression=Expression? caseList+=Case+
// "endswitch"
protected class SwitchExpression_Group extends GroupToken {
	
	public SwitchExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_EndswitchKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSwitchExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BSwitchExpression}
protected class SwitchExpression_BSwitchExpressionAction_0 extends ActionToken  {

	public SwitchExpression_BSwitchExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getBSwitchExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSwitchExpressionAccess().getBSwitchExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "switch"
protected class SwitchExpression_SwitchKeyword_1 extends KeywordToken  {
	
	public SwitchExpression_SwitchKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getSwitchKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_BSwitchExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// switchExpression=Expression?
protected class SwitchExpression_SwitchExpressionAssignment_2 extends AssignmentToken  {
	
	public SwitchExpression_SwitchExpressionAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getSwitchExpressionAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("switchExpression",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("switchExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSwitchExpressionAccess().getSwitchExpressionExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SwitchExpression_SwitchKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// caseList+=Case+
protected class SwitchExpression_CaseListAssignment_3 extends AssignmentToken  {
	
	public SwitchExpression_CaseListAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getCaseListAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Case_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("caseList",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("caseList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCaseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSwitchExpressionAccess().getCaseListCaseParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SwitchExpression_CaseListAssignment_3(parent, next, actIndex, consumed);
			case 1: return new SwitchExpression_SwitchExpressionAssignment_2(parent, next, actIndex, consumed);
			case 2: return new SwitchExpression_SwitchKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "endswitch"
protected class SwitchExpression_EndswitchKeyword_4 extends KeywordToken  {
	
	public SwitchExpression_EndswitchKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getEndswitchKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_CaseListAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule SwitchExpression ****************/


/************ begin Rule Case ****************
 *
 * Case returns be::BCase:
 *   {be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression;
 *
 **/

// {be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression
protected class Case_Group extends GroupToken {
	
	public Case_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCaseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Case_ThenExprAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCaseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BCase}
protected class Case_BCaseAction_0 extends ActionToken  {

	public Case_BCaseAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCaseAccess().getBCaseAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCaseAccess().getBCaseAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "case"
protected class Case_CaseKeyword_1 extends KeywordToken  {
	
	public Case_CaseKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCaseAccess().getCaseKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Case_BCaseAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// conditionExpr=Expression
protected class Case_ConditionExprAssignment_2 extends AssignmentToken  {
	
	public Case_ConditionExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseAccess().getConditionExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("conditionExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("conditionExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCaseAccess().getConditionExprExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Case_CaseKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ":"
protected class Case_ColonKeyword_3 extends KeywordToken  {
	
	public Case_ColonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCaseAccess().getColonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Case_ConditionExprAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// thenExpr=Expression
protected class Case_ThenExprAssignment_4 extends AssignmentToken  {
	
	public Case_ThenExprAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseAccess().getThenExprAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("thenExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("thenExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCaseAccess().getThenExprExpressionParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Case_ColonKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Case ****************/


/************ begin Rule BlockExpression ****************
 *
 * BlockExpression returns be::BExpression:
 *   {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}";
 *
 **/

// {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"
protected class BlockExpression_Group extends GroupToken {
	
	public BlockExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_RightCurlyBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BChainedExpression}
protected class BlockExpression_BChainedExpressionAction_0 extends ActionToken  {

	public BlockExpression_BChainedExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getBChainedExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionAccess().getBChainedExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "{"
protected class BlockExpression_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public BlockExpression_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getLeftCurlyBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_BChainedExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (expressions+=TopLevelExpression ";")*
protected class BlockExpression_Group_2 extends GroupToken {
	
	public BlockExpression_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_SemicolonKeyword_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=TopLevelExpression
protected class BlockExpression_ExpressionsAssignment_2_0 extends AssignmentToken  {
	
	public BlockExpression_ExpressionsAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getExpressionsAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TopLevelExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTopLevelExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBlockExpressionAccess().getExpressionsTopLevelExpressionParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BlockExpression_Group_2(parent, next, actIndex, consumed);
			case 1: return new BlockExpression_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BlockExpression_SemicolonKeyword_2_1 extends KeywordToken  {
	
	public BlockExpression_SemicolonKeyword_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getSemicolonKeyword_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_ExpressionsAssignment_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class BlockExpression_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public BlockExpression_RightCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getRightCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group_2(parent, this, 0, inst);
			case 1: return new BlockExpression_LeftCurlyBracketKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule BlockExpression ****************/


/************ begin Rule IfExpression ****************
 *
 * IfExpression returns be::BExpression:
 *   {be::BIfExpression} "if" conditionExpr=Expression "then" thenExpr=Expression (
 *   elseExpr=ElseIfExpression|"else" elseExpr=Expression)? "endif";
 *
 **/

// {be::BIfExpression} "if" conditionExpr=Expression "then" thenExpr=Expression (
// elseExpr=ElseIfExpression|"else" elseExpr=Expression)? "endif"
protected class IfExpression_Group extends GroupToken {
	
	public IfExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_EndifKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIfExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BIfExpression}
protected class IfExpression_BIfExpressionAction_0 extends ActionToken  {

	public IfExpression_BIfExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getBIfExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getIfExpressionAccess().getBIfExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "if"
protected class IfExpression_IfKeyword_1 extends KeywordToken  {
	
	public IfExpression_IfKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getIfKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_BIfExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// conditionExpr=Expression
protected class IfExpression_ConditionExprAssignment_2 extends AssignmentToken  {
	
	public IfExpression_ConditionExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getConditionExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("conditionExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("conditionExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getConditionExprExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_IfKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "then"
protected class IfExpression_ThenKeyword_3 extends KeywordToken  {
	
	public IfExpression_ThenKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getThenKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_ConditionExprAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// thenExpr=Expression
protected class IfExpression_ThenExprAssignment_4 extends AssignmentToken  {
	
	public IfExpression_ThenExprAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getThenExprAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("thenExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("thenExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getThenExprExpressionParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_ThenKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
protected class IfExpression_Alternatives_5 extends AlternativesToken {

	public IfExpression_Alternatives_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getAlternatives_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_ElseExprAssignment_5_0(parent, this, 0, inst);
			case 1: return new IfExpression_Group_5_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// elseExpr=ElseIfExpression
protected class IfExpression_ElseExprAssignment_5_0 extends AssignmentToken  {
	
	public IfExpression_ElseExprAssignment_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getElseExprAssignment_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseIfExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elseExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elseExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getElseIfExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getElseExprElseIfExpressionParserRuleCall_5_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_ThenExprAssignment_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "else" elseExpr=Expression
protected class IfExpression_Group_5_1 extends GroupToken {
	
	public IfExpression_Group_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getGroup_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_ElseExprAssignment_5_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "else"
protected class IfExpression_ElseKeyword_5_1_0 extends KeywordToken  {
	
	public IfExpression_ElseKeyword_5_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getElseKeyword_5_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_ThenExprAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// elseExpr=Expression
protected class IfExpression_ElseExprAssignment_5_1_1 extends AssignmentToken  {
	
	public IfExpression_ElseExprAssignment_5_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getElseExprAssignment_5_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elseExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elseExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getElseExprExpressionParserRuleCall_5_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_ElseKeyword_5_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "endif"
protected class IfExpression_EndifKeyword_6 extends KeywordToken  {
	
	public IfExpression_EndifKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getEndifKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_Alternatives_5(parent, this, 0, inst);
			case 1: return new IfExpression_ThenExprAssignment_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule IfExpression ****************/


/************ begin Rule ElseIfExpression ****************
 *
 * ElseIfExpression returns be::BExpression:
 *   {be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression (
 *   elseExpr=ElseIfExpression|"else" elseExpr=Expression)?;
 *
 **/

// {be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression (
// elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
protected class ElseIfExpression_Group extends GroupToken {
	
	public ElseIfExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseIfExpression_Alternatives_5(parent, this, 0, inst);
			case 1: return new ElseIfExpression_ThenExprAssignment_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getElseIfExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BIfExpression}
protected class ElseIfExpression_BIfExpressionAction_0 extends ActionToken  {

	public ElseIfExpression_BIfExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getBIfExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getElseIfExpressionAccess().getBIfExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "elseif"
protected class ElseIfExpression_ElseifKeyword_1 extends KeywordToken  {
	
	public ElseIfExpression_ElseifKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getElseifKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseIfExpression_BIfExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// conditionExpr=Expression
protected class ElseIfExpression_ConditionExprAssignment_2 extends AssignmentToken  {
	
	public ElseIfExpression_ConditionExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getConditionExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("conditionExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("conditionExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getElseIfExpressionAccess().getConditionExprExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ElseIfExpression_ElseifKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "then"
protected class ElseIfExpression_ThenKeyword_3 extends KeywordToken  {
	
	public ElseIfExpression_ThenKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getThenKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseIfExpression_ConditionExprAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// thenExpr=Expression
protected class ElseIfExpression_ThenExprAssignment_4 extends AssignmentToken  {
	
	public ElseIfExpression_ThenExprAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getThenExprAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("thenExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("thenExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getElseIfExpressionAccess().getThenExprExpressionParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ElseIfExpression_ThenKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
protected class ElseIfExpression_Alternatives_5 extends AlternativesToken {

	public ElseIfExpression_Alternatives_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getAlternatives_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseIfExpression_ElseExprAssignment_5_0(parent, this, 0, inst);
			case 1: return new ElseIfExpression_Group_5_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// elseExpr=ElseIfExpression
protected class ElseIfExpression_ElseExprAssignment_5_0 extends AssignmentToken  {
	
	public ElseIfExpression_ElseExprAssignment_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getElseExprAssignment_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseIfExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elseExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elseExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getElseIfExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getElseIfExpressionAccess().getElseExprElseIfExpressionParserRuleCall_5_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ElseIfExpression_ThenExprAssignment_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "else" elseExpr=Expression
protected class ElseIfExpression_Group_5_1 extends GroupToken {
	
	public ElseIfExpression_Group_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getGroup_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseIfExpression_ElseExprAssignment_5_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "else"
protected class ElseIfExpression_ElseKeyword_5_1_0 extends KeywordToken  {
	
	public ElseIfExpression_ElseKeyword_5_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getElseKeyword_5_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseIfExpression_ThenExprAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// elseExpr=Expression
protected class ElseIfExpression_ElseExprAssignment_5_1_1 extends AssignmentToken  {
	
	public ElseIfExpression_ElseExprAssignment_5_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElseIfExpressionAccess().getElseExprAssignment_5_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elseExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elseExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getElseIfExpressionAccess().getElseExprExpressionParserRuleCall_5_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ElseIfExpression_ElseKeyword_5_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule ElseIfExpression ****************/


/************ begin Rule PropertyValue ****************
 *
 * PropertyValue returns be::BExpression:
 *   {be::BVariableExpression} name=PID;
 *
 **/

// {be::BVariableExpression} name=PID
protected class PropertyValue_Group extends GroupToken {
	
	public PropertyValue_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyValueAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValue_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertyValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BVariableExpression}
protected class PropertyValue_BVariableExpressionAction_0 extends ActionToken  {

	public PropertyValue_BVariableExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPropertyValueAccess().getBVariableExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPropertyValueAccess().getBVariableExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// name=PID
protected class PropertyValue_NameAssignment_1 extends AssignmentToken  {
	
	public PropertyValue_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyValueAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyValue_BVariableExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getPropertyValueAccess().getNamePIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule PropertyValue ****************/


/************ begin Rule VariableValue ****************
 *
 * VariableValue returns be::BExpression:
 *   {be::BVariableExpression} name=ID;
 *
 **/

// {be::BVariableExpression} name=ID
protected class VariableValue_Group extends GroupToken {
	
	public VariableValue_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableValueAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableValue_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BVariableExpression}
protected class VariableValue_BVariableExpressionAction_0 extends ActionToken  {

	public VariableValue_BVariableExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getVariableValueAccess().getBVariableExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getVariableValueAccess().getBVariableExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// name=ID
protected class VariableValue_NameAssignment_1 extends AssignmentToken  {
	
	public VariableValue_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableValueAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableValue_BVariableExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableValueAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule VariableValue ****************/


/************ begin Rule KeywordVariables ****************
 *
 * KeywordVariables returns be::BExpression:
 *   {be::BVariableExpression} name=( "input" | "output" | "properties" | "unit" );
 *
 **/

// {be::BVariableExpression} name=( "input" | "output" | "properties" | "unit" )
protected class KeywordVariables_Group extends GroupToken {
	
	public KeywordVariables_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getKeywordVariablesAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new KeywordVariables_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getKeywordVariablesRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BVariableExpression}
protected class KeywordVariables_BVariableExpressionAction_0 extends ActionToken  {

	public KeywordVariables_BVariableExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getKeywordVariablesAccess().getBVariableExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getKeywordVariablesAccess().getBVariableExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// name=( "input" | "output" | "properties" | "unit" )
protected class KeywordVariables_NameAssignment_1 extends AssignmentToken  {
	
	public KeywordVariables_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getKeywordVariablesAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new KeywordVariables_BVariableExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if("input".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getKeywordVariablesAccess().getNameInputKeyword_1_0_0();
			return obj;
		}
		if("output".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getKeywordVariablesAccess().getNameOutputKeyword_1_0_1();
			return obj;
		}
		if("properties".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getKeywordVariablesAccess().getNamePropertiesKeyword_1_0_2();
			return obj;
		}
		if("unit".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getKeywordVariablesAccess().getNameUnitKeyword_1_0_3();
			return obj;
		}
		return null;
	}

}


/************ end Rule KeywordVariables ****************/


/************ begin Rule FeatureCall ****************
 *
 * FeatureCall returns be::BExpression:
 *   OperationCall;
 *
 **/

// OperationCall
protected class FeatureCall_OperationCallParserRuleCall extends RuleCallToken {
	
	public FeatureCall_OperationCallParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getOperationCallParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OperationCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFeatureCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OperationCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOperationCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule FeatureCall ****************/


/************ begin Rule OperationCall ****************
 *
 * OperationCall returns be::BCallExpression:
 *   {be::BCallExpression} name=( ID | PID ) "(" parameterList=ParameterList? ")";
 *
 **/

// {be::BCallExpression} name=( ID | PID ) "(" parameterList=ParameterList? ")"
protected class OperationCall_Group extends GroupToken {
	
	public OperationCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOperationCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OperationCall_RightParenthesisKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOperationCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BCallExpression}
protected class OperationCall_BCallExpressionAction_0 extends ActionToken  {

	public OperationCall_BCallExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOperationCallAccess().getBCallExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOperationCallAccess().getBCallExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// name=( ID | PID )
protected class OperationCall_NameAssignment_1 extends AssignmentToken  {
	
	public OperationCall_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationCallAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OperationCall_BCallExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getOperationCallAccess().getNameIDTerminalRuleCall_1_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getOperationCallAccess().getNamePIDTerminalRuleCall_1_0_1();
			return obj;
		}
		return null;
	}

}

// "("
protected class OperationCall_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public OperationCall_LeftParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationCallAccess().getLeftParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OperationCall_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parameterList=ParameterList?
protected class OperationCall_ParameterListAssignment_3 extends AssignmentToken  {
	
	public OperationCall_ParameterListAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationCallAccess().getParameterListAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameterList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameterList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOperationCallAccess().getParameterListParameterListParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OperationCall_LeftParenthesisKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class OperationCall_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public OperationCall_RightParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationCallAccess().getRightParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OperationCall_ParameterListAssignment_3(parent, this, 0, inst);
			case 1: return new OperationCall_LeftParenthesisKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule OperationCall ****************/


/************ begin Rule ConstructorCallExpression ****************
 *
 * ConstructorCallExpression returns be::BExpression:
 *   {be::BCreateExpression} "new" typeExpr=LiteralType ("(" parameterList=ParameterList?
 *   ")")? ("as" alias=ID)? contextBlock=ContextBlock_Creation?; 
 * 
 *          
 * 	   
 * 	    
 * 	   
 * 	    
 * 	
 * 
 * //Context : 
 * //	"context" selector = ContextSelector block = ContextBlock 
 * //	;
 * //
 * //ContextSelector : 
 * //	TypeRefSelector | ExpressionSelector | UnitSelector 
 * //	;
 * //	
 * //TypeRefSelector returns ContextSelector :
 * //	 type = TypeRef 
 * //	 ;
 * //	 
 * //ExpressionSelector : 
 * //	expr = Expression 
 * //	;
 * //	
 * //UnitSelector : 
 * //	"unit" interface=QID 
 * //	('/' (name=UnitName | namePattern = REGULAR_EXPR) ('/' versionRange=VersionRange)? )? 
 * //	;
 *
 **/

// {be::BCreateExpression} "new" typeExpr=LiteralType ("(" parameterList=ParameterList?
// ")")? ("as" alias=ID)? contextBlock=ContextBlock_Creation?
protected class ConstructorCallExpression_Group extends GroupToken {
	
	public ConstructorCallExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_ContextBlockAssignment_5(parent, this, 0, inst);
			case 1: return new ConstructorCallExpression_Group_4(parent, this, 1, inst);
			case 2: return new ConstructorCallExpression_Group_3(parent, this, 2, inst);
			case 3: return new ConstructorCallExpression_TypeExprAssignment_2(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstructorCallExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BCreateExpression}
protected class ConstructorCallExpression_BCreateExpressionAction_0 extends ActionToken  {

	public ConstructorCallExpression_BCreateExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getBCreateExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getConstructorCallExpressionAccess().getBCreateExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "new"
protected class ConstructorCallExpression_NewKeyword_1 extends KeywordToken  {
	
	public ConstructorCallExpression_NewKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getNewKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_BCreateExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeExpr=LiteralType
protected class ConstructorCallExpression_TypeExprAssignment_2 extends AssignmentToken  {
	
	public ConstructorCallExpression_TypeExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getTypeExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralType_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLiteralTypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallExpressionAccess().getTypeExprLiteralTypeParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCallExpression_NewKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("(" parameterList=ParameterList? ")")?
protected class ConstructorCallExpression_Group_3 extends GroupToken {
	
	public ConstructorCallExpression_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_RightParenthesisKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class ConstructorCallExpression_LeftParenthesisKeyword_3_0 extends KeywordToken  {
	
	public ConstructorCallExpression_LeftParenthesisKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getLeftParenthesisKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_TypeExprAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parameterList=ParameterList?
protected class ConstructorCallExpression_ParameterListAssignment_3_1 extends AssignmentToken  {
	
	public ConstructorCallExpression_ParameterListAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getParameterListAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameterList",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameterList");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallExpressionAccess().getParameterListParameterListParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCallExpression_LeftParenthesisKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class ConstructorCallExpression_RightParenthesisKeyword_3_2 extends KeywordToken  {
	
	public ConstructorCallExpression_RightParenthesisKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getRightParenthesisKeyword_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_ParameterListAssignment_3_1(parent, this, 0, inst);
			case 1: return new ConstructorCallExpression_LeftParenthesisKeyword_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// ("as" alias=ID)?
protected class ConstructorCallExpression_Group_4 extends GroupToken {
	
	public ConstructorCallExpression_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_AliasAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "as"
protected class ConstructorCallExpression_AsKeyword_4_0 extends KeywordToken  {
	
	public ConstructorCallExpression_AsKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getAsKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_Group_3(parent, this, 0, inst);
			case 1: return new ConstructorCallExpression_TypeExprAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// alias=ID
protected class ConstructorCallExpression_AliasAssignment_4_1 extends AssignmentToken  {
	
	public ConstructorCallExpression_AliasAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getAliasAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCallExpression_AsKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alias",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getConstructorCallExpressionAccess().getAliasIDTerminalRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}


// contextBlock=ContextBlock_Creation?
protected class ConstructorCallExpression_ContextBlockAssignment_5 extends AssignmentToken  {
	
	public ConstructorCallExpression_ContextBlockAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallExpressionAccess().getContextBlockAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Creation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("contextBlock",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("contextBlock");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getContextBlock_CreationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallExpressionAccess().getContextBlockContextBlock_CreationParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCallExpression_Group_4(parent, next, actIndex, consumed);
			case 1: return new ConstructorCallExpression_Group_3(parent, next, actIndex, consumed);
			case 2: return new ConstructorCallExpression_TypeExprAssignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ConstructorCallExpression ****************/


/************ begin Rule ContextBlock ****************
 *
 * ContextBlock returns be::BExpression:
 *   {be::BChainedExpression} "{" (expressions+=FunctionDefinition|expressions+=
 *   TopLevelExpression ";")* "}"; 
 * 
 * //Context : 
 * //	"context" selector = ContextSelector block = ContextBlock 
 * //	;
 * //
 * //ContextSelector : 
 * //	TypeRefSelector | ExpressionSelector | UnitSelector 
 * //	;
 * //	
 * //TypeRefSelector returns ContextSelector :
 * //	 type = TypeRef 
 * //	 ;
 * //	 
 * //ExpressionSelector : 
 * //	expr = Expression 
 * //	;
 * //	
 * //UnitSelector : 
 * //	"unit" interface=QID 
 * //	('/' (name=UnitName | namePattern = REGULAR_EXPR) ('/' versionRange=VersionRange)? )? 
 * //	;
 * 
 *          
 * 	      
 * //		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
 * 		     
 * //		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
 *
 **/

// {be::BChainedExpression} "{" (expressions+=FunctionDefinition|expressions+=
// TopLevelExpression ";")* "}"    
// 	      
// //		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
// 		     
// //		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
protected class ContextBlock_Group extends GroupToken {
	
	public ContextBlock_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_RightCurlyBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getContextBlockRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BChainedExpression}
protected class ContextBlock_BChainedExpressionAction_0 extends ActionToken  {

	public ContextBlock_BChainedExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getBChainedExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getContextBlockAccess().getBChainedExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "{"
protected class ContextBlock_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public ContextBlock_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getLeftCurlyBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_BChainedExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (expressions+=FunctionDefinition|expressions+=TopLevelExpression ";")*       
// //		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
// 		     
// //		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
protected class ContextBlock_Alternatives_2 extends AlternativesToken {

	public ContextBlock_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_ExpressionsAssignment_2_0(parent, this, 0, inst);
			case 1: return new ContextBlock_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=FunctionDefinition
protected class ContextBlock_ExpressionsAssignment_2_0 extends AssignmentToken  {
	
	public ContextBlock_ExpressionsAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getExpressionsAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionDefinition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionDefinitionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getContextBlockAccess().getExpressionsFunctionDefinitionParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ContextBlock_Alternatives_2(parent, next, actIndex, consumed);
			case 1: return new ContextBlock_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// expressions+=TopLevelExpression ";"
protected class ContextBlock_Group_2_1 extends GroupToken {
	
	public ContextBlock_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_SemicolonKeyword_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=TopLevelExpression
protected class ContextBlock_ExpressionsAssignment_2_1_0 extends AssignmentToken  {
	
	public ContextBlock_ExpressionsAssignment_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getExpressionsAssignment_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TopLevelExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTopLevelExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getContextBlockAccess().getExpressionsTopLevelExpressionParserRuleCall_2_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ContextBlock_Alternatives_2(parent, next, actIndex, consumed);
			case 1: return new ContextBlock_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class ContextBlock_SemicolonKeyword_2_1_1 extends KeywordToken  {
	
	public ContextBlock_SemicolonKeyword_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getSemicolonKeyword_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_ExpressionsAssignment_2_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// "}"
protected class ContextBlock_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public ContextBlock_RightCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getContextBlockAccess().getRightCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Alternatives_2(parent, this, 0, inst);
			case 1: return new ContextBlock_LeftCurlyBracketKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ContextBlock ****************/


/************ begin Rule ContextBlock_Creation ****************
 *
 * ContextBlock_Creation returns be::BExpression:
 *   {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"; 
 * 
 *          
 * 	       
 * 	
 * 					
 * //ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
 * //PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = PropertySet_Named ;
 *
 **/

// {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"
protected class ContextBlock_Creation_Group extends GroupToken {
	
	public ContextBlock_Creation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getContextBlock_CreationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Creation_RightCurlyBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getContextBlock_CreationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BChainedExpression}
protected class ContextBlock_Creation_BChainedExpressionAction_0 extends ActionToken  {

	public ContextBlock_Creation_BChainedExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getContextBlock_CreationAccess().getBChainedExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getContextBlock_CreationAccess().getBChainedExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "{"
protected class ContextBlock_Creation_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public ContextBlock_Creation_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getContextBlock_CreationAccess().getLeftCurlyBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Creation_BChainedExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (expressions+=TopLevelExpression ";")*
protected class ContextBlock_Creation_Group_2 extends GroupToken {
	
	public ContextBlock_Creation_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getContextBlock_CreationAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Creation_SemicolonKeyword_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=TopLevelExpression
protected class ContextBlock_Creation_ExpressionsAssignment_2_0 extends AssignmentToken  {
	
	public ContextBlock_Creation_ExpressionsAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getContextBlock_CreationAccess().getExpressionsAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TopLevelExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTopLevelExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getContextBlock_CreationAccess().getExpressionsTopLevelExpressionParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ContextBlock_Creation_Group_2(parent, next, actIndex, consumed);
			case 1: return new ContextBlock_Creation_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class ContextBlock_Creation_SemicolonKeyword_2_1 extends KeywordToken  {
	
	public ContextBlock_Creation_SemicolonKeyword_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getContextBlock_CreationAccess().getSemicolonKeyword_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Creation_ExpressionsAssignment_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class ContextBlock_Creation_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public ContextBlock_Creation_RightCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getContextBlock_CreationAccess().getRightCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ContextBlock_Creation_Group_2(parent, this, 0, inst);
			case 1: return new ContextBlock_Creation_LeftCurlyBracketKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ContextBlock_Creation ****************/


/************ begin Rule FunctionDefinition ****************
 *
 * FunctionDefinition returns be::BExpression:
 *   {be::BDefFunction} function=Function; 
 * 					
 * //ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
 * //PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = PropertySet_Named ;
 *               
 * //BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
 *
 **/

// {be::BDefFunction} function=Function
protected class FunctionDefinition_Group extends GroupToken {
	
	public FunctionDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionDefinition_FunctionAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BDefFunction}
protected class FunctionDefinition_BDefFunctionAction_0 extends ActionToken  {

	public FunctionDefinition_BDefFunctionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFunctionDefinitionAccess().getBDefFunctionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFunctionDefinitionAccess().getBDefFunctionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// function=Function
protected class FunctionDefinition_FunctionAssignment_1 extends AssignmentToken  {
	
	public FunctionDefinition_FunctionAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionDefinitionAccess().getFunctionAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("function",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("function");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionDefinitionAccess().getFunctionFunctionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionDefinition_BDefFunctionAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule FunctionDefinition ****************/


/************ begin Rule Literal ****************
 *
 * Literal returns be::BExpression:
 *   ValueLiteral|RegexpLiteral|LiteralMap|LiteralList|LiteralFunction; 
 * //BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
 *
 **/

// ValueLiteral|RegexpLiteral|LiteralMap|LiteralList|LiteralFunction 
// //BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
protected class Literal_Alternatives extends AlternativesToken {

	public Literal_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLiteralAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Literal_ValueLiteralParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Literal_RegexpLiteralParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Literal_LiteralMapParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Literal_LiteralListParserRuleCall_3(parent, this, 3, inst);
			case 4: return new Literal_LiteralFunctionParserRuleCall_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ValueLiteral
protected class Literal_ValueLiteralParserRuleCall_0 extends RuleCallToken {
	
	public Literal_ValueLiteralParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getValueLiteralParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueLiteral_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValueLiteral_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValueLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RegexpLiteral
protected class Literal_RegexpLiteralParserRuleCall_1 extends RuleCallToken {
	
	public Literal_RegexpLiteralParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getRegexpLiteralParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegexpLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RegexpLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRegexpLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// LiteralMap
protected class Literal_LiteralMapParserRuleCall_2 extends RuleCallToken {
	
	public Literal_LiteralMapParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getLiteralMapParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LiteralMap_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLiteralMapRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// LiteralList
protected class Literal_LiteralListParserRuleCall_3 extends RuleCallToken {
	
	public Literal_LiteralListParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getLiteralListParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LiteralList_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLiteralListRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// LiteralFunction
protected class Literal_LiteralFunctionParserRuleCall_4 extends RuleCallToken {
	
	public Literal_LiteralFunctionParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getLiteralFunctionParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralFunction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LiteralFunction_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLiteralFunctionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Literal ****************/


/************ begin Rule LiteralList ****************
 *
 * LiteralList returns be::BExpression:
 *   {be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
 *   entries+=Expression)* "]"|{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">"
 *   "]";
 *
 **/

// {be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
// entries+=Expression)* "]"|{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">"
// "]"
protected class LiteralList_Alternatives extends AlternativesToken {

	public LiteralList_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_Group_0(parent, this, 0, inst);
			case 1: return new LiteralList_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLiteralListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
// entries+=Expression)* "]"
protected class LiteralList_Group_0 extends GroupToken {
	
	public LiteralList_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_RightSquareBracketKeyword_0_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BLiteralListExpression}
protected class LiteralList_BLiteralListExpressionAction_0_0 extends ActionToken  {

	public LiteralList_BLiteralListExpressionAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getBLiteralListExpressionAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getLiteralListAccess().getBLiteralListExpressionAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "["
protected class LiteralList_LeftSquareBracketKeyword_0_1 extends KeywordToken  {
	
	public LiteralList_LeftSquareBracketKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getLeftSquareBracketKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_BLiteralListExpressionAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("<" entryType=TypeRef ">")?
protected class LiteralList_Group_0_2 extends GroupToken {
	
	public LiteralList_Group_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getGroup_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_GreaterThanSignKeyword_0_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class LiteralList_LessThanSignKeyword_0_2_0 extends KeywordToken  {
	
	public LiteralList_LessThanSignKeyword_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getLessThanSignKeyword_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_LeftSquareBracketKeyword_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// entryType=TypeRef
protected class LiteralList_EntryTypeAssignment_0_2_1 extends AssignmentToken  {
	
	public LiteralList_EntryTypeAssignment_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getEntryTypeAssignment_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entryType",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entryType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralListAccess().getEntryTypeTypeRefParserRuleCall_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralList_LessThanSignKeyword_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ">"
protected class LiteralList_GreaterThanSignKeyword_0_2_2 extends KeywordToken  {
	
	public LiteralList_GreaterThanSignKeyword_0_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getGreaterThanSignKeyword_0_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_EntryTypeAssignment_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// entries+=Expression
protected class LiteralList_EntriesAssignment_0_3 extends AssignmentToken  {
	
	public LiteralList_EntriesAssignment_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getEntriesAssignment_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entries",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entries");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralListAccess().getEntriesExpressionParserRuleCall_0_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralList_Group_0_2(parent, next, actIndex, consumed);
			case 1: return new LiteralList_LeftSquareBracketKeyword_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," entries+=Expression)*
protected class LiteralList_Group_0_4 extends GroupToken {
	
	public LiteralList_Group_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getGroup_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_EntriesAssignment_0_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LiteralList_CommaKeyword_0_4_0 extends KeywordToken  {
	
	public LiteralList_CommaKeyword_0_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getCommaKeyword_0_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_Group_0_4(parent, this, 0, inst);
			case 1: return new LiteralList_EntriesAssignment_0_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// entries+=Expression
protected class LiteralList_EntriesAssignment_0_4_1 extends AssignmentToken  {
	
	public LiteralList_EntriesAssignment_0_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getEntriesAssignment_0_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entries",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entries");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralListAccess().getEntriesExpressionParserRuleCall_0_4_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralList_CommaKeyword_0_4_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "]"
protected class LiteralList_RightSquareBracketKeyword_0_5 extends KeywordToken  {
	
	public LiteralList_RightSquareBracketKeyword_0_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getRightSquareBracketKeyword_0_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_Group_0_4(parent, this, 0, inst);
			case 1: return new LiteralList_EntriesAssignment_0_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// {be::BLiteralListExpression} "[" "<" entryType=TypeRef ">" "]"
protected class LiteralList_Group_1 extends GroupToken {
	
	public LiteralList_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_RightSquareBracketKeyword_1_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BLiteralListExpression}
protected class LiteralList_BLiteralListExpressionAction_1_0 extends ActionToken  {

	public LiteralList_BLiteralListExpressionAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getBLiteralListExpressionAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getLiteralListAccess().getBLiteralListExpressionAction_1_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "["
protected class LiteralList_LeftSquareBracketKeyword_1_1 extends KeywordToken  {
	
	public LiteralList_LeftSquareBracketKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getLeftSquareBracketKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_BLiteralListExpressionAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class LiteralList_LessThanSignKeyword_1_2 extends KeywordToken  {
	
	public LiteralList_LessThanSignKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getLessThanSignKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_LeftSquareBracketKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// entryType=TypeRef
protected class LiteralList_EntryTypeAssignment_1_3 extends AssignmentToken  {
	
	public LiteralList_EntryTypeAssignment_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getEntryTypeAssignment_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entryType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entryType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralListAccess().getEntryTypeTypeRefParserRuleCall_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralList_LessThanSignKeyword_1_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ">"
protected class LiteralList_GreaterThanSignKeyword_1_4 extends KeywordToken  {
	
	public LiteralList_GreaterThanSignKeyword_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getGreaterThanSignKeyword_1_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_EntryTypeAssignment_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "]"
protected class LiteralList_RightSquareBracketKeyword_1_5 extends KeywordToken  {
	
	public LiteralList_RightSquareBracketKeyword_1_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralListAccess().getRightSquareBracketKeyword_1_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralList_GreaterThanSignKeyword_1_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule LiteralList ****************/


/************ begin Rule LiteralMap ****************
 *
 * LiteralMap returns be::BExpression:
 *   {be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
 *   entries+=MapEntry ("," entries+=MapEntry)* "]"|{be::BLiteralMapExpression} "[" "<"
 *   keyType=TypeRef "," valueType=TypeRef ">" "]"; 
 * 	
 *      
 * 	                                
 * 	                 
 * 	
 * 
 * // A lambda enclosed in { }
 *
 **/

// {be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
// entries+=MapEntry ("," entries+=MapEntry)* "]"|{be::BLiteralMapExpression} "[" "<"
// keyType=TypeRef "," valueType=TypeRef ">" "]" 
// 	
//      
// 	                                
// 	                 
// 	
// 
// // A lambda enclosed in { }
protected class LiteralMap_Alternatives extends AlternativesToken {

	public LiteralMap_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_Group_0(parent, this, 0, inst);
			case 1: return new LiteralMap_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLiteralMapRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
// entries+=MapEntry ("," entries+=MapEntry)* "]"
protected class LiteralMap_Group_0 extends GroupToken {
	
	public LiteralMap_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_RightSquareBracketKeyword_0_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BLiteralMapExpression}
protected class LiteralMap_BLiteralMapExpressionAction_0_0 extends ActionToken  {

	public LiteralMap_BLiteralMapExpressionAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getBLiteralMapExpressionAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getLiteralMapAccess().getBLiteralMapExpressionAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "["
protected class LiteralMap_LeftSquareBracketKeyword_0_1 extends KeywordToken  {
	
	public LiteralMap_LeftSquareBracketKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getLeftSquareBracketKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_BLiteralMapExpressionAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("<" keyType=TypeRef "," valueType=TypeRef ">")?
protected class LiteralMap_Group_0_2 extends GroupToken {
	
	public LiteralMap_Group_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getGroup_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_GreaterThanSignKeyword_0_2_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class LiteralMap_LessThanSignKeyword_0_2_0 extends KeywordToken  {
	
	public LiteralMap_LessThanSignKeyword_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getLessThanSignKeyword_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_LeftSquareBracketKeyword_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// keyType=TypeRef
protected class LiteralMap_KeyTypeAssignment_0_2_1 extends AssignmentToken  {
	
	public LiteralMap_KeyTypeAssignment_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getKeyTypeAssignment_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("keyType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("keyType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralMapAccess().getKeyTypeTypeRefParserRuleCall_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralMap_LessThanSignKeyword_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ","
protected class LiteralMap_CommaKeyword_0_2_2 extends KeywordToken  {
	
	public LiteralMap_CommaKeyword_0_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getCommaKeyword_0_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_KeyTypeAssignment_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// valueType=TypeRef
protected class LiteralMap_ValueTypeAssignment_0_2_3 extends AssignmentToken  {
	
	public LiteralMap_ValueTypeAssignment_0_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getValueTypeAssignment_0_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("valueType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("valueType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralMapAccess().getValueTypeTypeRefParserRuleCall_0_2_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralMap_CommaKeyword_0_2_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ">"
protected class LiteralMap_GreaterThanSignKeyword_0_2_4 extends KeywordToken  {
	
	public LiteralMap_GreaterThanSignKeyword_0_2_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getGreaterThanSignKeyword_0_2_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_ValueTypeAssignment_0_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// entries+=MapEntry
protected class LiteralMap_EntriesAssignment_0_3 extends AssignmentToken  {
	
	public LiteralMap_EntriesAssignment_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getEntriesAssignment_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MapEntry_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entries",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entries");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMapEntryRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralMapAccess().getEntriesMapEntryParserRuleCall_0_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralMap_Group_0_2(parent, next, actIndex, consumed);
			case 1: return new LiteralMap_LeftSquareBracketKeyword_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," entries+=MapEntry)*
protected class LiteralMap_Group_0_4 extends GroupToken {
	
	public LiteralMap_Group_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getGroup_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_EntriesAssignment_0_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LiteralMap_CommaKeyword_0_4_0 extends KeywordToken  {
	
	public LiteralMap_CommaKeyword_0_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getCommaKeyword_0_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_Group_0_4(parent, this, 0, inst);
			case 1: return new LiteralMap_EntriesAssignment_0_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// entries+=MapEntry
protected class LiteralMap_EntriesAssignment_0_4_1 extends AssignmentToken  {
	
	public LiteralMap_EntriesAssignment_0_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getEntriesAssignment_0_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MapEntry_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entries",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entries");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMapEntryRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralMapAccess().getEntriesMapEntryParserRuleCall_0_4_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralMap_CommaKeyword_0_4_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "]"
protected class LiteralMap_RightSquareBracketKeyword_0_5 extends KeywordToken  {
	
	public LiteralMap_RightSquareBracketKeyword_0_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getRightSquareBracketKeyword_0_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_Group_0_4(parent, this, 0, inst);
			case 1: return new LiteralMap_EntriesAssignment_0_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// {be::BLiteralMapExpression} "[" "<" keyType=TypeRef "," valueType=TypeRef ">" "]"
protected class LiteralMap_Group_1 extends GroupToken {
	
	public LiteralMap_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_RightSquareBracketKeyword_1_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {be::BLiteralMapExpression}
protected class LiteralMap_BLiteralMapExpressionAction_1_0 extends ActionToken  {

	public LiteralMap_BLiteralMapExpressionAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getBLiteralMapExpressionAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getLiteralMapAccess().getBLiteralMapExpressionAction_1_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "["
protected class LiteralMap_LeftSquareBracketKeyword_1_1 extends KeywordToken  {
	
	public LiteralMap_LeftSquareBracketKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getLeftSquareBracketKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_BLiteralMapExpressionAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class LiteralMap_LessThanSignKeyword_1_2 extends KeywordToken  {
	
	public LiteralMap_LessThanSignKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getLessThanSignKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_LeftSquareBracketKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// keyType=TypeRef
protected class LiteralMap_KeyTypeAssignment_1_3 extends AssignmentToken  {
	
	public LiteralMap_KeyTypeAssignment_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getKeyTypeAssignment_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("keyType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("keyType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralMapAccess().getKeyTypeTypeRefParserRuleCall_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralMap_LessThanSignKeyword_1_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ","
protected class LiteralMap_CommaKeyword_1_4 extends KeywordToken  {
	
	public LiteralMap_CommaKeyword_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getCommaKeyword_1_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_KeyTypeAssignment_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// valueType=TypeRef
protected class LiteralMap_ValueTypeAssignment_1_5 extends AssignmentToken  {
	
	public LiteralMap_ValueTypeAssignment_1_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getValueTypeAssignment_1_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("valueType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("valueType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralMapAccess().getValueTypeTypeRefParserRuleCall_1_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralMap_CommaKeyword_1_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ">"
protected class LiteralMap_GreaterThanSignKeyword_1_6 extends KeywordToken  {
	
	public LiteralMap_GreaterThanSignKeyword_1_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getGreaterThanSignKeyword_1_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_ValueTypeAssignment_1_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "]"
protected class LiteralMap_RightSquareBracketKeyword_1_7 extends KeywordToken  {
	
	public LiteralMap_RightSquareBracketKeyword_1_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralMapAccess().getRightSquareBracketKeyword_1_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralMap_GreaterThanSignKeyword_1_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule LiteralMap ****************/


/************ begin Rule LiteralFunction ****************
 *
 * LiteralFunction returns be::BExpression:
 *   "{" ClosureExpression "}"; 
 * 
 * // A lambda enclosed in { }
 *       
 * 	    
 * 	
 * 
 * //LiteralFunction returns be::BExpression : {be::B3Function} 
 * //	'{' ('<' returnType=TypeRef '>')?
 * //	(
 * //	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
 * //		(',' varArgs?="..." parameters += ParameterDeclaration)?)
 * //	| 	(    varArgs?="..." parameters += ParameterDeclaration)
 * //	)? 
 * //	'|' funcExpr=OneOrManyExpressions '}'
 * //	;
 * 
 * // A lambda (without delimiters)
 *
 **/

// "{" ClosureExpression "}"
protected class LiteralFunction_Group extends GroupToken {
	
	public LiteralFunction_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralFunctionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralFunction_RightCurlyBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLiteralFunctionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "{"
protected class LiteralFunction_LeftCurlyBracketKeyword_0 extends KeywordToken  {
	
	public LiteralFunction_LeftCurlyBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralFunctionAccess().getLeftCurlyBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ClosureExpression
protected class LiteralFunction_ClosureExpressionParserRuleCall_1 extends RuleCallToken {
	
	public LiteralFunction_ClosureExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralFunctionAccess().getClosureExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ClosureExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getClosureExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralFunction_LeftCurlyBracketKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// "}"
protected class LiteralFunction_RightCurlyBracketKeyword_2 extends KeywordToken  {
	
	public LiteralFunction_RightCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLiteralFunctionAccess().getRightCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralFunction_ClosureExpressionParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule LiteralFunction ****************/


/************ begin Rule ClosureExpression ****************
 *
 * ClosureExpression returns be::BExpression:
 *   {be::B3Function} ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (","
 *   parameters+=ParameterDeclaration)* ("," varArgs?="..." parameters+=
 *   ParameterDeclaration)?|varArgs?="..." parameters+=ParameterDeclaration)? "|"
 *   funcExpr=OneOrManyExpressions; 
 * 
 * //LiteralFunction returns be::BExpression : {be::B3Function} 
 * //	'{' ('<' returnType=TypeRef '>')?
 * //	(
 * //	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
 * //		(',' varArgs?="..." parameters += ParameterDeclaration)?)
 * //	| 	(    varArgs?="..." parameters += ParameterDeclaration)
 * //	)? 
 * //	'|' funcExpr=OneOrManyExpressions '}'
 * //	;
 * 
 * // A lambda (without delimiters)
 *
 **/

// {be::B3Function} ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (","
// parameters+=ParameterDeclaration)* ("," varArgs?="..." parameters+=
// ParameterDeclaration)?|varArgs?="..." parameters+=ParameterDeclaration)? "|"
// funcExpr=OneOrManyExpressions
protected class ClosureExpression_Group extends GroupToken {
	
	public ClosureExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_FuncExprAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getClosureExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::B3Function}
protected class ClosureExpression_B3FunctionAction_0 extends ActionToken  {

	public ClosureExpression_B3FunctionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getB3FunctionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getClosureExpressionAccess().getB3FunctionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ("<" returnType=TypeRef ">")?
protected class ClosureExpression_Group_1 extends GroupToken {
	
	public ClosureExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_GreaterThanSignKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class ClosureExpression_LessThanSignKeyword_1_0 extends KeywordToken  {
	
	public ClosureExpression_LessThanSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getLessThanSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_B3FunctionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// returnType=TypeRef
protected class ClosureExpression_ReturnTypeAssignment_1_1 extends AssignmentToken  {
	
	public ClosureExpression_ReturnTypeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getReturnTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("returnType",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("returnType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureExpressionAccess().getReturnTypeTypeRefParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ClosureExpression_LessThanSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ">"
protected class ClosureExpression_GreaterThanSignKeyword_1_2 extends KeywordToken  {
	
	public ClosureExpression_GreaterThanSignKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getGreaterThanSignKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_ReturnTypeAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
// varArgs?="..." parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
// ParameterDeclaration)?
protected class ClosureExpression_Alternatives_2 extends AlternativesToken {

	public ClosureExpression_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_Group_2_0(parent, this, 0, inst);
			case 1: return new ClosureExpression_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
// varArgs?="..." parameters+=ParameterDeclaration)?
protected class ClosureExpression_Group_2_0 extends GroupToken {
	
	public ClosureExpression_Group_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getGroup_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_Group_2_0_2(parent, this, 0, inst);
			case 1: return new ClosureExpression_Group_2_0_1(parent, this, 1, inst);
			case 2: return new ClosureExpression_ParametersAssignment_2_0_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration
protected class ClosureExpression_ParametersAssignment_2_0_0 extends AssignmentToken  {
	
	public ClosureExpression_ParametersAssignment_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getParametersAssignment_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureExpressionAccess().getParametersParameterDeclarationParserRuleCall_2_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ClosureExpression_Group_1(parent, next, actIndex, consumed);
			case 1: return new ClosureExpression_B3FunctionAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," parameters+=ParameterDeclaration)*
protected class ClosureExpression_Group_2_0_1 extends GroupToken {
	
	public ClosureExpression_Group_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getGroup_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_ParametersAssignment_2_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ClosureExpression_CommaKeyword_2_0_1_0 extends KeywordToken  {
	
	public ClosureExpression_CommaKeyword_2_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getCommaKeyword_2_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_Group_2_0_1(parent, this, 0, inst);
			case 1: return new ClosureExpression_ParametersAssignment_2_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=ParameterDeclaration
protected class ClosureExpression_ParametersAssignment_2_0_1_1 extends AssignmentToken  {
	
	public ClosureExpression_ParametersAssignment_2_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getParametersAssignment_2_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureExpressionAccess().getParametersParameterDeclarationParserRuleCall_2_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ClosureExpression_CommaKeyword_2_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ("," varArgs?="..." parameters+=ParameterDeclaration)?
protected class ClosureExpression_Group_2_0_2 extends GroupToken {
	
	public ClosureExpression_Group_2_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getGroup_2_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_ParametersAssignment_2_0_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ClosureExpression_CommaKeyword_2_0_2_0 extends KeywordToken  {
	
	public ClosureExpression_CommaKeyword_2_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getCommaKeyword_2_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_Group_2_0_1(parent, this, 0, inst);
			case 1: return new ClosureExpression_ParametersAssignment_2_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..."
protected class ClosureExpression_VarArgsAssignment_2_0_2_1 extends AssignmentToken  {
	
	public ClosureExpression_VarArgsAssignment_2_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getVarArgsAssignment_2_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_CommaKeyword_2_0_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varArgs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varArgs");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getClosureExpressionAccess().getVarArgsFullStopFullStopFullStopKeyword_2_0_2_1_0();
			return obj;
		}
		return null;
	}

}

// parameters+=ParameterDeclaration
protected class ClosureExpression_ParametersAssignment_2_0_2_2 extends AssignmentToken  {
	
	public ClosureExpression_ParametersAssignment_2_0_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getParametersAssignment_2_0_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureExpressionAccess().getParametersParameterDeclarationParserRuleCall_2_0_2_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ClosureExpression_VarArgsAssignment_2_0_2_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// varArgs?="..." parameters+=ParameterDeclaration
protected class ClosureExpression_Group_2_1 extends GroupToken {
	
	public ClosureExpression_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_ParametersAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// varArgs?="..."
protected class ClosureExpression_VarArgsAssignment_2_1_0 extends AssignmentToken  {
	
	public ClosureExpression_VarArgsAssignment_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getVarArgsAssignment_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_Group_1(parent, this, 0, inst);
			case 1: return new ClosureExpression_B3FunctionAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("varArgs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("varArgs");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getClosureExpressionAccess().getVarArgsFullStopFullStopFullStopKeyword_2_1_0_0();
			return obj;
		}
		return null;
	}

}

// parameters+=ParameterDeclaration
protected class ClosureExpression_ParametersAssignment_2_1_1 extends AssignmentToken  {
	
	public ClosureExpression_ParametersAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getParametersAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParameterDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureExpressionAccess().getParametersParameterDeclarationParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ClosureExpression_VarArgsAssignment_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "|"
protected class ClosureExpression_VerticalLineKeyword_3 extends KeywordToken  {
	
	public ClosureExpression_VerticalLineKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getVerticalLineKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClosureExpression_Alternatives_2(parent, this, 0, inst);
			case 1: return new ClosureExpression_Group_1(parent, this, 1, inst);
			case 2: return new ClosureExpression_B3FunctionAction_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// funcExpr=OneOrManyExpressions
protected class ClosureExpression_FuncExprAssignment_4 extends AssignmentToken  {
	
	public ClosureExpression_FuncExprAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureExpressionAccess().getFuncExprAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OneOrManyExpressions_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("funcExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("funcExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOneOrManyExpressionsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureExpressionAccess().getFuncExprOneOrManyExpressionsParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ClosureExpression_VerticalLineKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ClosureExpression ****************/


/************ begin Rule OneOrManyExpressions ****************
 *
 * OneOrManyExpressions returns be::BExpression:
 *   BlockExpressionWithoutBrackets|Expression;
 *
 **/

// BlockExpressionWithoutBrackets|Expression
protected class OneOrManyExpressions_Alternatives extends AlternativesToken {

	public OneOrManyExpressions_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getOneOrManyExpressionsAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OneOrManyExpressions_BlockExpressionWithoutBracketsParserRuleCall_0(parent, this, 0, inst);
			case 1: return new OneOrManyExpressions_ExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOneOrManyExpressionsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BlockExpressionWithoutBrackets
protected class OneOrManyExpressions_BlockExpressionWithoutBracketsParserRuleCall_0 extends RuleCallToken {
	
	public OneOrManyExpressions_BlockExpressionWithoutBracketsParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOneOrManyExpressionsAccess().getBlockExpressionWithoutBracketsParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpressionWithoutBrackets_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BlockExpressionWithoutBrackets_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionWithoutBracketsRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Expression
protected class OneOrManyExpressions_ExpressionParserRuleCall_1 extends RuleCallToken {
	
	public OneOrManyExpressions_ExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOneOrManyExpressionsAccess().getExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_AssignmentExpressionParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule OneOrManyExpressions ****************/


/************ begin Rule BlockExpressionWithoutBrackets ****************
 *
 * BlockExpressionWithoutBrackets returns be::BExpression:
 *   {be::BChainedExpression} (expressions+=TopLevelExpression ";")+;
 *
 **/

// {be::BChainedExpression} (expressions+=TopLevelExpression ";")+
protected class BlockExpressionWithoutBrackets_Group extends GroupToken {
	
	public BlockExpressionWithoutBrackets_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlockExpressionWithoutBracketsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpressionWithoutBrackets_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionWithoutBracketsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BChainedExpression}
protected class BlockExpressionWithoutBrackets_BChainedExpressionAction_0 extends ActionToken  {

	public BlockExpressionWithoutBrackets_BChainedExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBlockExpressionWithoutBracketsAccess().getBChainedExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionWithoutBracketsAccess().getBChainedExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// (expressions+=TopLevelExpression ";")+
protected class BlockExpressionWithoutBrackets_Group_1 extends GroupToken {
	
	public BlockExpressionWithoutBrackets_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlockExpressionWithoutBracketsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpressionWithoutBrackets_SemicolonKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=TopLevelExpression
protected class BlockExpressionWithoutBrackets_ExpressionsAssignment_1_0 extends AssignmentToken  {
	
	public BlockExpressionWithoutBrackets_ExpressionsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBlockExpressionWithoutBracketsAccess().getExpressionsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TopLevelExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTopLevelExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBlockExpressionWithoutBracketsAccess().getExpressionsTopLevelExpressionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BlockExpressionWithoutBrackets_Group_1(parent, next, actIndex, consumed);
			case 1: return new BlockExpressionWithoutBrackets_BChainedExpressionAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BlockExpressionWithoutBrackets_SemicolonKeyword_1_1 extends KeywordToken  {
	
	public BlockExpressionWithoutBrackets_SemicolonKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionWithoutBracketsAccess().getSemicolonKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpressionWithoutBrackets_ExpressionsAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule BlockExpressionWithoutBrackets ****************/


/************ begin Rule MapEntry ****************
 *
 * MapEntry returns be::BMapEntry:
 *   {be::BMapEntry} key=KeyLiteral ":" value=Expression;
 *
 **/

// {be::BMapEntry} key=KeyLiteral ":" value=Expression
protected class MapEntry_Group extends GroupToken {
	
	public MapEntry_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMapEntryAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MapEntry_ValueAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMapEntryRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BMapEntry}
protected class MapEntry_BMapEntryAction_0 extends ActionToken  {

	public MapEntry_BMapEntryAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getMapEntryAccess().getBMapEntryAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getMapEntryAccess().getBMapEntryAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// key=KeyLiteral
protected class MapEntry_KeyAssignment_1 extends AssignmentToken  {
	
	public MapEntry_KeyAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMapEntryAccess().getKeyAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new KeyLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("key",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("key");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getKeyLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMapEntryAccess().getKeyKeyLiteralParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MapEntry_BMapEntryAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ":"
protected class MapEntry_ColonKeyword_2 extends KeywordToken  {
	
	public MapEntry_ColonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMapEntryAccess().getColonKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MapEntry_KeyAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// value=Expression
protected class MapEntry_ValueAssignment_3 extends AssignmentToken  {
	
	public MapEntry_ValueAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMapEntryAccess().getValueAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMapEntryAccess().getValueExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MapEntry_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule MapEntry ****************/


/************ begin Rule KeyLiteral ****************
 *
 * KeyLiteral returns be::BExpression:
 *   {be::BLiteralExpression} value=( ID | PID | STRING );
 *
 **/

// {be::BLiteralExpression} value=( ID | PID | STRING )
protected class KeyLiteral_Group extends GroupToken {
	
	public KeyLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getKeyLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new KeyLiteral_ValueAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getKeyLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralExpression}
protected class KeyLiteral_BLiteralExpressionAction_0 extends ActionToken  {

	public KeyLiteral_BLiteralExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getKeyLiteralAccess().getBLiteralExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getKeyLiteralAccess().getBLiteralExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// value=( ID | PID | STRING )
protected class KeyLiteral_ValueAssignment_1 extends AssignmentToken  {
	
	public KeyLiteral_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getKeyLiteralAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new KeyLiteral_BLiteralExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getKeyLiteralAccess().getValueIDTerminalRuleCall_1_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getKeyLiteralAccess().getValuePIDTerminalRuleCall_1_0_1();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getKeyLiteralAccess().getValueSTRINGTerminalRuleCall_1_0_2();
			return obj;
		}
		return null;
	}

}


/************ end Rule KeyLiteral ****************/


/************ begin Rule LiteralType ****************
 *
 * LiteralType returns be::BExpression:
 *   {be::BLiteralType} type=TypeRef;
 *
 **/

// {be::BLiteralType} type=TypeRef
protected class LiteralType_Group extends GroupToken {
	
	public LiteralType_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLiteralTypeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralType_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLiteralTypeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralType}
protected class LiteralType_BLiteralTypeAction_0 extends ActionToken  {

	public LiteralType_BLiteralTypeAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getLiteralTypeAccess().getBLiteralTypeAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getLiteralTypeAccess().getBLiteralTypeAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// type=TypeRef
protected class LiteralType_TypeAssignment_1 extends AssignmentToken  {
	
	public LiteralType_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralTypeAccess().getTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLiteralTypeAccess().getTypeTypeRefParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LiteralType_BLiteralTypeAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule LiteralType ****************/


/************ begin Rule ValueLiteral ****************
 *
 * ValueLiteral returns be::BExpression:
 *   BooleanLiteral|RealLiteral|IntegerLiteral|NullLiteral|StringLiteral|UnitLiteral; 
 * 
 *      
 * 	   
 * 	     // SEE ISSUE 297089 - must be placed before IntegerLiteral
 * 	    
 * 	   
 * 	  
 * //	| QueryLiteral
 *
 **/

// BooleanLiteral|RealLiteral|IntegerLiteral|NullLiteral|StringLiteral|UnitLiteral 
// 
//      
// 	   
// 	     // SEE ISSUE 297089 - must be placed before IntegerLiteral
// 	    
// 	   
// 	  
// //	| QueryLiteral
protected class ValueLiteral_Alternatives extends AlternativesToken {

	public ValueLiteral_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueLiteralAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueLiteral_BooleanLiteralParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ValueLiteral_RealLiteralParserRuleCall_1(parent, this, 1, inst);
			case 2: return new ValueLiteral_IntegerLiteralParserRuleCall_2(parent, this, 2, inst);
			case 3: return new ValueLiteral_NullLiteralParserRuleCall_3(parent, this, 3, inst);
			case 4: return new ValueLiteral_StringLiteralParserRuleCall_4(parent, this, 4, inst);
			case 5: return new ValueLiteral_UnitLiteralParserRuleCall_5(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValueLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BooleanLiteral
protected class ValueLiteral_BooleanLiteralParserRuleCall_0 extends RuleCallToken {
	
	public ValueLiteral_BooleanLiteralParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueLiteralAccess().getBooleanLiteralParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RealLiteral      // SEE ISSUE 297089 - must be placed before IntegerLiteral
protected class ValueLiteral_RealLiteralParserRuleCall_1 extends RuleCallToken {
	
	public ValueLiteral_RealLiteralParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueLiteralAccess().getRealLiteralParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RealLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RealLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRealLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// IntegerLiteral
protected class ValueLiteral_IntegerLiteralParserRuleCall_2 extends RuleCallToken {
	
	public ValueLiteral_IntegerLiteralParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueLiteralAccess().getIntegerLiteralParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntegerLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntegerLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntegerLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// NullLiteral
protected class ValueLiteral_NullLiteralParserRuleCall_3 extends RuleCallToken {
	
	public ValueLiteral_NullLiteralParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueLiteralAccess().getNullLiteralParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NullLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNullLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StringLiteral   
// //	| QueryLiteral
protected class ValueLiteral_StringLiteralParserRuleCall_4 extends RuleCallToken {
	
	public ValueLiteral_StringLiteralParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueLiteralAccess().getStringLiteralParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StringLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StringLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStringLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// UnitLiteral
protected class ValueLiteral_UnitLiteralParserRuleCall_5 extends RuleCallToken {
	
	public ValueLiteral_UnitLiteralParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueLiteralAccess().getUnitLiteralParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnitLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnitLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnitLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ValueLiteral ****************/


/************ begin Rule BooleanLiteral ****************
 *
 * BooleanLiteral returns be::BExpression:
 *   {be::BLiteralExpression} value=BooleanValue;
 *
 **/

// {be::BLiteralExpression} value=BooleanValue
protected class BooleanLiteral_Group extends GroupToken {
	
	public BooleanLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_ValueAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralExpression}
protected class BooleanLiteral_BLiteralExpressionAction_0 extends ActionToken  {

	public BooleanLiteral_BLiteralExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getBLiteralExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralAccess().getBLiteralExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// value=BooleanValue
protected class BooleanLiteral_ValueAssignment_1 extends AssignmentToken  {
	
	public BooleanLiteral_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_BLiteralExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getBooleanLiteralAccess().getValueBooleanValueParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule BooleanLiteral ****************/


/************ begin Rule IntegerLiteral ****************
 *
 * IntegerLiteral returns be::BExpression:
 *   {be::BLiteralExpression} value=IntValue;
 *
 **/

// {be::BLiteralExpression} value=IntValue
protected class IntegerLiteral_Group extends GroupToken {
	
	public IntegerLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIntegerLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntegerLiteral_ValueAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntegerLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralExpression}
protected class IntegerLiteral_BLiteralExpressionAction_0 extends ActionToken  {

	public IntegerLiteral_BLiteralExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getIntegerLiteralAccess().getBLiteralExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getIntegerLiteralAccess().getBLiteralExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// value=IntValue
protected class IntegerLiteral_ValueAssignment_1 extends AssignmentToken  {
	
	public IntegerLiteral_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntegerLiteralAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntegerLiteral_BLiteralExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getIntegerLiteralAccess().getValueIntValueParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule IntegerLiteral ****************/


/************ begin Rule UnitLiteral ****************
 *
 * UnitLiteral returns be::BExpression:
 *   {be::BLiteralExpression} value="unit";
 *
 **/

// {be::BLiteralExpression} value="unit"
protected class UnitLiteral_Group extends GroupToken {
	
	public UnitLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnitLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnitLiteral_ValueAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnitLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralExpression}
protected class UnitLiteral_BLiteralExpressionAction_0 extends ActionToken  {

	public UnitLiteral_BLiteralExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnitLiteralAccess().getBLiteralExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnitLiteralAccess().getBLiteralExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// value="unit"
protected class UnitLiteral_ValueAssignment_1 extends AssignmentToken  {
	
	public UnitLiteral_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnitLiteralAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnitLiteral_BLiteralExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("unit".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnitLiteralAccess().getValueUnitKeyword_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule UnitLiteral ****************/


/************ begin Rule StringLiteral ****************
 *
 * StringLiteral returns be::BExpression:
 *   {be::BLiteralExpression} value=STRING;
 *
 **/

// {be::BLiteralExpression} value=STRING
protected class StringLiteral_Group extends GroupToken {
	
	public StringLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStringLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StringLiteral_ValueAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStringLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralExpression}
protected class StringLiteral_BLiteralExpressionAction_0 extends ActionToken  {

	public StringLiteral_BLiteralExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getStringLiteralAccess().getBLiteralExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getStringLiteralAccess().getBLiteralExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// value=STRING
protected class StringLiteral_ValueAssignment_1 extends AssignmentToken  {
	
	public StringLiteral_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringLiteralAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StringLiteral_BLiteralExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule StringLiteral ****************/


/************ begin Rule RealLiteral ****************
 *
 * RealLiteral returns be::BExpression:
 *   {be::BLiteralExpression} value=RealValue;
 *
 **/

// {be::BLiteralExpression} value=RealValue
protected class RealLiteral_Group extends GroupToken {
	
	public RealLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRealLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RealLiteral_ValueAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRealLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralExpression}
protected class RealLiteral_BLiteralExpressionAction_0 extends ActionToken  {

	public RealLiteral_BLiteralExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRealLiteralAccess().getBLiteralExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRealLiteralAccess().getBLiteralExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// value=RealValue
protected class RealLiteral_ValueAssignment_1 extends AssignmentToken  {
	
	public RealLiteral_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRealLiteralAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RealLiteral_BLiteralExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getRealLiteralAccess().getValueRealValueParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule RealLiteral ****************/


/************ begin Rule RegexpLiteral ****************
 *
 * RegexpLiteral returns be::BExpression:
 *   {be::BRegularExpression} pattern=REGULAR_EXPR; 
 * 	
 *         
 * 	    
 * 	
 * 
 * // Note: NullLiteral has a java null value as its value
 *
 **/

// {be::BRegularExpression} pattern=REGULAR_EXPR
protected class RegexpLiteral_Group extends GroupToken {
	
	public RegexpLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegexpLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegexpLiteral_PatternAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRegexpLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BRegularExpression}
protected class RegexpLiteral_BRegularExpressionAction_0 extends ActionToken  {

	public RegexpLiteral_BRegularExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRegexpLiteralAccess().getBRegularExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRegexpLiteralAccess().getBRegularExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// pattern=REGULAR_EXPR
protected class RegexpLiteral_PatternAssignment_1 extends AssignmentToken  {
	
	public RegexpLiteral_PatternAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegexpLiteralAccess().getPatternAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegexpLiteral_BRegularExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("pattern",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("pattern");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRegexpLiteralAccess().getPatternREGULAR_EXPRTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule RegexpLiteral ****************/


/************ begin Rule NullLiteral ****************
 *
 * NullLiteral returns be::BExpression:
 *   {be::BLiteralExpression} "null"; 
 * 
 * // Note: NullLiteral has a java null value as its value
 * 	         
 * 	
 * 	
 * 
 * //ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
 * //SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
 * 
 * // Has conversion rule
 *
 **/

// {be::BLiteralExpression} "null"
protected class NullLiteral_Group extends GroupToken {
	
	public NullLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_NullKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNullLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {be::BLiteralExpression}
protected class NullLiteral_BLiteralExpressionAction_0 extends ActionToken  {

	public NullLiteral_BLiteralExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getBLiteralExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getNullLiteralAccess().getBLiteralExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "null"
protected class NullLiteral_NullKeyword_1 extends KeywordToken  {
	
	public NullLiteral_NullKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getNullKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_BLiteralExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule NullLiteral ****************/





/************ begin Rule ParanthesizedExpression ****************
 *
 * ParanthesizedExpression returns be::BExpression:
 *   "(" Expression ")"; 
 * 	
 *        
 * 	    
 * 		
 * 
 * // Has conversion rule
 *
 **/

// "(" Expression ")"
protected class ParanthesizedExpression_Group extends GroupToken {
	
	public ParanthesizedExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParanthesizedExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesizedExpression_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParanthesizedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class ParanthesizedExpression_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public ParanthesizedExpression_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesizedExpressionAccess().getLeftParenthesisKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Expression
protected class ParanthesizedExpression_ExpressionParserRuleCall_1 extends RuleCallToken {
	
	public ParanthesizedExpression_ExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParanthesizedExpressionAccess().getExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_AssignmentExpressionParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesizedExpression_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParanthesizedExpression_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ParanthesizedExpression_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParanthesizedExpressionAccess().getRightParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParanthesizedExpression_ExpressionParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParanthesizedExpression ****************/













}
