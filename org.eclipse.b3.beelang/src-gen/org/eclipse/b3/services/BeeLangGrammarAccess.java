/*
* generated by Xtext
*/

package org.eclipse.b3.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class BeeLangGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class BeeModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BeeModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cFunctionsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cFunctionsFunctionParserRuleCall_1_0_0 = (RuleCall)cFunctionsAssignment_1_0.eContents().get(0);
		private final Assignment cConcernAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cConcernConcern_NamedParserRuleCall_1_1_0 = (RuleCall)cConcernAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Keyword cPropertiesKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cPropertySetsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cPropertySetsPropertySet_NamedParserRuleCall_1_2_1_0 = (RuleCall)cPropertySetsAssignment_1_2_1.eContents().get(0);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyBuildUnitParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		
		//BeeModel hidden ( WS , SL_COMMENT , ML_COMMENT ):
		//  imports+=Import* (functions+=Function|concern+=Concern_Named|"properties"
		//  propertySets+=PropertySet_Named)* body=BuildUnit?;
		public ParserRule getRule() { return rule; }

		//imports+=Import* (functions+=Function|concern+=Concern_Named|"properties"
		//propertySets+=PropertySet_Named)* body=BuildUnit?
		public Group getGroup() { return cGroup; }

		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }

		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }

		//(functions+=Function|concern+=Concern_Named|"properties" propertySets+=
		//PropertySet_Named)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//functions+=Function
		public Assignment getFunctionsAssignment_1_0() { return cFunctionsAssignment_1_0; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_1_0_0() { return cFunctionsFunctionParserRuleCall_1_0_0; }

		//concern+=Concern_Named
		public Assignment getConcernAssignment_1_1() { return cConcernAssignment_1_1; }

		//Concern_Named
		public RuleCall getConcernConcern_NamedParserRuleCall_1_1_0() { return cConcernConcern_NamedParserRuleCall_1_1_0; }

		//"properties" propertySets+=PropertySet_Named
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"properties"
		public Keyword getPropertiesKeyword_1_2_0() { return cPropertiesKeyword_1_2_0; }

		//propertySets+=PropertySet_Named
		public Assignment getPropertySetsAssignment_1_2_1() { return cPropertySetsAssignment_1_2_1; }

		//PropertySet_Named
		public RuleCall getPropertySetsPropertySet_NamedParserRuleCall_1_2_1_0() { return cPropertySetsPropertySet_NamedParserRuleCall_1_2_1_0; }

		//body=BuildUnit?
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//BuildUnit
		public RuleCall getBodyBuildUnitParserRuleCall_2_0() { return cBodyBuildUnitParserRuleCall_2_0; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3JavaImportAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cReexportAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cReexportReexportKeyword_1_0 = (Keyword)cReexportAssignment_1.eContents().get(0);
		private final Keyword cImportKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cQualifiedNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cQualifiedNameQIDParserRuleCall_3_0 = (RuleCall)cQualifiedNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cAsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cNameAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_4_1_0 = (RuleCall)cNameAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Import returns be::IType:
		//  {be::B3JavaImport} reexport?="reexport"? "import" qualifiedName=QID ("as" name=ID)?
		//  ";"; 
		//
		//        
		//	                 
		//	
		//
		//// Wanted later 
		////Import : (reexport ?='reexport')? 
		////		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
		////	; 
		//
		////JavaImporter 	: qualifiedName=QID ;
		////NativeImporter 	: uriString = STRING ;
		public ParserRule getRule() { return rule; }

		//{be::B3JavaImport} reexport?="reexport"? "import" qualifiedName=QID ("as" name=ID)?
		//";"
		public Group getGroup() { return cGroup; }

		//{be::B3JavaImport}
		public Action getB3JavaImportAction_0() { return cB3JavaImportAction_0; }

		//reexport?="reexport"?
		public Assignment getReexportAssignment_1() { return cReexportAssignment_1; }

		//"reexport"
		public Keyword getReexportReexportKeyword_1_0() { return cReexportReexportKeyword_1_0; }

		//"import"
		public Keyword getImportKeyword_2() { return cImportKeyword_2; }

		//qualifiedName=QID
		public Assignment getQualifiedNameAssignment_3() { return cQualifiedNameAssignment_3; }

		//QID
		public RuleCall getQualifiedNameQIDParserRuleCall_3_0() { return cQualifiedNameQIDParserRuleCall_3_0; }

		//("as" name=ID)?
		public Group getGroup_4() { return cGroup_4; }

		//"as"
		public Keyword getAsKeyword_4_0() { return cAsKeyword_4_0; }

		//name=ID
		public Assignment getNameAssignment_4_1() { return cNameAssignment_4_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_4_1_0() { return cNameIDTerminalRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class BuildUnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuildUnit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuildUnitAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Assignment cExecutionModeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExecutionModeExecutionModeEnumRuleCall_2_0 = (RuleCall)cExecutionModeAssignment_2.eContents().get(0);
		private final Keyword cUnitKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameUnitNameParserRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cVersionKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cVersionAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cVersionVersionLiteralParserRuleCall_5_1_0 = (RuleCall)cVersionAssignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cImplementsKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cImplementsAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cImplementsSimpleTypeRefParserRuleCall_6_1_0 = (RuleCall)cImplementsAssignment_6_1.eContents().get(0);
		private final Group cGroup_6_2 = (Group)cGroup_6.eContents().get(2);
		private final Keyword cCommaKeyword_6_2_0 = (Keyword)cGroup_6_2.eContents().get(0);
		private final Assignment cImplementsAssignment_6_2_1 = (Assignment)cGroup_6_2.eContents().get(1);
		private final RuleCall cImplementsSimpleTypeRefParserRuleCall_6_2_1_0 = (RuleCall)cImplementsAssignment_6_2_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cDefaultKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Keyword cPropertiesKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Assignment cDefaultPropertiesAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cDefaultPropertiesPropertySetParserRuleCall_8_2_0 = (RuleCall)cDefaultPropertiesAssignment_8_2.eContents().get(0);
		private final Alternatives cAlternatives_9 = (Alternatives)cGroup.eContents().get(9);
		private final Group cGroup_9_0 = (Group)cAlternatives_9.eContents().get(0);
		private final Keyword cProvidesKeyword_9_0_0 = (Keyword)cGroup_9_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_0_1 = (Keyword)cGroup_9_0.eContents().get(1);
		private final Group cGroup_9_0_2 = (Group)cGroup_9_0.eContents().get(2);
		private final Assignment cUnitProvidedCapabilitiesAssignment_9_0_2_0 = (Assignment)cGroup_9_0_2.eContents().get(0);
		private final RuleCall cUnitProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_0_2_0_0 = (RuleCall)cUnitProvidedCapabilitiesAssignment_9_0_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_0_2_1 = (Keyword)cGroup_9_0_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_9_0_3 = (Keyword)cGroup_9_0.eContents().get(3);
		private final Group cGroup_9_1 = (Group)cAlternatives_9.eContents().get(1);
		private final Keyword cProvidesKeyword_9_1_0 = (Keyword)cGroup_9_1.eContents().get(0);
		private final Assignment cUnitProvidedCapabilitiesAssignment_9_1_1 = (Assignment)cGroup_9_1.eContents().get(1);
		private final RuleCall cUnitProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_1_0 = (RuleCall)cUnitProvidedCapabilitiesAssignment_9_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_1_2 = (Keyword)cGroup_9_1.eContents().get(2);
		private final Group cGroup_9_2 = (Group)cAlternatives_9.eContents().get(2);
		private final Keyword cRequiresKeyword_9_2_0 = (Keyword)cGroup_9_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_2_1 = (Keyword)cGroup_9_2.eContents().get(1);
		private final Group cGroup_9_2_2 = (Group)cGroup_9_2.eContents().get(2);
		private final Assignment cRequiredCapabilitiesAssignment_9_2_2_0 = (Assignment)cGroup_9_2_2.eContents().get(0);
		private final RuleCall cRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_2_2_0_0 = (RuleCall)cRequiredCapabilitiesAssignment_9_2_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_2_2_1 = (Keyword)cGroup_9_2_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_9_2_3 = (Keyword)cGroup_9_2.eContents().get(3);
		private final Group cGroup_9_3 = (Group)cAlternatives_9.eContents().get(3);
		private final Keyword cRequiresKeyword_9_3_0 = (Keyword)cGroup_9_3.eContents().get(0);
		private final Assignment cRequiredCapabilitiesAssignment_9_3_1 = (Assignment)cGroup_9_3.eContents().get(1);
		private final RuleCall cRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_3_1_0 = (RuleCall)cRequiredCapabilitiesAssignment_9_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_3_2 = (Keyword)cGroup_9_3.eContents().get(2);
		private final Group cGroup_9_4 = (Group)cAlternatives_9.eContents().get(4);
		private final Keyword cEnvKeyword_9_4_0 = (Keyword)cGroup_9_4.eContents().get(0);
		private final Keyword cRequiresKeyword_9_4_1 = (Keyword)cGroup_9_4.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_9_4_2 = (Keyword)cGroup_9_4.eContents().get(2);
		private final Group cGroup_9_4_3 = (Group)cGroup_9_4.eContents().get(3);
		private final Assignment cMetaRequiredCapabilitiesAssignment_9_4_3_0 = (Assignment)cGroup_9_4_3.eContents().get(0);
		private final RuleCall cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_4_3_0_0 = (RuleCall)cMetaRequiredCapabilitiesAssignment_9_4_3_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_4_3_1 = (Keyword)cGroup_9_4_3.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_9_4_4 = (Keyword)cGroup_9_4.eContents().get(4);
		private final Group cGroup_9_5 = (Group)cAlternatives_9.eContents().get(5);
		private final Keyword cEnvKeyword_9_5_0 = (Keyword)cGroup_9_5.eContents().get(0);
		private final Keyword cRequiresKeyword_9_5_1 = (Keyword)cGroup_9_5.eContents().get(1);
		private final Assignment cMetaRequiredCapabilitiesAssignment_9_5_2 = (Assignment)cGroup_9_5.eContents().get(2);
		private final RuleCall cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_5_2_0 = (RuleCall)cMetaRequiredCapabilitiesAssignment_9_5_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_5_3 = (Keyword)cGroup_9_5.eContents().get(3);
		private final Assignment cConcernsAssignment_9_6 = (Assignment)cAlternatives_9.eContents().get(6);
		private final RuleCall cConcernsConcern_NamedParserRuleCall_9_6_0 = (RuleCall)cConcernsAssignment_9_6.eContents().get(0);
		private final Group cGroup_9_7 = (Group)cAlternatives_9.eContents().get(7);
		private final Keyword cSequentialKeyword_9_7_0 = (Keyword)cGroup_9_7.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_7_1 = (Keyword)cGroup_9_7.eContents().get(1);
		private final Assignment cSynchronizationsAssignment_9_7_2 = (Assignment)cGroup_9_7.eContents().get(2);
		private final RuleCall cSynchronizationsSynchronizationParserRuleCall_9_7_2_0 = (RuleCall)cSynchronizationsAssignment_9_7_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9_7_3 = (Keyword)cGroup_9_7.eContents().get(3);
		private final Group cGroup_9_8 = (Group)cAlternatives_9.eContents().get(8);
		private final Keyword cSequentialKeyword_9_8_0 = (Keyword)cGroup_9_8.eContents().get(0);
		private final Assignment cSynchronizationsAssignment_9_8_1 = (Assignment)cGroup_9_8.eContents().get(1);
		private final RuleCall cSynchronizationsSynchronizationParserRuleCall_9_8_1_0 = (RuleCall)cSynchronizationsAssignment_9_8_1.eContents().get(0);
		private final Assignment cFunctionsAssignment_9_9 = (Assignment)cAlternatives_9.eContents().get(9);
		private final RuleCall cFunctionsBuilderParserRuleCall_9_9_0 = (RuleCall)cFunctionsAssignment_9_9.eContents().get(0);
		private final Assignment cFunctionsAssignment_9_10 = (Assignment)cAlternatives_9.eContents().get(10);
		private final RuleCall cFunctionsFunctionParserRuleCall_9_10_0 = (RuleCall)cFunctionsAssignment_9_10.eContents().get(0);
		private final Group cGroup_9_11 = (Group)cAlternatives_9.eContents().get(11);
		private final Keyword cRepositoriesKeyword_9_11_0 = (Keyword)cGroup_9_11.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_11_1 = (Keyword)cGroup_9_11.eContents().get(1);
		private final Assignment cRepositoriesAssignment_9_11_2 = (Assignment)cGroup_9_11.eContents().get(2);
		private final RuleCall cRepositoriesRepositoryConfigurationParserRuleCall_9_11_2_0 = (RuleCall)cRepositoriesAssignment_9_11_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9_11_3 = (Keyword)cGroup_9_11.eContents().get(3);
		private final Group cGroup_9_12 = (Group)cAlternatives_9.eContents().get(12);
		private final Keyword cPropertiesKeyword_9_12_0 = (Keyword)cGroup_9_12.eContents().get(0);
		private final Assignment cPropertySetsAssignment_9_12_1 = (Assignment)cGroup_9_12.eContents().get(1);
		private final RuleCall cPropertySetsPropertySet_NamedParserRuleCall_9_12_1_0 = (RuleCall)cPropertySetsAssignment_9_12_1.eContents().get(0);
		private final Group cGroup_9_13 = (Group)cAlternatives_9.eContents().get(13);
		private final Keyword cContainersKeyword_9_13_0 = (Keyword)cGroup_9_13.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_13_1 = (Keyword)cGroup_9_13.eContents().get(1);
		private final Assignment cContainersAssignment_9_13_2 = (Assignment)cGroup_9_13.eContents().get(2);
		private final RuleCall cContainersContainerConfigurationParserRuleCall_9_13_2_0 = (RuleCall)cContainersAssignment_9_13_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9_13_3 = (Keyword)cGroup_9_13.eContents().get(3);
		private final Keyword cRightCurlyBracketKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//BuildUnit returns build::BuildUnit hidden ( WS , ML_COMMENT , SL_COMMENT ):
		//  {build::BuildUnit} documentation=DOCUMENTATION? executionMode=ExecutionMode? "unit"
		//  name=UnitName? ("version" version=VersionLiteral)? ("implements" implements+=
		//  SimpleTypeRef ("," implements+=SimpleTypeRef)*)? "{" ("default" "properties"
		//  defaultProperties=PropertySet)? ("provides" "{" (unitProvidedCapabilities+=
		//  ProvidedCapability ";")+ "}"|"provides" unitProvidedCapabilities+=
		//  ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=RequiredCapability ";")
		//  + "}"|"requires" requiredCapabilities+=RequiredCapability ";"|"env" "requires" "{" (
		//  metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"env" "requires"
		//  metaRequiredCapabilities+=RequiredCapability ";"|concerns+=Concern_Named|
		//  "sequential" "{" synchronizations+=Synchronization+ "}"|"sequential"
		//  synchronizations+=Synchronization|functions+=Builder|functions+=Function|
		//  "repositories" "{" repositories+=RepositoryConfiguration* "}"|"properties"
		//  propertySets+=PropertySet_Named|"containers" "{" containers+=
		//  ContainerConfiguration* "}")* "}"; 
		//
		//// Wanted later 
		////Import : (reexport ?='reexport')? 
		////		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
		////	; 
		//
		////JavaImporter 	: qualifiedName=QID ;
		////NativeImporter 	: uriString = STRING ;
		//		
		//              
		//	    
		//	    
		//	          
		//		           
		//	
		//			 //-- PROPERTIES
		//			 // goes first, because they may be used in the other clauses. TODO: can probably be relaxed
		//			 // since linking will find them anyway.
		//			 //
		//			            
		//		
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--CONCERNS
		//			       
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--BUILDERS & FUNCTIONS
		//			         			
		//			        			
		//			//-- REPOSITORIES
		public ParserRule getRule() { return rule; }

		//{build::BuildUnit} documentation=DOCUMENTATION? executionMode=ExecutionMode? "unit"
		//name=UnitName? ("version" version=VersionLiteral)? ("implements" implements+=
		//SimpleTypeRef ("," implements+=SimpleTypeRef)*)? "{" ("default" "properties"
		//defaultProperties=PropertySet)? ("provides" "{" (unitProvidedCapabilities+=
		//ProvidedCapability ";")+ "}"|"provides" unitProvidedCapabilities+=
		//ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=RequiredCapability ";")
		//+ "}"|"requires" requiredCapabilities+=RequiredCapability ";"|"env" "requires" "{" (
		//metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"env" "requires"
		//metaRequiredCapabilities+=RequiredCapability ";"|concerns+=Concern_Named|
		//"sequential" "{" synchronizations+=Synchronization+ "}"|"sequential"
		//synchronizations+=Synchronization|functions+=Builder|functions+=Function|
		//"repositories" "{" repositories+=RepositoryConfiguration* "}"|"properties"
		//propertySets+=PropertySet_Named|"containers" "{" containers+=
		//ContainerConfiguration* "}")* "}"   
		//	    
		//	    
		//	          
		//		           
		//	
		//			 //-- PROPERTIES
		//			 // goes first, because they may be used in the other clauses. TODO: can probably be relaxed
		//			 // since linking will find them anyway.
		//			 //
		//			            
		//		
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--CONCERNS
		//			       
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--BUILDERS & FUNCTIONS
		//			         			
		//			        			
		//			//-- REPOSITORIES
		public Group getGroup() { return cGroup; }

		//{build::BuildUnit}
		public Action getBuildUnitAction_0() { return cBuildUnitAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//executionMode=ExecutionMode?
		public Assignment getExecutionModeAssignment_2() { return cExecutionModeAssignment_2; }

		//ExecutionMode
		public RuleCall getExecutionModeExecutionModeEnumRuleCall_2_0() { return cExecutionModeExecutionModeEnumRuleCall_2_0; }

		//"unit"
		public Keyword getUnitKeyword_3() { return cUnitKeyword_3; }

		//name=UnitName?
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }

		//UnitName
		public RuleCall getNameUnitNameParserRuleCall_4_0() { return cNameUnitNameParserRuleCall_4_0; }

		//("version" version=VersionLiteral)?
		public Group getGroup_5() { return cGroup_5; }

		//"version"
		public Keyword getVersionKeyword_5_0() { return cVersionKeyword_5_0; }

		//version=VersionLiteral
		public Assignment getVersionAssignment_5_1() { return cVersionAssignment_5_1; }

		//VersionLiteral
		public RuleCall getVersionVersionLiteralParserRuleCall_5_1_0() { return cVersionVersionLiteralParserRuleCall_5_1_0; }

		//("implements" implements+=SimpleTypeRef ("," implements+=SimpleTypeRef)*)?
		public Group getGroup_6() { return cGroup_6; }

		//"implements"
		public Keyword getImplementsKeyword_6_0() { return cImplementsKeyword_6_0; }

		//implements+=SimpleTypeRef
		public Assignment getImplementsAssignment_6_1() { return cImplementsAssignment_6_1; }

		//SimpleTypeRef
		public RuleCall getImplementsSimpleTypeRefParserRuleCall_6_1_0() { return cImplementsSimpleTypeRefParserRuleCall_6_1_0; }

		//("," implements+=SimpleTypeRef)*
		public Group getGroup_6_2() { return cGroup_6_2; }

		//","
		public Keyword getCommaKeyword_6_2_0() { return cCommaKeyword_6_2_0; }

		//implements+=SimpleTypeRef
		public Assignment getImplementsAssignment_6_2_1() { return cImplementsAssignment_6_2_1; }

		//SimpleTypeRef
		public RuleCall getImplementsSimpleTypeRefParserRuleCall_6_2_1_0() { return cImplementsSimpleTypeRefParserRuleCall_6_2_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_7() { return cLeftCurlyBracketKeyword_7; }

		//("default" "properties" defaultProperties=PropertySet)?
		public Group getGroup_8() { return cGroup_8; }

		//"default"
		public Keyword getDefaultKeyword_8_0() { return cDefaultKeyword_8_0; }

		//"properties"
		public Keyword getPropertiesKeyword_8_1() { return cPropertiesKeyword_8_1; }

		//defaultProperties=PropertySet
		public Assignment getDefaultPropertiesAssignment_8_2() { return cDefaultPropertiesAssignment_8_2; }

		//PropertySet
		public RuleCall getDefaultPropertiesPropertySetParserRuleCall_8_2_0() { return cDefaultPropertiesPropertySetParserRuleCall_8_2_0; }

		//("provides" "{" (unitProvidedCapabilities+=ProvidedCapability ";")+ "}"|"provides"
		//unitProvidedCapabilities+=ProvidedCapability ";"|"requires" "{" (
		//requiredCapabilities+=RequiredCapability ";")+ "}"|"requires" requiredCapabilities
		//+=RequiredCapability ";"|"env" "requires" "{" (metaRequiredCapabilities+=
		//RequiredCapability ";")+ "}"|"env" "requires" metaRequiredCapabilities+=
		//RequiredCapability ";"|concerns+=Concern_Named|"sequential" "{" synchronizations+=
		//Synchronization+ "}"|"sequential" synchronizations+=Synchronization|functions+=
		//Builder|functions+=Function|"repositories" "{" repositories+=
		//RepositoryConfiguration* "}"|"properties" propertySets+=PropertySet_Named|
		//"containers" "{" containers+=ContainerConfiguration* "}")* 
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--CONCERNS
		//			       
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--BUILDERS & FUNCTIONS
		//			         			
		//			        			
		//			//-- REPOSITORIES
		public Alternatives getAlternatives_9() { return cAlternatives_9; }

		//"provides" "{" (unitProvidedCapabilities+=ProvidedCapability ";")+ "}"
		public Group getGroup_9_0() { return cGroup_9_0; }

		//"provides"
		public Keyword getProvidesKeyword_9_0_0() { return cProvidesKeyword_9_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_0_1() { return cLeftCurlyBracketKeyword_9_0_1; }

		//(unitProvidedCapabilities+=ProvidedCapability ";")+
		public Group getGroup_9_0_2() { return cGroup_9_0_2; }

		//unitProvidedCapabilities+=ProvidedCapability
		public Assignment getUnitProvidedCapabilitiesAssignment_9_0_2_0() { return cUnitProvidedCapabilitiesAssignment_9_0_2_0; }

		//ProvidedCapability
		public RuleCall getUnitProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_0_2_0_0() { return cUnitProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_0_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_9_0_2_1() { return cSemicolonKeyword_9_0_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_0_3() { return cRightCurlyBracketKeyword_9_0_3; }

		//"provides" unitProvidedCapabilities+=ProvidedCapability ";"
		public Group getGroup_9_1() { return cGroup_9_1; }

		//"provides"
		public Keyword getProvidesKeyword_9_1_0() { return cProvidesKeyword_9_1_0; }

		//unitProvidedCapabilities+=ProvidedCapability
		public Assignment getUnitProvidedCapabilitiesAssignment_9_1_1() { return cUnitProvidedCapabilitiesAssignment_9_1_1; }

		//ProvidedCapability
		public RuleCall getUnitProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_1_0() { return cUnitProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_9_1_2() { return cSemicolonKeyword_9_1_2; }

		//"requires" "{" (requiredCapabilities+=RequiredCapability ";")+ "}"
		public Group getGroup_9_2() { return cGroup_9_2; }

		//"requires"
		public Keyword getRequiresKeyword_9_2_0() { return cRequiresKeyword_9_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_2_1() { return cLeftCurlyBracketKeyword_9_2_1; }

		//(requiredCapabilities+=RequiredCapability ";")+
		public Group getGroup_9_2_2() { return cGroup_9_2_2; }

		//requiredCapabilities+=RequiredCapability
		public Assignment getRequiredCapabilitiesAssignment_9_2_2_0() { return cRequiredCapabilitiesAssignment_9_2_2_0; }

		//RequiredCapability
		public RuleCall getRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_2_2_0_0() { return cRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_2_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_9_2_2_1() { return cSemicolonKeyword_9_2_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_2_3() { return cRightCurlyBracketKeyword_9_2_3; }

		//"requires" requiredCapabilities+=RequiredCapability ";"
		public Group getGroup_9_3() { return cGroup_9_3; }

		//"requires"
		public Keyword getRequiresKeyword_9_3_0() { return cRequiresKeyword_9_3_0; }

		//requiredCapabilities+=RequiredCapability
		public Assignment getRequiredCapabilitiesAssignment_9_3_1() { return cRequiredCapabilitiesAssignment_9_3_1; }

		//RequiredCapability
		public RuleCall getRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_3_1_0() { return cRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_9_3_2() { return cSemicolonKeyword_9_3_2; }

		//"env" "requires" "{" (metaRequiredCapabilities+=RequiredCapability ";")+ "}"
		public Group getGroup_9_4() { return cGroup_9_4; }

		//"env"
		public Keyword getEnvKeyword_9_4_0() { return cEnvKeyword_9_4_0; }

		//"requires"
		public Keyword getRequiresKeyword_9_4_1() { return cRequiresKeyword_9_4_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_4_2() { return cLeftCurlyBracketKeyword_9_4_2; }

		//(metaRequiredCapabilities+=RequiredCapability ";")+
		public Group getGroup_9_4_3() { return cGroup_9_4_3; }

		//metaRequiredCapabilities+=RequiredCapability
		public Assignment getMetaRequiredCapabilitiesAssignment_9_4_3_0() { return cMetaRequiredCapabilitiesAssignment_9_4_3_0; }

		//RequiredCapability
		public RuleCall getMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_4_3_0_0() { return cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_4_3_0_0; }

		//";"
		public Keyword getSemicolonKeyword_9_4_3_1() { return cSemicolonKeyword_9_4_3_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_4_4() { return cRightCurlyBracketKeyword_9_4_4; }

		//"env" "requires" metaRequiredCapabilities+=RequiredCapability ";"
		public Group getGroup_9_5() { return cGroup_9_5; }

		//"env"
		public Keyword getEnvKeyword_9_5_0() { return cEnvKeyword_9_5_0; }

		//"requires"
		public Keyword getRequiresKeyword_9_5_1() { return cRequiresKeyword_9_5_1; }

		//metaRequiredCapabilities+=RequiredCapability
		public Assignment getMetaRequiredCapabilitiesAssignment_9_5_2() { return cMetaRequiredCapabilitiesAssignment_9_5_2; }

		//RequiredCapability
		public RuleCall getMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_5_2_0() { return cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_5_2_0; }

		//";"
		public Keyword getSemicolonKeyword_9_5_3() { return cSemicolonKeyword_9_5_3; }

		//concerns+=Concern_Named
		public Assignment getConcernsAssignment_9_6() { return cConcernsAssignment_9_6; }

		//Concern_Named
		public RuleCall getConcernsConcern_NamedParserRuleCall_9_6_0() { return cConcernsConcern_NamedParserRuleCall_9_6_0; }

		//"sequential" "{" synchronizations+=Synchronization+ "}"
		public Group getGroup_9_7() { return cGroup_9_7; }

		//"sequential"
		public Keyword getSequentialKeyword_9_7_0() { return cSequentialKeyword_9_7_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_7_1() { return cLeftCurlyBracketKeyword_9_7_1; }

		//synchronizations+=Synchronization+
		public Assignment getSynchronizationsAssignment_9_7_2() { return cSynchronizationsAssignment_9_7_2; }

		//Synchronization
		public RuleCall getSynchronizationsSynchronizationParserRuleCall_9_7_2_0() { return cSynchronizationsSynchronizationParserRuleCall_9_7_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_7_3() { return cRightCurlyBracketKeyword_9_7_3; }

		//"sequential" synchronizations+=Synchronization
		public Group getGroup_9_8() { return cGroup_9_8; }

		//"sequential"
		public Keyword getSequentialKeyword_9_8_0() { return cSequentialKeyword_9_8_0; }

		//synchronizations+=Synchronization
		public Assignment getSynchronizationsAssignment_9_8_1() { return cSynchronizationsAssignment_9_8_1; }

		//Synchronization
		public RuleCall getSynchronizationsSynchronizationParserRuleCall_9_8_1_0() { return cSynchronizationsSynchronizationParserRuleCall_9_8_1_0; }

		//functions+=Builder
		public Assignment getFunctionsAssignment_9_9() { return cFunctionsAssignment_9_9; }

		//Builder
		public RuleCall getFunctionsBuilderParserRuleCall_9_9_0() { return cFunctionsBuilderParserRuleCall_9_9_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_9_10() { return cFunctionsAssignment_9_10; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_9_10_0() { return cFunctionsFunctionParserRuleCall_9_10_0; }

		//"repositories" "{" repositories+=RepositoryConfiguration* "}"
		public Group getGroup_9_11() { return cGroup_9_11; }

		//"repositories"
		public Keyword getRepositoriesKeyword_9_11_0() { return cRepositoriesKeyword_9_11_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_11_1() { return cLeftCurlyBracketKeyword_9_11_1; }

		//repositories+=RepositoryConfiguration*
		public Assignment getRepositoriesAssignment_9_11_2() { return cRepositoriesAssignment_9_11_2; }

		//RepositoryConfiguration
		public RuleCall getRepositoriesRepositoryConfigurationParserRuleCall_9_11_2_0() { return cRepositoriesRepositoryConfigurationParserRuleCall_9_11_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_11_3() { return cRightCurlyBracketKeyword_9_11_3; }

		//"properties" propertySets+=PropertySet_Named
		public Group getGroup_9_12() { return cGroup_9_12; }

		//"properties"
		public Keyword getPropertiesKeyword_9_12_0() { return cPropertiesKeyword_9_12_0; }

		//propertySets+=PropertySet_Named
		public Assignment getPropertySetsAssignment_9_12_1() { return cPropertySetsAssignment_9_12_1; }

		//PropertySet_Named
		public RuleCall getPropertySetsPropertySet_NamedParserRuleCall_9_12_1_0() { return cPropertySetsPropertySet_NamedParserRuleCall_9_12_1_0; }

		//"containers" "{" containers+=ContainerConfiguration* "}"
		public Group getGroup_9_13() { return cGroup_9_13; }

		//"containers"
		public Keyword getContainersKeyword_9_13_0() { return cContainersKeyword_9_13_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_13_1() { return cLeftCurlyBracketKeyword_9_13_1; }

		//containers+=ContainerConfiguration*
		public Assignment getContainersAssignment_9_13_2() { return cContainersAssignment_9_13_2; }

		//ContainerConfiguration
		public RuleCall getContainersContainerConfigurationParserRuleCall_9_13_2_0() { return cContainersContainerConfigurationParserRuleCall_9_13_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_13_3() { return cRightCurlyBracketKeyword_9_13_3; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_10() { return cRightCurlyBracketKeyword_10; }
	}

	public class ProvidedCapabilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProvidedCapability");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVersionedCapabilityAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cWhenKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cCondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cCondExprExpressionParserRuleCall_1_2_0 = (RuleCall)cCondExprAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cNameSpaceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSpaceInterfaceNameParserRuleCall_2_0 = (RuleCall)cNameSpaceAssignment_2.eContents().get(0);
		private final Keyword cSolidusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameCapabilityNameParserRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cSolidusKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cVersionAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cVersionVersionLiteralParserRuleCall_5_1_0 = (RuleCall)cVersionAssignment_5_1.eContents().get(0);
		
		//ProvidedCapability returns build::VersionedCapability:
		//  {build::VersionedCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
		//  InterfaceName "/" name=CapabilityName ("/" version=VersionLiteral)?; 
		//
		//        
		//	        
		//	     
		//	    
		//	
		//	
		//// Capability required by a unit - always refers to capabilities with at least ns/name
		public ParserRule getRule() { return rule; }

		//{build::VersionedCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
		//InterfaceName "/" name=CapabilityName ("/" version=VersionLiteral)?
		public Group getGroup() { return cGroup; }

		//{build::VersionedCapability}
		public Action getVersionedCapabilityAction_0() { return cVersionedCapabilityAction_0; }

		//("when" "(" condExpr=Expression ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"when"
		public Keyword getWhenKeyword_1_0() { return cWhenKeyword_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_1_2() { return cCondExprAssignment_1_2; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_1_2_0() { return cCondExprExpressionParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }

		//nameSpace=InterfaceName
		public Assignment getNameSpaceAssignment_2() { return cNameSpaceAssignment_2; }

		//InterfaceName
		public RuleCall getNameSpaceInterfaceNameParserRuleCall_2_0() { return cNameSpaceInterfaceNameParserRuleCall_2_0; }

		//"/"
		public Keyword getSolidusKeyword_3() { return cSolidusKeyword_3; }

		//name=CapabilityName
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }

		//CapabilityName
		public RuleCall getNameCapabilityNameParserRuleCall_4_0() { return cNameCapabilityNameParserRuleCall_4_0; }

		//("/" version=VersionLiteral)?
		public Group getGroup_5() { return cGroup_5; }

		//"/"
		public Keyword getSolidusKeyword_5_0() { return cSolidusKeyword_5_0; }

		//version=VersionLiteral
		public Assignment getVersionAssignment_5_1() { return cVersionAssignment_5_1; }

		//VersionLiteral
		public RuleCall getVersionVersionLiteralParserRuleCall_5_1_0() { return cVersionVersionLiteralParserRuleCall_5_1_0; }
	}

	public class RequiredCapabilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RequiredCapability");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRequiredCapabilityAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cWhenKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cCondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cCondExprExpressionParserRuleCall_1_2_0 = (RuleCall)cCondExprAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cNameSpaceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameSpaceInterfaceNameParserRuleCall_2_0 = (RuleCall)cNameSpaceAssignment_2.eContents().get(0);
		private final Keyword cSolidusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameCapabilityNameParserRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cSolidusKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cVersionRangeAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cVersionRangeVersionRangeLiteralParserRuleCall_5_1_0 = (RuleCall)cVersionRangeAssignment_5_1.eContents().get(0);
		
		//RequiredCapability returns build::RequiredCapability:
		//  {build::RequiredCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
		//  InterfaceName "/" name=CapabilityName ("/" versionRange=VersionRangeLiteral)?; 
		//	
		//// Capability required by a unit - always refers to capabilities with at least ns/name
		public ParserRule getRule() { return rule; }

		//{build::RequiredCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
		//InterfaceName "/" name=CapabilityName ("/" versionRange=VersionRangeLiteral)?
		public Group getGroup() { return cGroup; }

		//{build::RequiredCapability}
		public Action getRequiredCapabilityAction_0() { return cRequiredCapabilityAction_0; }

		//("when" "(" condExpr=Expression ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"when"
		public Keyword getWhenKeyword_1_0() { return cWhenKeyword_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_1_2() { return cCondExprAssignment_1_2; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_1_2_0() { return cCondExprExpressionParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }

		//nameSpace=InterfaceName
		public Assignment getNameSpaceAssignment_2() { return cNameSpaceAssignment_2; }

		//InterfaceName
		public RuleCall getNameSpaceInterfaceNameParserRuleCall_2_0() { return cNameSpaceInterfaceNameParserRuleCall_2_0; }

		//"/"
		public Keyword getSolidusKeyword_3() { return cSolidusKeyword_3; }

		//name=CapabilityName
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }

		//CapabilityName
		public RuleCall getNameCapabilityNameParserRuleCall_4_0() { return cNameCapabilityNameParserRuleCall_4_0; }

		//("/" versionRange=VersionRangeLiteral)?
		public Group getGroup_5() { return cGroup_5; }

		//"/"
		public Keyword getSolidusKeyword_5_0() { return cSolidusKeyword_5_0; }

		//versionRange=VersionRangeLiteral
		public Assignment getVersionRangeAssignment_5_1() { return cVersionRangeAssignment_5_1; }

		//VersionRangeLiteral
		public RuleCall getVersionRangeVersionRangeLiteralParserRuleCall_5_1_0() { return cVersionRangeVersionRangeLiteralParserRuleCall_5_1_0; }
	}

	public class RequiredCapability_UnfilteredElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RequiredCapability_Unfiltered");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRequiredCapabilityAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cNameSpaceAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cNameSpaceInterfaceNameParserRuleCall_1_0_0 = (RuleCall)cNameSpaceAssignment_1_0.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameCapabilityNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cSolidusKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cVersionRangeAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cVersionRangeVersionRangeLiteralParserRuleCall_3_1_0 = (RuleCall)cVersionRangeAssignment_3_1.eContents().get(0);
		
		//RequiredCapability_Unfiltered returns build::RequiredCapability:
		//  {build::RequiredCapability} (nameSpace=InterfaceName "/")? name=CapabilityName ("/"
		//  versionRange=VersionRangeLiteral)?; 
		//	
		//         
		//	     
		//	    
		//	
		//	
		//// An optionally named sequence of property statements
		public ParserRule getRule() { return rule; }

		//{build::RequiredCapability} (nameSpace=InterfaceName "/")? name=CapabilityName ("/"
		//versionRange=VersionRangeLiteral)?
		public Group getGroup() { return cGroup; }

		//{build::RequiredCapability}
		public Action getRequiredCapabilityAction_0() { return cRequiredCapabilityAction_0; }

		//(nameSpace=InterfaceName "/")?
		public Group getGroup_1() { return cGroup_1; }

		//nameSpace=InterfaceName
		public Assignment getNameSpaceAssignment_1_0() { return cNameSpaceAssignment_1_0; }

		//InterfaceName
		public RuleCall getNameSpaceInterfaceNameParserRuleCall_1_0_0() { return cNameSpaceInterfaceNameParserRuleCall_1_0_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }

		//name=CapabilityName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//CapabilityName
		public RuleCall getNameCapabilityNameParserRuleCall_2_0() { return cNameCapabilityNameParserRuleCall_2_0; }

		//("/" versionRange=VersionRangeLiteral)?
		public Group getGroup_3() { return cGroup_3; }

		//"/"
		public Keyword getSolidusKeyword_3_0() { return cSolidusKeyword_3_0; }

		//versionRange=VersionRangeLiteral
		public Assignment getVersionRangeAssignment_3_1() { return cVersionRangeAssignment_3_1; }

		//VersionRangeLiteral
		public RuleCall getVersionRangeVersionRangeLiteralParserRuleCall_3_1_0() { return cVersionRangeVersionRangeLiteralParserRuleCall_3_1_0; }
	}

	public class PropertySet_NamedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertySet_Named");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBPropertySetAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cExtendsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExtendsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cExtendsBPropertySetCrossReference_2_1_0 = (CrossReference)cExtendsAssignment_2_1.eContents().get(0);
		private final RuleCall cExtendsBPropertySetQIDREFParserRuleCall_2_1_0_1 = (RuleCall)cExtendsBPropertySetCrossReference_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cOperationsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOperationsPropertyOperationParserRuleCall_4_0 = (RuleCall)cOperationsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//PropertySet_Named returns be::BPropertySet:
		//  {be::BPropertySet} name=ID ("extends" extends=[be::BPropertySet|QIDREF])? "{"
		//  operations+=PropertyOperation* "}"; 
		//	
		//// An optionally named sequence of property statements
		//         
		//	                         
		//	
		//
		//// Sequence of possibly filtered property statements
		public ParserRule getRule() { return rule; }

		//{be::BPropertySet} name=ID ("extends" extends=[be::BPropertySet|QIDREF])? "{"
		//operations+=PropertyOperation* "}"
		public Group getGroup() { return cGroup; }

		//{be::BPropertySet}
		public Action getBPropertySetAction_0() { return cBPropertySetAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//("extends" extends=[be::BPropertySet|QIDREF])?
		public Group getGroup_2() { return cGroup_2; }

		//"extends"
		public Keyword getExtendsKeyword_2_0() { return cExtendsKeyword_2_0; }

		//extends=[be::BPropertySet|QIDREF]
		public Assignment getExtendsAssignment_2_1() { return cExtendsAssignment_2_1; }

		//[be::BPropertySet|QIDREF]
		public CrossReference getExtendsBPropertySetCrossReference_2_1_0() { return cExtendsBPropertySetCrossReference_2_1_0; }

		//QIDREF
		public RuleCall getExtendsBPropertySetQIDREFParserRuleCall_2_1_0_1() { return cExtendsBPropertySetQIDREFParserRuleCall_2_1_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//operations+=PropertyOperation*
		public Assignment getOperationsAssignment_4() { return cOperationsAssignment_4; }

		//PropertyOperation
		public RuleCall getOperationsPropertyOperationParserRuleCall_4_0() { return cOperationsPropertyOperationParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class PropertySetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertySet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBPropertySetAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cExtendsKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExtendsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cExtendsBPropertySetCrossReference_1_1_0 = (CrossReference)cExtendsAssignment_1_1.eContents().get(0);
		private final RuleCall cExtendsBPropertySetQIDREFParserRuleCall_1_1_0_1 = (RuleCall)cExtendsBPropertySetCrossReference_1_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOperationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOperationsPropertyOperationParserRuleCall_3_0 = (RuleCall)cOperationsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PropertySet returns be::BPropertySet:
		//  {be::BPropertySet} ("extends" extends=[be::BPropertySet|QIDREF])? "{" operations+=
		//  PropertyOperation* "}"; 
		//
		//// Sequence of possibly filtered property statements	
		//         
		//	                    
		//	
		//
		//// For model generation, to get supertype correct
		public ParserRule getRule() { return rule; }

		//{be::BPropertySet} ("extends" extends=[be::BPropertySet|QIDREF])? "{" operations+=
		//PropertyOperation* "}"
		public Group getGroup() { return cGroup; }

		//{be::BPropertySet}
		public Action getBPropertySetAction_0() { return cBPropertySetAction_0; }

		//("extends" extends=[be::BPropertySet|QIDREF])?
		public Group getGroup_1() { return cGroup_1; }

		//"extends"
		public Keyword getExtendsKeyword_1_0() { return cExtendsKeyword_1_0; }

		//extends=[be::BPropertySet|QIDREF]
		public Assignment getExtendsAssignment_1_1() { return cExtendsAssignment_1_1; }

		//[be::BPropertySet|QIDREF]
		public CrossReference getExtendsBPropertySetCrossReference_1_1_0() { return cExtendsBPropertySetCrossReference_1_1_0; }

		//QIDREF
		public RuleCall getExtendsBPropertySetQIDREFParserRuleCall_1_1_0_1() { return cExtendsBPropertySetQIDREFParserRuleCall_1_1_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//operations+=PropertyOperation*
		public Assignment getOperationsAssignment_3() { return cOperationsAssignment_3; }

		//PropertyOperation
		public RuleCall getOperationsPropertyOperationParserRuleCall_3_0() { return cOperationsPropertyOperationParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class PropertyOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConditionalPropertyOperationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPropertyDefinitionOperationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPropertySetOperationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PropertyOperation returns be::BPropertyOperation:
		//  ConditionalPropertyOperation|PropertyDefinitionOperation|PropertySetOperation; 
		//
		//// For model generation, to get supertype correct
		public ParserRule getRule() { return rule; }

		//ConditionalPropertyOperation|PropertyDefinitionOperation|PropertySetOperation 
		//
		//// For model generation, to get supertype correct
		public Alternatives getAlternatives() { return cAlternatives; }

		//ConditionalPropertyOperation
		public RuleCall getConditionalPropertyOperationParserRuleCall_0() { return cConditionalPropertyOperationParserRuleCall_0; }

		//PropertyDefinitionOperation
		public RuleCall getPropertyDefinitionOperationParserRuleCall_1() { return cPropertyDefinitionOperationParserRuleCall_1; }

		//PropertySetOperation
		public RuleCall getPropertySetOperationParserRuleCall_2() { return cPropertySetOperationParserRuleCall_2; }
	}

	public class ConditionalPropertyOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalPropertyOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBConditionalPropertyOperationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCondExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCondExprExpressionParserRuleCall_3_0 = (RuleCall)cCondExprAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cBodyAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cBodyPropertyDefinitionOperationParserRuleCall_5_0_0 = (RuleCall)cBodyAssignment_5_0.eContents().get(0);
		private final Assignment cBodyAssignment_5_1 = (Assignment)cAlternatives_5.eContents().get(1);
		private final RuleCall cBodyPropertySetOperationParserRuleCall_5_1_0 = (RuleCall)cBodyAssignment_5_1.eContents().get(0);
		
		//ConditionalPropertyOperation returns be::BPropertyOperation:
		//  {be::BConditionalPropertyOperation} "when" "(" condExpr=Expression ")" (body=
		//  PropertyDefinitionOperation|body=PropertySetOperation);
		public ParserRule getRule() { return rule; }

		//{be::BConditionalPropertyOperation} "when" "(" condExpr=Expression ")" (body=
		//PropertyDefinitionOperation|body=PropertySetOperation)
		public Group getGroup() { return cGroup; }

		//{be::BConditionalPropertyOperation}
		public Action getBConditionalPropertyOperationAction_0() { return cBConditionalPropertyOperationAction_0; }

		//"when"
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_3() { return cCondExprAssignment_3; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_3_0() { return cCondExprExpressionParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//body=PropertyDefinitionOperation|body=PropertySetOperation
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//body=PropertyDefinitionOperation
		public Assignment getBodyAssignment_5_0() { return cBodyAssignment_5_0; }

		//PropertyDefinitionOperation
		public RuleCall getBodyPropertyDefinitionOperationParserRuleCall_5_0_0() { return cBodyPropertyDefinitionOperationParserRuleCall_5_0_0; }

		//body=PropertySetOperation
		public Assignment getBodyAssignment_5_1() { return cBodyAssignment_5_1; }

		//PropertySetOperation
		public RuleCall getBodyPropertySetOperationParserRuleCall_5_1_0() { return cBodyPropertySetOperationParserRuleCall_5_1_0; }
	}

	public class PropertyDefinitionOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyDefinitionOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBPropertyDefinitionOperationAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cDefinitionAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cDefinitionPropertyValDeclarationParserRuleCall_1_0_0 = (RuleCall)cDefinitionAssignment_1_0.eContents().get(0);
		private final Assignment cDefinitionAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cDefinitionPropertyVarDeclarationParserRuleCall_1_1_0 = (RuleCall)cDefinitionAssignment_1_1.eContents().get(0);
		
		//PropertyDefinitionOperation returns be::BPropertyOperation:
		//  {be::BPropertyDefinitionOperation} (definition=PropertyValDeclaration|definition=
		//  PropertyVarDeclaration); 
		//        
		//	            
		//	
		//		
		//// property values, must be assigned (but can be assigned null).
		public ParserRule getRule() { return rule; }

		//{be::BPropertyDefinitionOperation} (definition=PropertyValDeclaration|definition=
		//PropertyVarDeclaration)
		public Group getGroup() { return cGroup; }

		//{be::BPropertyDefinitionOperation}
		public Action getBPropertyDefinitionOperationAction_0() { return cBPropertyDefinitionOperationAction_0; }

		//definition=PropertyValDeclaration|definition=PropertyVarDeclaration
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//definition=PropertyValDeclaration
		public Assignment getDefinitionAssignment_1_0() { return cDefinitionAssignment_1_0; }

		//PropertyValDeclaration
		public RuleCall getDefinitionPropertyValDeclarationParserRuleCall_1_0_0() { return cDefinitionPropertyValDeclarationParserRuleCall_1_0_0; }

		//definition=PropertyVarDeclaration
		public Assignment getDefinitionAssignment_1_1() { return cDefinitionAssignment_1_1; }

		//PropertyVarDeclaration
		public RuleCall getDefinitionPropertyVarDeclarationParserRuleCall_1_1_0() { return cDefinitionPropertyVarDeclarationParserRuleCall_1_1_0; }
	}

	public class PropertyValDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyValDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefPropertyAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFinalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFinalFinalKeyword_1_0 = (Keyword)cFinalAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeRefParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNamePIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueExprAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueExprExpressionParserRuleCall_5_0 = (RuleCall)cValueExprAssignment_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//PropertyValDeclaration returns be::BDefProperty:
		//  {be::BDefProperty} final?="final"? type=TypeRef? name=PID "=" valueExpr=Expression ";"
		//; 
		//		
		//// property values, must be assigned (but can be assigned null).
		//         
		//	                    
		//	
		//	
		//// property variables, value optionally assigned
		public ParserRule getRule() { return rule; }

		//{be::BDefProperty} final?="final"? type=TypeRef? name=PID "=" valueExpr=Expression ";"
		public Group getGroup() { return cGroup; }

		//{be::BDefProperty}
		public Action getBDefPropertyAction_0() { return cBDefPropertyAction_0; }

		//final?="final"?
		public Assignment getFinalAssignment_1() { return cFinalAssignment_1; }

		//"final"
		public Keyword getFinalFinalKeyword_1_0() { return cFinalFinalKeyword_1_0; }

		//type=TypeRef?
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_2_0() { return cTypeTypeRefParserRuleCall_2_0; }

		//name=PID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_3_0() { return cNamePIDTerminalRuleCall_3_0; }

		//"="
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_5() { return cValueExprAssignment_5; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_5_0() { return cValueExprExpressionParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class PropertyVarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyVarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefPropertyAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFinalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFinalFinalKeyword_1_0 = (Keyword)cFinalAssignment_1.eContents().get(0);
		private final Assignment cMutableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cMutableMutableKeyword_2_0 = (Keyword)cMutableAssignment_2.eContents().get(0);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeRefParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNamePIDTerminalRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cValueExprAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cValueExprExpressionParserRuleCall_5_1_0 = (RuleCall)cValueExprAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//PropertyVarDeclaration returns be::BDefProperty:
		//  {be::BDefProperty} final?="final"? mutable?="mutable" type=TypeRef? name=PID ("="
		//  valueExpr=Expression)? ";"; 
		//	
		//// property variables, value optionally assigned
		public ParserRule getRule() { return rule; }

		//{be::BDefProperty} final?="final"? mutable?="mutable" type=TypeRef? name=PID ("="
		//valueExpr=Expression)? ";"
		public Group getGroup() { return cGroup; }

		//{be::BDefProperty}
		public Action getBDefPropertyAction_0() { return cBDefPropertyAction_0; }

		//final?="final"?
		public Assignment getFinalAssignment_1() { return cFinalAssignment_1; }

		//"final"
		public Keyword getFinalFinalKeyword_1_0() { return cFinalFinalKeyword_1_0; }

		//mutable?="mutable"
		public Assignment getMutableAssignment_2() { return cMutableAssignment_2; }

		//"mutable"
		public Keyword getMutableMutableKeyword_2_0() { return cMutableMutableKeyword_2_0; }

		//type=TypeRef?
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_3_0() { return cTypeTypeRefParserRuleCall_3_0; }

		//name=PID
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_4_0() { return cNamePIDTerminalRuleCall_4_0; }

		//("=" valueExpr=Expression)?
		public Group getGroup_5() { return cGroup_5; }

		//"="
		public Keyword getEqualsSignKeyword_5_0() { return cEqualsSignKeyword_5_0; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_5_1() { return cValueExprAssignment_5_1; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_5_1_0() { return cValueExprExpressionParserRuleCall_5_1_0; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class PropertySetOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertySetOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBPropertySetOperationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPropertySetAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPropertySetPropertySetParserRuleCall_1_0 = (RuleCall)cPropertySetAssignment_1.eContents().get(0);
		
		//PropertySetOperation returns be::BPropertyOperation:
		//  {be::BPropertySetOperation} propertySet=PropertySet;
		public ParserRule getRule() { return rule; }

		//{be::BPropertySetOperation} propertySet=PropertySet
		public Group getGroup() { return cGroup; }

		//{be::BPropertySetOperation}
		public Action getBPropertySetOperationAction_0() { return cBPropertySetOperationAction_0; }

		//propertySet=PropertySet
		public Assignment getPropertySetAssignment_1() { return cPropertySetAssignment_1; }

		//PropertySet
		public RuleCall getPropertySetPropertySetParserRuleCall_1_0() { return cPropertySetPropertySetParserRuleCall_1_0; }
	}

	public class SynchronizationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Synchronization");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSynchronizationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBuildersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBuildersSynchronizedBuilderParserRuleCall_1_0 = (RuleCall)cBuildersAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cBuildersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cBuildersSynchronizedBuilderParserRuleCall_2_1_0 = (RuleCall)cBuildersAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Synchronization returns build::Synchronization:
		//  {build::Synchronization} builders+=SynchronizedBuilder ("," builders+=
		//  SynchronizedBuilder)+ ";"; 
		//
		//        
		//	            
		//	
		//
		//// TODO: This is really a builder reference (which could be reused/refactored)
		public ParserRule getRule() { return rule; }

		//{build::Synchronization} builders+=SynchronizedBuilder ("," builders+=
		//SynchronizedBuilder)+ ";"
		public Group getGroup() { return cGroup; }

		//{build::Synchronization}
		public Action getSynchronizationAction_0() { return cSynchronizationAction_0; }

		//builders+=SynchronizedBuilder
		public Assignment getBuildersAssignment_1() { return cBuildersAssignment_1; }

		//SynchronizedBuilder
		public RuleCall getBuildersSynchronizedBuilderParserRuleCall_1_0() { return cBuildersSynchronizedBuilderParserRuleCall_1_0; }

		//("," builders+=SynchronizedBuilder)+
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//builders+=SynchronizedBuilder
		public Assignment getBuildersAssignment_2_1() { return cBuildersAssignment_2_1; }

		//SynchronizedBuilder
		public RuleCall getBuildersSynchronizedBuilderParserRuleCall_2_1_0() { return cBuildersSynchronizedBuilderParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class SynchronizedBuilderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SynchronizedBuilder");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cSynchronizedBuilderAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cNameSpaceAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameSpaceEscapedQualifiedNameParserRuleCall_0_1_0 = (RuleCall)cNameSpaceAssignment_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cNameAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cNameEscapedQualifiedNameParserRuleCall_0_3_0 = (RuleCall)cNameAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cNumberSignKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cBuilderNameAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cBuilderNameBuilderNameParserRuleCall_0_4_1_0 = (RuleCall)cBuilderNameAssignment_0_4_1.eContents().get(0);
		private final Assignment cBuilderNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cBuilderNameBuilderNameParserRuleCall_1_0 = (RuleCall)cBuilderNameAssignment_1.eContents().get(0);
		
		//SynchronizedBuilder returns build::SynchronizedBuilder:
		//  {build::SynchronizedBuilder} nameSpace=EscapedQualifiedName "/" name=
		//  EscapedQualifiedName ("#" builderName=BuilderName)?|builderName=BuilderName; 
		//
		//// TODO: This is really a builder reference (which could be reused/refactored)
		public ParserRule getRule() { return rule; }

		//{build::SynchronizedBuilder} nameSpace=EscapedQualifiedName "/" name=
		//EscapedQualifiedName ("#" builderName=BuilderName)?|builderName=BuilderName 
		//
		//// TODO: This is really a builder reference (which could be reused/refactored)
		public Alternatives getAlternatives() { return cAlternatives; }

		//{build::SynchronizedBuilder} nameSpace=EscapedQualifiedName "/" name=
		//EscapedQualifiedName ("#" builderName=BuilderName)?
		public Group getGroup_0() { return cGroup_0; }

		//{build::SynchronizedBuilder}
		public Action getSynchronizedBuilderAction_0_0() { return cSynchronizedBuilderAction_0_0; }

		//nameSpace=EscapedQualifiedName
		public Assignment getNameSpaceAssignment_0_1() { return cNameSpaceAssignment_0_1; }

		//EscapedQualifiedName
		public RuleCall getNameSpaceEscapedQualifiedNameParserRuleCall_0_1_0() { return cNameSpaceEscapedQualifiedNameParserRuleCall_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_0_2() { return cSolidusKeyword_0_2; }

		//name=EscapedQualifiedName
		public Assignment getNameAssignment_0_3() { return cNameAssignment_0_3; }

		//EscapedQualifiedName
		public RuleCall getNameEscapedQualifiedNameParserRuleCall_0_3_0() { return cNameEscapedQualifiedNameParserRuleCall_0_3_0; }

		//("#" builderName=BuilderName)?
		public Group getGroup_0_4() { return cGroup_0_4; }

		//"#"
		public Keyword getNumberSignKeyword_0_4_0() { return cNumberSignKeyword_0_4_0; }

		//builderName=BuilderName
		public Assignment getBuilderNameAssignment_0_4_1() { return cBuilderNameAssignment_0_4_1; }

		//BuilderName
		public RuleCall getBuilderNameBuilderNameParserRuleCall_0_4_1_0() { return cBuilderNameBuilderNameParserRuleCall_0_4_1_0; }

		//builderName=BuilderName
		public Assignment getBuilderNameAssignment_1() { return cBuilderNameAssignment_1; }

		//BuilderName
		public RuleCall getBuilderNameBuilderNameParserRuleCall_1_0() { return cBuilderNameBuilderNameParserRuleCall_1_0; }
	}

	public class PathGroupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPathGroupAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPathVectorsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathVectorsPathVectorParserRuleCall_1_0 = (RuleCall)cPathVectorsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cAnnotationsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAnnotationsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAnnotationsPropertySetParserRuleCall_2_1_0 = (RuleCall)cAnnotationsAssignment_2_1.eContents().get(0);
		
		//PathGroup returns build::PathGroup:
		//  {build::PathGroup} pathVectors+=PathVector+ ("annotations" annotations=PropertySet)
		//  ?;
		public ParserRule getRule() { return rule; }

		//{build::PathGroup} pathVectors+=PathVector+ ("annotations" annotations=PropertySet)
		//?
		public Group getGroup() { return cGroup; }

		//{build::PathGroup}
		public Action getPathGroupAction_0() { return cPathGroupAction_0; }

		//pathVectors+=PathVector+
		public Assignment getPathVectorsAssignment_1() { return cPathVectorsAssignment_1; }

		//PathVector
		public RuleCall getPathVectorsPathVectorParserRuleCall_1_0() { return cPathVectorsPathVectorParserRuleCall_1_0; }

		//("annotations" annotations=PropertySet)?
		public Group getGroup_2() { return cGroup_2; }

		//"annotations"
		public Keyword getAnnotationsKeyword_2_0() { return cAnnotationsKeyword_2_0; }

		//annotations=PropertySet
		public Assignment getAnnotationsAssignment_2_1() { return cAnnotationsAssignment_2_1; }

		//PropertySet
		public RuleCall getAnnotationsPropertySetParserRuleCall_2_1_0() { return cAnnotationsPropertySetParserRuleCall_2_1_0; }
	}

	public class PathVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathVector");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasePathVectorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnbasedPathVectorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCompoundPathVectorParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PathVector returns build::PathVector:
		//  BasePathVector|UnbasedPathVector|CompoundPathVector;
		public ParserRule getRule() { return rule; }

		//BasePathVector|UnbasedPathVector|CompoundPathVector
		public Alternatives getAlternatives() { return cAlternatives; }

		//BasePathVector
		public RuleCall getBasePathVectorParserRuleCall_0() { return cBasePathVectorParserRuleCall_0; }

		//UnbasedPathVector
		public RuleCall getUnbasedPathVectorParserRuleCall_1() { return cUnbasedPathVectorParserRuleCall_1; }

		//CompoundPathVector
		public RuleCall getCompoundPathVectorParserRuleCall_2() { return cCompoundPathVectorParserRuleCall_2; }
	}

	public class BasePathVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasePathVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPathVectorElementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cWhenKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cCondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cCondExprExpressionParserRuleCall_1_2_0 = (RuleCall)cCondExprAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cBasePathAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBasePathPathParserRuleCall_2_0 = (RuleCall)cBasePathAssignment_2.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cPathsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cPathsPathParserRuleCall_4_0_0 = (RuleCall)cPathsAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cPathsAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cPathsPathParserRuleCall_4_1_1_0 = (RuleCall)cPathsAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//BasePathVector returns build::PathVector:
		//  {build::PathVectorElement} ("when" "(" condExpr=Expression ")")? basePath=Path "[" (
		//  paths+=Path ("," paths+=Path)*)? "]" ";";
		public ParserRule getRule() { return rule; }

		//{build::PathVectorElement} ("when" "(" condExpr=Expression ")")? basePath=Path "[" (
		//paths+=Path ("," paths+=Path)*)? "]" ";"
		public Group getGroup() { return cGroup; }

		//{build::PathVectorElement}
		public Action getPathVectorElementAction_0() { return cPathVectorElementAction_0; }

		//("when" "(" condExpr=Expression ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"when"
		public Keyword getWhenKeyword_1_0() { return cWhenKeyword_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_1_2() { return cCondExprAssignment_1_2; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_1_2_0() { return cCondExprExpressionParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }

		//basePath=Path
		public Assignment getBasePathAssignment_2() { return cBasePathAssignment_2; }

		//Path
		public RuleCall getBasePathPathParserRuleCall_2_0() { return cBasePathPathParserRuleCall_2_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_3() { return cLeftSquareBracketKeyword_3; }

		//(paths+=Path ("," paths+=Path)*)?
		public Group getGroup_4() { return cGroup_4; }

		//paths+=Path
		public Assignment getPathsAssignment_4_0() { return cPathsAssignment_4_0; }

		//Path
		public RuleCall getPathsPathParserRuleCall_4_0_0() { return cPathsPathParserRuleCall_4_0_0; }

		//("," paths+=Path)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//paths+=Path
		public Assignment getPathsAssignment_4_1_1() { return cPathsAssignment_4_1_1; }

		//Path
		public RuleCall getPathsPathParserRuleCall_4_1_1_0() { return cPathsPathParserRuleCall_4_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class UnbasedPathVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnbasedPathVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPathVectorElementAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cWhenKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cCondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cCondExprExpressionParserRuleCall_1_2_0 = (RuleCall)cCondExprAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cPathsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPathsPathParserRuleCall_2_0 = (RuleCall)cPathsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cPathsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cPathsPathParserRuleCall_3_1_0 = (RuleCall)cPathsAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//UnbasedPathVector returns build::PathVector:
		//  {build::PathVectorElement} ("when" "(" condExpr=Expression ")")? paths+=Path ("," paths
		//  +=Path)* ";";
		public ParserRule getRule() { return rule; }

		//{build::PathVectorElement} ("when" "(" condExpr=Expression ")")? paths+=Path ("," paths
		//+=Path)* ";"
		public Group getGroup() { return cGroup; }

		//{build::PathVectorElement}
		public Action getPathVectorElementAction_0() { return cPathVectorElementAction_0; }

		//("when" "(" condExpr=Expression ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"when"
		public Keyword getWhenKeyword_1_0() { return cWhenKeyword_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_1_2() { return cCondExprAssignment_1_2; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_1_2_0() { return cCondExprExpressionParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }

		//paths+=Path
		public Assignment getPathsAssignment_2() { return cPathsAssignment_2; }

		//Path
		public RuleCall getPathsPathParserRuleCall_2_0() { return cPathsPathParserRuleCall_2_0; }

		//("," paths+=Path)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//paths+=Path
		public Assignment getPathsAssignment_3_1() { return cPathsAssignment_3_1; }

		//Path
		public RuleCall getPathsPathParserRuleCall_3_1_0() { return cPathsPathParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class CompoundPathVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundPathVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCompoundPathVectorAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCondExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCondExprExpressionParserRuleCall_3_0 = (RuleCall)cCondExprAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cPathVectorsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cPathVectorsPathVectorParserRuleCall_6_0 = (RuleCall)cPathVectorsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//CompoundPathVector returns build::PathVector:
		//  {build::CompoundPathVector} "when" "(" condExpr=Expression ")" "{" pathVectors+=
		//  PathVector* "}"; 
		//	
		//        
		//	      
		//	         
		//	
		//
		//// A path can be written without quotes if it consists of safe chars
		public ParserRule getRule() { return rule; }

		//{build::CompoundPathVector} "when" "(" condExpr=Expression ")" "{" pathVectors+=
		//PathVector* "}"
		public Group getGroup() { return cGroup; }

		//{build::CompoundPathVector}
		public Action getCompoundPathVectorAction_0() { return cCompoundPathVectorAction_0; }

		//"when"
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_3() { return cCondExprAssignment_3; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_3_0() { return cCondExprExpressionParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }

		//pathVectors+=PathVector*
		public Assignment getPathVectorsAssignment_6() { return cPathVectorsAssignment_6; }

		//PathVector
		public RuleCall getPathVectorsPathVectorParserRuleCall_6_0() { return cPathVectorsPathVectorParserRuleCall_6_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Path");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cQIDParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cSolidusKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final RuleCall cQIDParserRuleCall_1_2_1 = (RuleCall)cGroup_1_2.eContents().get(1);
		private final Keyword cSolidusKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Path returns ecore::EString hidden ( ):
		//  STRING|"/"? QID ("/" QID)* "/"?; 
		//
		//// A path can be written without quotes if it consists of safe chars
		public ParserRule getRule() { return rule; }

		//STRING|"/"? QID ("/" QID)* "/"? 
		//
		//// A path can be written without quotes if it consists of safe chars
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//"/"? QID ("/" QID)* "/"?
		public Group getGroup_1() { return cGroup_1; }

		//"/"?
		public Keyword getSolidusKeyword_1_0() { return cSolidusKeyword_1_0; }

		//QID
		public RuleCall getQIDParserRuleCall_1_1() { return cQIDParserRuleCall_1_1; }

		//("/" QID)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"/"
		public Keyword getSolidusKeyword_1_2_0() { return cSolidusKeyword_1_2_0; }

		//QID
		public RuleCall getQIDParserRuleCall_1_2_1() { return cQIDParserRuleCall_1_2_1; }

		//"/"?
		public Keyword getSolidusKeyword_1_3() { return cSolidusKeyword_1_3; }
	}

	public class PrerequisiteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Prerequisite");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPrerequisiteAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cWhenKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cCondExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cCondExprExpressionParserRuleCall_1_2_0 = (RuleCall)cCondExprAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cWithExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cWithExprWithClauseParserRuleCall_2_0 = (RuleCall)cWithExprAssignment_2.eContents().get(0);
		private final Assignment cBuildResultAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBuildResultBuildResultReferenceParserRuleCall_3_0 = (RuleCall)cBuildResultAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cAsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cAliasAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cAliasIDTerminalRuleCall_4_1_0 = (RuleCall)cAliasAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Prerequisite returns build::Prerequisite:
		//  {build::Prerequisite} ("when" "(" condExpr=Expression ")")? withExpr=WithClause?
		//  buildResult=BuildResultReference ("as" alias=ID)? ";"; 
		//
		//         
		//	        
		//	    
		//	
		//	    
		//	
		//
		//// Validation checks that there is at least one of references, properties or concern.
		public ParserRule getRule() { return rule; }

		//{build::Prerequisite} ("when" "(" condExpr=Expression ")")? withExpr=WithClause?
		//buildResult=BuildResultReference ("as" alias=ID)? ";"
		public Group getGroup() { return cGroup; }

		//{build::Prerequisite}
		public Action getPrerequisiteAction_0() { return cPrerequisiteAction_0; }

		//("when" "(" condExpr=Expression ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"when"
		public Keyword getWhenKeyword_1_0() { return cWhenKeyword_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_1_2() { return cCondExprAssignment_1_2; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_1_2_0() { return cCondExprExpressionParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }

		//withExpr=WithClause?
		public Assignment getWithExprAssignment_2() { return cWithExprAssignment_2; }

		//WithClause
		public RuleCall getWithExprWithClauseParserRuleCall_2_0() { return cWithExprWithClauseParserRuleCall_2_0; }

		//buildResult=BuildResultReference
		public Assignment getBuildResultAssignment_3() { return cBuildResultAssignment_3; }

		//BuildResultReference
		public RuleCall getBuildResultBuildResultReferenceParserRuleCall_3_0() { return cBuildResultBuildResultReferenceParserRuleCall_3_0; }

		//("as" alias=ID)?
		public Group getGroup_4() { return cGroup_4; }

		//"as"
		public Keyword getAsKeyword_4_0() { return cAsKeyword_4_0; }

		//alias=ID
		public Assignment getAliasAssignment_4_1() { return cAliasAssignment_4_1; }

		//ID
		public RuleCall getAliasIDTerminalRuleCall_4_1_0() { return cAliasIDTerminalRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class WithClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WithClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBWithExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWithKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cReferencedAdviceAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cReferencedAdviceBAdviceCrossReference_2_1_0 = (CrossReference)cReferencedAdviceAssignment_2_1.eContents().get(0);
		private final RuleCall cReferencedAdviceBAdviceIDTerminalRuleCall_2_1_0_1 = (RuleCall)cReferencedAdviceBAdviceCrossReference_2_1_0.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cReferencedAdviceAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final CrossReference cReferencedAdviceBAdviceCrossReference_2_2_1_0 = (CrossReference)cReferencedAdviceAssignment_2_2_1.eContents().get(0);
		private final RuleCall cReferencedAdviceBAdviceIDTerminalRuleCall_2_2_1_0_1 = (RuleCall)cReferencedAdviceBAdviceCrossReference_2_2_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cPropertiesKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cPropertySetsAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cPropertySetsPropertySetParserRuleCall_3_0_1_0 = (RuleCall)cPropertySetsAssignment_3_0_1.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Keyword cConcernKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cConcernsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cConcernsConcern_AnonymousParserRuleCall_3_1_1_0 = (RuleCall)cConcernsAssignment_3_1_1.eContents().get(0);
		
		//WithClause returns be::BWithExpression:
		//  {be::BWithExpression} "with" ("(" referencedAdvice+=[be::BAdvice] (","
		//  referencedAdvice+=[be::BAdvice])* ")")? ("properties" propertySets+=PropertySet|
		//  "concern" concerns+=Concern_Anonymous)*; 
		//
		//// Validation checks that there is at least one of references, properties or concern.
		public ParserRule getRule() { return rule; }

		//{be::BWithExpression} "with" ("(" referencedAdvice+=[be::BAdvice] (","
		//referencedAdvice+=[be::BAdvice])* ")")? ("properties" propertySets+=PropertySet|
		//"concern" concerns+=Concern_Anonymous)*
		public Group getGroup() { return cGroup; }

		//{be::BWithExpression}
		public Action getBWithExpressionAction_0() { return cBWithExpressionAction_0; }

		//"with"
		public Keyword getWithKeyword_1() { return cWithKeyword_1; }

		//("(" referencedAdvice+=[be::BAdvice] ("," referencedAdvice+=[be::BAdvice])* ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//referencedAdvice+=[be::BAdvice]
		public Assignment getReferencedAdviceAssignment_2_1() { return cReferencedAdviceAssignment_2_1; }

		//[be::BAdvice]
		public CrossReference getReferencedAdviceBAdviceCrossReference_2_1_0() { return cReferencedAdviceBAdviceCrossReference_2_1_0; }

		//ID
		public RuleCall getReferencedAdviceBAdviceIDTerminalRuleCall_2_1_0_1() { return cReferencedAdviceBAdviceIDTerminalRuleCall_2_1_0_1; }

		//("," referencedAdvice+=[be::BAdvice])*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//referencedAdvice+=[be::BAdvice]
		public Assignment getReferencedAdviceAssignment_2_2_1() { return cReferencedAdviceAssignment_2_2_1; }

		//[be::BAdvice]
		public CrossReference getReferencedAdviceBAdviceCrossReference_2_2_1_0() { return cReferencedAdviceBAdviceCrossReference_2_2_1_0; }

		//ID
		public RuleCall getReferencedAdviceBAdviceIDTerminalRuleCall_2_2_1_0_1() { return cReferencedAdviceBAdviceIDTerminalRuleCall_2_2_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }

		//("properties" propertySets+=PropertySet|"concern" concerns+=Concern_Anonymous)*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//"properties" propertySets+=PropertySet
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"properties"
		public Keyword getPropertiesKeyword_3_0_0() { return cPropertiesKeyword_3_0_0; }

		//propertySets+=PropertySet
		public Assignment getPropertySetsAssignment_3_0_1() { return cPropertySetsAssignment_3_0_1; }

		//PropertySet
		public RuleCall getPropertySetsPropertySetParserRuleCall_3_0_1_0() { return cPropertySetsPropertySetParserRuleCall_3_0_1_0; }

		//"concern" concerns+=Concern_Anonymous
		public Group getGroup_3_1() { return cGroup_3_1; }

		//"concern"
		public Keyword getConcernKeyword_3_1_0() { return cConcernKeyword_3_1_0; }

		//concerns+=Concern_Anonymous
		public Assignment getConcernsAssignment_3_1_1() { return cConcernsAssignment_3_1_1; }

		//Concern_Anonymous
		public RuleCall getConcernsConcern_AnonymousParserRuleCall_3_1_1_0() { return cConcernsConcern_AnonymousParserRuleCall_3_1_1_0; }
	}

	public class BuildResultReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuildResultReference");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnitBuildResultReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCapabilityBuildResultReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCompoundBuildResultReferenceParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//BuildResultReference returns build::BuildResultReference:
		//  UnitBuildResultReference|CapabilityBuildResultReference|
		//  CompoundBuildResultReference;
		public ParserRule getRule() { return rule; }

		//UnitBuildResultReference|CapabilityBuildResultReference|
		//CompoundBuildResultReference
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnitBuildResultReference
		public RuleCall getUnitBuildResultReferenceParserRuleCall_0() { return cUnitBuildResultReferenceParserRuleCall_0; }

		//CapabilityBuildResultReference
		public RuleCall getCapabilityBuildResultReferenceParserRuleCall_1() { return cCapabilityBuildResultReferenceParserRuleCall_1; }

		//CompoundBuildResultReference
		public RuleCall getCompoundBuildResultReferenceParserRuleCall_2() { return cCompoundBuildResultReferenceParserRuleCall_2; }
	}

	public class UnitBuildResultReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitBuildResultReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuilderReferenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cUnitKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cNumberSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBuilderNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBuilderNameBuilderNameParserRuleCall_3_0 = (RuleCall)cBuilderNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cParametersAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cParametersParameterListParserRuleCall_4_1_0 = (RuleCall)cParametersAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//UnitBuildResultReference returns build::BuildResultReference:
		//  {build::BuilderReference} "unit"? "#" builderName=BuilderName ("(" parameters=
		//  ParameterList ")")?;
		public ParserRule getRule() { return rule; }

		//{build::BuilderReference} "unit"? "#" builderName=BuilderName ("(" parameters=
		//ParameterList ")")?
		public Group getGroup() { return cGroup; }

		//{build::BuilderReference}
		public Action getBuilderReferenceAction_0() { return cBuilderReferenceAction_0; }

		//"unit"?
		public Keyword getUnitKeyword_1() { return cUnitKeyword_1; }

		//"#"
		public Keyword getNumberSignKeyword_2() { return cNumberSignKeyword_2; }

		//builderName=BuilderName
		public Assignment getBuilderNameAssignment_3() { return cBuilderNameAssignment_3; }

		//BuilderName
		public RuleCall getBuilderNameBuilderNameParserRuleCall_3_0() { return cBuilderNameBuilderNameParserRuleCall_3_0; }

		//("(" parameters=ParameterList ")")?
		public Group getGroup_4() { return cGroup_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }

		//parameters=ParameterList
		public Assignment getParametersAssignment_4_1() { return cParametersAssignment_4_1; }

		//ParameterList
		public RuleCall getParametersParameterListParserRuleCall_4_1_0() { return cParametersParameterListParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}

	public class CapabilityBuildResultReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CapabilityBuildResultReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuilderReferenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cRequiredCapabilityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRequiredCapabilityRequiredCapability_UnfilteredParserRuleCall_1_0 = (RuleCall)cRequiredCapabilityAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cNumberSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cBuilderNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cBuilderNameBuilderNameParserRuleCall_2_1_0 = (RuleCall)cBuilderNameAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParametersAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParametersParameterListParserRuleCall_3_1_0 = (RuleCall)cParametersAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		
		//CapabilityBuildResultReference returns build::BuildResultReference:
		//  {build::BuilderReference} requiredCapability=RequiredCapability_Unfiltered ("#"
		//  builderName=BuilderName)? ("(" parameters=ParameterList ")")?;
		public ParserRule getRule() { return rule; }

		//{build::BuilderReference} requiredCapability=RequiredCapability_Unfiltered ("#"
		//builderName=BuilderName)? ("(" parameters=ParameterList ")")?
		public Group getGroup() { return cGroup; }

		//{build::BuilderReference}
		public Action getBuilderReferenceAction_0() { return cBuilderReferenceAction_0; }

		//requiredCapability=RequiredCapability_Unfiltered
		public Assignment getRequiredCapabilityAssignment_1() { return cRequiredCapabilityAssignment_1; }

		//RequiredCapability_Unfiltered
		public RuleCall getRequiredCapabilityRequiredCapability_UnfilteredParserRuleCall_1_0() { return cRequiredCapabilityRequiredCapability_UnfilteredParserRuleCall_1_0; }

		//("#" builderName=BuilderName)?
		public Group getGroup_2() { return cGroup_2; }

		//"#"
		public Keyword getNumberSignKeyword_2_0() { return cNumberSignKeyword_2_0; }

		//builderName=BuilderName
		public Assignment getBuilderNameAssignment_2_1() { return cBuilderNameAssignment_2_1; }

		//BuilderName
		public RuleCall getBuilderNameBuilderNameParserRuleCall_2_1_0() { return cBuilderNameBuilderNameParserRuleCall_2_1_0; }

		//("(" parameters=ParameterList ")")?
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//parameters=ParameterList
		public Assignment getParametersAssignment_3_1() { return cParametersAssignment_3_1; }

		//ParameterList
		public RuleCall getParametersParameterListParserRuleCall_3_1_0() { return cParametersParameterListParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }
	}

	public class CompoundBuildResultReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundBuildResultReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCompoundBuildResultReferenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPrerequisitesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPrerequisitesPrerequisiteParserRuleCall_2_0 = (RuleCall)cPrerequisitesAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//CompoundBuildResultReference returns build::BuildResultReference:
		//  {build::CompoundBuildResultReference} "{" prerequisites+=Prerequisite* "}";
		public ParserRule getRule() { return rule; }

		//{build::CompoundBuildResultReference} "{" prerequisites+=Prerequisite* "}"
		public Group getGroup() { return cGroup; }

		//{build::CompoundBuildResultReference}
		public Action getCompoundBuildResultReferenceAction_0() { return cCompoundBuildResultReferenceAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//prerequisites+=Prerequisite*
		public Assignment getPrerequisitesAssignment_2() { return cPrerequisitesAssignment_2; }

		//Prerequisite
		public RuleCall getPrerequisitesPrerequisiteParserRuleCall_2_0() { return cPrerequisitesPrerequisiteParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class BuilderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Builder");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuilderAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Assignment cVisibilityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVisibilityVisibilityEnumRuleCall_2_0 = (RuleCall)cVisibilityAssignment_2.eContents().get(0);
		private final Assignment cExecutionModeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExecutionModeExecutionModeEnumRuleCall_3_0 = (RuleCall)cExecutionModeAssignment_3.eContents().get(0);
		private final Assignment cFinalAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cFinalFinalKeyword_4_0 = (Keyword)cFinalAssignment_4.eContents().get(0);
		private final Keyword cBuilderKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cNameAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cNameBuilderNameParserRuleCall_6_0 = (RuleCall)cNameAssignment_6.eContents().get(0);
		private final Alternatives cAlternatives_7 = (Alternatives)cGroup.eContents().get(7);
		private final Group cGroup_7_0 = (Group)cAlternatives_7.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_7_0_0 = (Keyword)cGroup_7_0.eContents().get(0);
		private final Group cGroup_7_0_1 = (Group)cGroup_7_0.eContents().get(1);
		private final Assignment cParametersAssignment_7_0_1_0 = (Assignment)cGroup_7_0_1.eContents().get(0);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_7_0_1_0_0 = (RuleCall)cParametersAssignment_7_0_1_0.eContents().get(0);
		private final Group cGroup_7_0_1_1 = (Group)cGroup_7_0_1.eContents().get(1);
		private final Keyword cCommaKeyword_7_0_1_1_0 = (Keyword)cGroup_7_0_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_7_0_1_1_1 = (Assignment)cGroup_7_0_1_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_7_0_1_1_1_0 = (RuleCall)cParametersAssignment_7_0_1_1_1.eContents().get(0);
		private final Group cGroup_7_0_1_2 = (Group)cGroup_7_0_1.eContents().get(2);
		private final Keyword cCommaKeyword_7_0_1_2_0 = (Keyword)cGroup_7_0_1_2.eContents().get(0);
		private final Assignment cVarArgsAssignment_7_0_1_2_1 = (Assignment)cGroup_7_0_1_2.eContents().get(1);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_7_0_1_2_1_0 = (Keyword)cVarArgsAssignment_7_0_1_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_7_0_1_2_2 = (Assignment)cGroup_7_0_1_2.eContents().get(2);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_7_0_1_2_2_0 = (RuleCall)cParametersAssignment_7_0_1_2_2.eContents().get(0);
		private final Group cGroup_7_1 = (Group)cAlternatives_7.eContents().get(1);
		private final Group cGroup_7_1_0 = (Group)cGroup_7_1.eContents().get(0);
		private final Assignment cVarArgsAssignment_7_1_0_0 = (Assignment)cGroup_7_1_0.eContents().get(0);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_7_1_0_0_0 = (Keyword)cVarArgsAssignment_7_1_0_0.eContents().get(0);
		private final Assignment cParametersAssignment_7_1_0_1 = (Assignment)cGroup_7_1_0.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_7_1_0_1_0 = (RuleCall)cParametersAssignment_7_1_0_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7_1_1 = (Keyword)cGroup_7_1.eContents().get(1);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cWhenKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cGuardAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cGuardGuardExpressionParserRuleCall_8_1_0 = (RuleCall)cGuardAssignment_8_1.eContents().get(0);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cProvidesKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cProvidedCapabilitiesAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_0 = (RuleCall)cProvidedCapabilitiesAssignment_9_1.eContents().get(0);
		private final Group cGroup_9_2 = (Group)cGroup_9.eContents().get(2);
		private final Keyword cCommaKeyword_9_2_0 = (Keyword)cGroup_9_2.eContents().get(0);
		private final Assignment cProvidedCapabilitiesAssignment_9_2_1 = (Assignment)cGroup_9_2.eContents().get(1);
		private final RuleCall cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_2_1_0 = (RuleCall)cProvidedCapabilitiesAssignment_9_2_1.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cPreconditionKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Alternatives cAlternatives_10_1 = (Alternatives)cGroup_10.eContents().get(1);
		private final Group cGroup_10_1_0 = (Group)cAlternatives_10_1.eContents().get(0);
		private final Keyword cColonKeyword_10_1_0_0 = (Keyword)cGroup_10_1_0.eContents().get(0);
		private final Assignment cPrecondExprAssignment_10_1_0_1 = (Assignment)cGroup_10_1_0.eContents().get(1);
		private final RuleCall cPrecondExprExpressionParserRuleCall_10_1_0_1_0 = (RuleCall)cPrecondExprAssignment_10_1_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_10_1_0_2 = (Keyword)cGroup_10_1_0.eContents().get(2);
		private final Assignment cPrecondExprAssignment_10_1_1 = (Assignment)cAlternatives_10_1.eContents().get(1);
		private final RuleCall cPrecondExprBlockExpressionParserRuleCall_10_1_1_0 = (RuleCall)cPrecondExprAssignment_10_1_1.eContents().get(0);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cPostconditionKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Alternatives cAlternatives_11_1 = (Alternatives)cGroup_11.eContents().get(1);
		private final Group cGroup_11_1_0 = (Group)cAlternatives_11_1.eContents().get(0);
		private final Keyword cColonKeyword_11_1_0_0 = (Keyword)cGroup_11_1_0.eContents().get(0);
		private final Assignment cPostcondExprAssignment_11_1_0_1 = (Assignment)cGroup_11_1_0.eContents().get(1);
		private final RuleCall cPostcondExprExpressionParserRuleCall_11_1_0_1_0 = (RuleCall)cPostcondExprAssignment_11_1_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_11_1_0_2 = (Keyword)cGroup_11_1_0.eContents().get(2);
		private final Assignment cPostcondExprAssignment_11_1_1 = (Assignment)cAlternatives_11_1.eContents().get(1);
		private final RuleCall cPostcondExprBlockExpressionParserRuleCall_11_1_1_0 = (RuleCall)cPostcondExprAssignment_11_1_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final Group cGroup_13 = (Group)cGroup.eContents().get(13);
		private final Keyword cDefaultKeyword_13_0 = (Keyword)cGroup_13.eContents().get(0);
		private final Keyword cPropertiesKeyword_13_1 = (Keyword)cGroup_13.eContents().get(1);
		private final Assignment cDefaultPropertiesAssignment_13_2 = (Assignment)cGroup_13.eContents().get(2);
		private final RuleCall cDefaultPropertiesPropertySetParserRuleCall_13_2_0 = (RuleCall)cDefaultPropertiesAssignment_13_2.eContents().get(0);
		private final Assignment cInputAssignment_14 = (Assignment)cGroup.eContents().get(14);
		private final RuleCall cInputBuilderInputParserRuleCall_14_0 = (RuleCall)cInputAssignment_14.eContents().get(0);
		private final Group cGroup_15 = (Group)cGroup.eContents().get(15);
		private final Keyword cOutputKeyword_15_0 = (Keyword)cGroup_15.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_15_1 = (Keyword)cGroup_15.eContents().get(1);
		private final Assignment cOutputAssignment_15_2 = (Assignment)cGroup_15.eContents().get(2);
		private final RuleCall cOutputPathGroupParserRuleCall_15_2_0 = (RuleCall)cOutputAssignment_15_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_15_3 = (Keyword)cGroup_15.eContents().get(3);
		private final Assignment cFuncExprAssignment_16 = (Assignment)cGroup.eContents().get(16);
		private final RuleCall cFuncExprBlockExpressionWithoutBracketsParserRuleCall_16_0 = (RuleCall)cFuncExprAssignment_16.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_17 = (Keyword)cGroup.eContents().get(17);
		
		//Builder returns build::Builder:
		//  {build::Builder} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
		//  ExecutionMode? final?="final"? "builder" name=BuilderName ("(" (parameters+=
		//  ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
		//  parameters+=ParameterDeclaration)?)|(varArgs?="..." parameters+=
		//  ParameterDeclaration) ")")? ("when" guard=GuardExpression)? ("provides"
		//  providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
		//  ProvidedCapability)*)? ("precondition" (":" precondExpr=Expression ";"|precondExpr=
		//  BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=
		//  BlockExpression))? "{" ("default" "properties" defaultProperties=PropertySet)? input=
		//  BuilderInput? ("output" "{" output=PathGroup "}")? funcExpr=
		//  BlockExpressionWithoutBrackets? "}"; 
		//	
		//        
		//	     
		//	    
		//        
		//  	    
		////	(cached ?= "cached")?
		public ParserRule getRule() { return rule; }

		//{build::Builder} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
		//ExecutionMode? final?="final"? "builder" name=BuilderName ("(" (parameters+=
		//ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
		//parameters+=ParameterDeclaration)?)|(varArgs?="..." parameters+=
		//ParameterDeclaration) ")")? ("when" guard=GuardExpression)? ("provides"
		//providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
		//ProvidedCapability)*)? ("precondition" (":" precondExpr=Expression ";"|precondExpr=
		//BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=
		//BlockExpression))? "{" ("default" "properties" defaultProperties=PropertySet)? input=
		//BuilderInput? ("output" "{" output=PathGroup "}")? funcExpr=
		//BlockExpressionWithoutBrackets? "}"   
		//	     
		//	    
		//        
		//  	    
		////	(cached ?= "cached")?
		public Group getGroup() { return cGroup; }

		//{build::Builder}
		public Action getBuilderAction_0() { return cBuilderAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//visibility=Visibility?
		public Assignment getVisibilityAssignment_2() { return cVisibilityAssignment_2; }

		//Visibility
		public RuleCall getVisibilityVisibilityEnumRuleCall_2_0() { return cVisibilityVisibilityEnumRuleCall_2_0; }

		//executionMode=ExecutionMode?
		public Assignment getExecutionModeAssignment_3() { return cExecutionModeAssignment_3; }

		//ExecutionMode
		public RuleCall getExecutionModeExecutionModeEnumRuleCall_3_0() { return cExecutionModeExecutionModeEnumRuleCall_3_0; }

		//final?="final"?
		public Assignment getFinalAssignment_4() { return cFinalAssignment_4; }

		//"final"
		public Keyword getFinalFinalKeyword_4_0() { return cFinalFinalKeyword_4_0; }

		//"builder" 
		////	(cached ?= "cached")?
		public Keyword getBuilderKeyword_5() { return cBuilderKeyword_5; }

		//name=BuilderName
		public Assignment getNameAssignment_6() { return cNameAssignment_6; }

		//BuilderName
		public RuleCall getNameBuilderNameParserRuleCall_6_0() { return cNameBuilderNameParserRuleCall_6_0; }

		//("(" (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
		//varArgs?="..." parameters+=ParameterDeclaration)?)|(varArgs?="..." parameters+=
		//ParameterDeclaration) ")")?
		public Alternatives getAlternatives_7() { return cAlternatives_7; }

		//"(" (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
		//varArgs?="..." parameters+=ParameterDeclaration)?)
		public Group getGroup_7_0() { return cGroup_7_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_7_0_0() { return cLeftParenthesisKeyword_7_0_0; }

		//parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
		//varArgs?="..." parameters+=ParameterDeclaration)?
		public Group getGroup_7_0_1() { return cGroup_7_0_1; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_7_0_1_0() { return cParametersAssignment_7_0_1_0; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_7_0_1_0_0() { return cParametersParameterDeclarationParserRuleCall_7_0_1_0_0; }

		//("," parameters+=ParameterDeclaration)*
		public Group getGroup_7_0_1_1() { return cGroup_7_0_1_1; }

		//","
		public Keyword getCommaKeyword_7_0_1_1_0() { return cCommaKeyword_7_0_1_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_7_0_1_1_1() { return cParametersAssignment_7_0_1_1_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_7_0_1_1_1_0() { return cParametersParameterDeclarationParserRuleCall_7_0_1_1_1_0; }

		//("," varArgs?="..." parameters+=ParameterDeclaration)?
		public Group getGroup_7_0_1_2() { return cGroup_7_0_1_2; }

		//","
		public Keyword getCommaKeyword_7_0_1_2_0() { return cCommaKeyword_7_0_1_2_0; }

		//varArgs?="..."
		public Assignment getVarArgsAssignment_7_0_1_2_1() { return cVarArgsAssignment_7_0_1_2_1; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_7_0_1_2_1_0() { return cVarArgsFullStopFullStopFullStopKeyword_7_0_1_2_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_7_0_1_2_2() { return cParametersAssignment_7_0_1_2_2; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_7_0_1_2_2_0() { return cParametersParameterDeclarationParserRuleCall_7_0_1_2_2_0; }

		//(varArgs?="..." parameters+=ParameterDeclaration) ")"
		public Group getGroup_7_1() { return cGroup_7_1; }

		//varArgs?="..." parameters+=ParameterDeclaration
		public Group getGroup_7_1_0() { return cGroup_7_1_0; }

		//varArgs?="..."
		public Assignment getVarArgsAssignment_7_1_0_0() { return cVarArgsAssignment_7_1_0_0; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_7_1_0_0_0() { return cVarArgsFullStopFullStopFullStopKeyword_7_1_0_0_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_7_1_0_1() { return cParametersAssignment_7_1_0_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_7_1_0_1_0() { return cParametersParameterDeclarationParserRuleCall_7_1_0_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7_1_1() { return cRightParenthesisKeyword_7_1_1; }

		//("when" guard=GuardExpression)?
		public Group getGroup_8() { return cGroup_8; }

		//"when"
		public Keyword getWhenKeyword_8_0() { return cWhenKeyword_8_0; }

		//guard=GuardExpression
		public Assignment getGuardAssignment_8_1() { return cGuardAssignment_8_1; }

		//GuardExpression
		public RuleCall getGuardGuardExpressionParserRuleCall_8_1_0() { return cGuardGuardExpressionParserRuleCall_8_1_0; }

		//("provides" providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
		//ProvidedCapability)*)?
		public Group getGroup_9() { return cGroup_9; }

		//"provides"
		public Keyword getProvidesKeyword_9_0() { return cProvidesKeyword_9_0; }

		//providedCapabilities+=ProvidedCapability
		public Assignment getProvidedCapabilitiesAssignment_9_1() { return cProvidedCapabilitiesAssignment_9_1; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_0() { return cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_0; }

		//("," providedCapabilities+=ProvidedCapability)*
		public Group getGroup_9_2() { return cGroup_9_2; }

		//","
		public Keyword getCommaKeyword_9_2_0() { return cCommaKeyword_9_2_0; }

		//providedCapabilities+=ProvidedCapability
		public Assignment getProvidedCapabilitiesAssignment_9_2_1() { return cProvidedCapabilitiesAssignment_9_2_1; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_2_1_0() { return cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_2_1_0; }

		//("precondition" (":" precondExpr=Expression ";"|precondExpr=BlockExpression))?
		public Group getGroup_10() { return cGroup_10; }

		//"precondition"
		public Keyword getPreconditionKeyword_10_0() { return cPreconditionKeyword_10_0; }

		//":" precondExpr=Expression ";"|precondExpr=BlockExpression
		public Alternatives getAlternatives_10_1() { return cAlternatives_10_1; }

		//":" precondExpr=Expression ";"
		public Group getGroup_10_1_0() { return cGroup_10_1_0; }

		//":"
		public Keyword getColonKeyword_10_1_0_0() { return cColonKeyword_10_1_0_0; }

		//precondExpr=Expression
		public Assignment getPrecondExprAssignment_10_1_0_1() { return cPrecondExprAssignment_10_1_0_1; }

		//Expression
		public RuleCall getPrecondExprExpressionParserRuleCall_10_1_0_1_0() { return cPrecondExprExpressionParserRuleCall_10_1_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_10_1_0_2() { return cSemicolonKeyword_10_1_0_2; }

		//precondExpr=BlockExpression
		public Assignment getPrecondExprAssignment_10_1_1() { return cPrecondExprAssignment_10_1_1; }

		//BlockExpression
		public RuleCall getPrecondExprBlockExpressionParserRuleCall_10_1_1_0() { return cPrecondExprBlockExpressionParserRuleCall_10_1_1_0; }

		//("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=BlockExpression))?
		public Group getGroup_11() { return cGroup_11; }

		//"postcondition"
		public Keyword getPostconditionKeyword_11_0() { return cPostconditionKeyword_11_0; }

		//":" postcondExpr=Expression ";"|postcondExpr=BlockExpression
		public Alternatives getAlternatives_11_1() { return cAlternatives_11_1; }

		//":" postcondExpr=Expression ";"
		public Group getGroup_11_1_0() { return cGroup_11_1_0; }

		//":"
		public Keyword getColonKeyword_11_1_0_0() { return cColonKeyword_11_1_0_0; }

		//postcondExpr=Expression
		public Assignment getPostcondExprAssignment_11_1_0_1() { return cPostcondExprAssignment_11_1_0_1; }

		//Expression
		public RuleCall getPostcondExprExpressionParserRuleCall_11_1_0_1_0() { return cPostcondExprExpressionParserRuleCall_11_1_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_11_1_0_2() { return cSemicolonKeyword_11_1_0_2; }

		//postcondExpr=BlockExpression
		public Assignment getPostcondExprAssignment_11_1_1() { return cPostcondExprAssignment_11_1_1; }

		//BlockExpression
		public RuleCall getPostcondExprBlockExpressionParserRuleCall_11_1_1_0() { return cPostcondExprBlockExpressionParserRuleCall_11_1_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_12() { return cLeftCurlyBracketKeyword_12; }

		//("default" "properties" defaultProperties=PropertySet)?
		public Group getGroup_13() { return cGroup_13; }

		//"default"
		public Keyword getDefaultKeyword_13_0() { return cDefaultKeyword_13_0; }

		//"properties"
		public Keyword getPropertiesKeyword_13_1() { return cPropertiesKeyword_13_1; }

		//defaultProperties=PropertySet
		public Assignment getDefaultPropertiesAssignment_13_2() { return cDefaultPropertiesAssignment_13_2; }

		//PropertySet
		public RuleCall getDefaultPropertiesPropertySetParserRuleCall_13_2_0() { return cDefaultPropertiesPropertySetParserRuleCall_13_2_0; }

		//input=BuilderInput?
		public Assignment getInputAssignment_14() { return cInputAssignment_14; }

		//BuilderInput
		public RuleCall getInputBuilderInputParserRuleCall_14_0() { return cInputBuilderInputParserRuleCall_14_0; }

		//("output" "{" output=PathGroup "}")?
		public Group getGroup_15() { return cGroup_15; }

		//"output"
		public Keyword getOutputKeyword_15_0() { return cOutputKeyword_15_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_15_1() { return cLeftCurlyBracketKeyword_15_1; }

		//output=PathGroup
		public Assignment getOutputAssignment_15_2() { return cOutputAssignment_15_2; }

		//PathGroup
		public RuleCall getOutputPathGroupParserRuleCall_15_2_0() { return cOutputPathGroupParserRuleCall_15_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_15_3() { return cRightCurlyBracketKeyword_15_3; }

		//funcExpr=BlockExpressionWithoutBrackets?
		public Assignment getFuncExprAssignment_16() { return cFuncExprAssignment_16; }

		//BlockExpressionWithoutBrackets
		public RuleCall getFuncExprBlockExpressionWithoutBracketsParserRuleCall_16_0() { return cFuncExprBlockExpressionWithoutBracketsParserRuleCall_16_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_17() { return cRightCurlyBracketKeyword_17; }
	}

	public class ParameterListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBParameterListAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParametersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParametersFirstParameterParserRuleCall_1_0 = (RuleCall)cParametersAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParametersFirstParameterParserRuleCall_2_1_0 = (RuleCall)cParametersAssignment_2_1.eContents().get(0);
		
		//ParameterList returns be::BParameterList:
		//  {be::BParameterList} parameters+=FirstParameter ("," parameters+=FirstParameter)*;
		public ParserRule getRule() { return rule; }

		//{be::BParameterList} parameters+=FirstParameter ("," parameters+=FirstParameter)*
		public Group getGroup() { return cGroup; }

		//{be::BParameterList}
		public Action getBParameterListAction_0() { return cBParameterListAction_0; }

		//parameters+=FirstParameter
		public Assignment getParametersAssignment_1() { return cParametersAssignment_1; }

		//FirstParameter
		public RuleCall getParametersFirstParameterParserRuleCall_1_0() { return cParametersFirstParameterParserRuleCall_1_0; }

		//("," parameters+=FirstParameter)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//parameters+=FirstParameter
		public Assignment getParametersAssignment_2_1() { return cParametersAssignment_2_1; }

		//FirstParameter
		public RuleCall getParametersFirstParameterParserRuleCall_2_1_0() { return cParametersFirstParameterParserRuleCall_2_1_0; }
	}

	public class FirstParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FirstParameter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClosureParameterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FirstParameter returns be::BParameter:
		//  ClosureParameter|Parameter;
		public ParserRule getRule() { return rule; }

		//ClosureParameter|Parameter
		public Alternatives getAlternatives() { return cAlternatives; }

		//ClosureParameter
		public RuleCall getClosureParameterParserRuleCall_0() { return cClosureParameterParserRuleCall_0; }

		//Parameter
		public RuleCall getParameterParserRuleCall_1() { return cParameterParserRuleCall_1; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//Parameter returns be::BParameter:
		//  {be::BParameter} expr=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BParameter} expr=Expression
		public Group getGroup() { return cGroup; }

		//{be::BParameter}
		public Action getBParameterAction_0() { return cBParameterAction_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
	}

	public class ClosureParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClosureParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprClosureExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//ClosureParameter returns be::BParameter:
		//  {be::BParameter} expr=ClosureExpression;
		public ParserRule getRule() { return rule; }

		//{be::BParameter} expr=ClosureExpression
		public Group getGroup() { return cGroup; }

		//{be::BParameter}
		public Action getBParameterAction_0() { return cBParameterAction_0; }

		//expr=ClosureExpression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//ClosureExpression
		public RuleCall getExprClosureExpressionParserRuleCall_1_0() { return cExprClosureExpressionParserRuleCall_1_0; }
	}

	public class ParameterDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBParameterDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTypeTypeRefParserRuleCall_1_0_0 = (RuleCall)cTypeAssignment_1_0.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		
		//ParameterDeclaration returns be::BParameterDeclaration:
		//  {be::BParameterDeclaration} (type=TypeRef? name=ID);
		public ParserRule getRule() { return rule; }

		//{be::BParameterDeclaration} (type=TypeRef? name=ID)
		public Group getGroup() { return cGroup; }

		//{be::BParameterDeclaration}
		public Action getBParameterDeclarationAction_0() { return cBParameterDeclarationAction_0; }

		//type=TypeRef? name=ID
		public Group getGroup_1() { return cGroup_1; }

		//type=TypeRef?
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_1_0_0() { return cTypeTypeRefParserRuleCall_1_0_0; }

		//name=ID
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_1_0() { return cNameIDTerminalRuleCall_1_1_0; }
	}

	public class BuilderInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderInput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuilderInputAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cInputKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cPreconditionKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Group cGroup_2_1_0 = (Group)cAlternatives_2_1.eContents().get(0);
		private final Keyword cColonKeyword_2_1_0_0 = (Keyword)cGroup_2_1_0.eContents().get(0);
		private final Assignment cPrecondExprAssignment_2_1_0_1 = (Assignment)cGroup_2_1_0.eContents().get(1);
		private final RuleCall cPrecondExprExpressionParserRuleCall_2_1_0_1_0 = (RuleCall)cPrecondExprAssignment_2_1_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1_0_2 = (Keyword)cGroup_2_1_0.eContents().get(2);
		private final Assignment cPrecondExprAssignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cPrecondExprBlockExpressionParserRuleCall_2_1_1_0 = (RuleCall)cPrecondExprAssignment_2_1_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cPostconditionKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Alternatives cAlternatives_3_1 = (Alternatives)cGroup_3.eContents().get(1);
		private final Group cGroup_3_1_0 = (Group)cAlternatives_3_1.eContents().get(0);
		private final Keyword cColonKeyword_3_1_0_0 = (Keyword)cGroup_3_1_0.eContents().get(0);
		private final Assignment cPostcondExprAssignment_3_1_0_1 = (Assignment)cGroup_3_1_0.eContents().get(1);
		private final RuleCall cPostcondExprExpressionParserRuleCall_3_1_0_1_0 = (RuleCall)cPostcondExprAssignment_3_1_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_1_0_2 = (Keyword)cGroup_3_1_0.eContents().get(2);
		private final Assignment cPostcondExprAssignment_3_1_1 = (Assignment)cAlternatives_3_1.eContents().get(1);
		private final RuleCall cPostcondExprBlockExpressionParserRuleCall_3_1_1_0 = (RuleCall)cPostcondExprAssignment_3_1_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cPrerequisitesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPrerequisitesPrerequisiteParserRuleCall_5_0 = (RuleCall)cPrerequisitesAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//BuilderInput returns build::BuilderInput:
		//  {build::BuilderInput} "input" ("precondition" (":" precondExpr=Expression ";"|
		//  precondExpr=BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|
		//  postcondExpr=BlockExpression))? "{" prerequisites+=Prerequisite+ "}";
		public ParserRule getRule() { return rule; }

		//{build::BuilderInput} "input" ("precondition" (":" precondExpr=Expression ";"|
		//precondExpr=BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|
		//postcondExpr=BlockExpression))? "{" prerequisites+=Prerequisite+ "}"
		public Group getGroup() { return cGroup; }

		//{build::BuilderInput}
		public Action getBuilderInputAction_0() { return cBuilderInputAction_0; }

		//"input"
		public Keyword getInputKeyword_1() { return cInputKeyword_1; }

		//("precondition" (":" precondExpr=Expression ";"|precondExpr=BlockExpression))?
		public Group getGroup_2() { return cGroup_2; }

		//"precondition"
		public Keyword getPreconditionKeyword_2_0() { return cPreconditionKeyword_2_0; }

		//":" precondExpr=Expression ";"|precondExpr=BlockExpression
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//":" precondExpr=Expression ";"
		public Group getGroup_2_1_0() { return cGroup_2_1_0; }

		//":"
		public Keyword getColonKeyword_2_1_0_0() { return cColonKeyword_2_1_0_0; }

		//precondExpr=Expression
		public Assignment getPrecondExprAssignment_2_1_0_1() { return cPrecondExprAssignment_2_1_0_1; }

		//Expression
		public RuleCall getPrecondExprExpressionParserRuleCall_2_1_0_1_0() { return cPrecondExprExpressionParserRuleCall_2_1_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1_0_2() { return cSemicolonKeyword_2_1_0_2; }

		//precondExpr=BlockExpression
		public Assignment getPrecondExprAssignment_2_1_1() { return cPrecondExprAssignment_2_1_1; }

		//BlockExpression
		public RuleCall getPrecondExprBlockExpressionParserRuleCall_2_1_1_0() { return cPrecondExprBlockExpressionParserRuleCall_2_1_1_0; }

		//("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=BlockExpression))?
		public Group getGroup_3() { return cGroup_3; }

		//"postcondition"
		public Keyword getPostconditionKeyword_3_0() { return cPostconditionKeyword_3_0; }

		//":" postcondExpr=Expression ";"|postcondExpr=BlockExpression
		public Alternatives getAlternatives_3_1() { return cAlternatives_3_1; }

		//":" postcondExpr=Expression ";"
		public Group getGroup_3_1_0() { return cGroup_3_1_0; }

		//":"
		public Keyword getColonKeyword_3_1_0_0() { return cColonKeyword_3_1_0_0; }

		//postcondExpr=Expression
		public Assignment getPostcondExprAssignment_3_1_0_1() { return cPostcondExprAssignment_3_1_0_1; }

		//Expression
		public RuleCall getPostcondExprExpressionParserRuleCall_3_1_0_1_0() { return cPostcondExprExpressionParserRuleCall_3_1_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3_1_0_2() { return cSemicolonKeyword_3_1_0_2; }

		//postcondExpr=BlockExpression
		public Assignment getPostcondExprAssignment_3_1_1() { return cPostcondExprAssignment_3_1_1; }

		//BlockExpression
		public RuleCall getPostcondExprBlockExpressionParserRuleCall_3_1_1_0() { return cPostcondExprBlockExpressionParserRuleCall_3_1_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//prerequisites+=Prerequisite+
		public Assignment getPrerequisitesAssignment_5() { return cPrerequisitesAssignment_5; }

		//Prerequisite
		public RuleCall getPrerequisitesPrerequisiteParserRuleCall_5_0() { return cPrerequisitesPrerequisiteParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class RepositoryConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RepositoryConfiguration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRepositoryDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cResolutionStrategyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//RepositoryConfiguration returns build::RepositoryConfiguration:
		//  RepositoryDeclaration|ResolutionStrategy;
		public ParserRule getRule() { return rule; }

		//RepositoryDeclaration|ResolutionStrategy
		public Alternatives getAlternatives() { return cAlternatives; }

		//RepositoryDeclaration
		public RuleCall getRepositoryDeclarationParserRuleCall_0() { return cRepositoryDeclarationParserRuleCall_0; }

		//ResolutionStrategy
		public RuleCall getResolutionStrategyParserRuleCall_1() { return cResolutionStrategyParserRuleCall_1; }
	}

	public class RepositoryDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RepositoryDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRepositoryDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cLocationAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cLocationURIParserRuleCall_2_0_0 = (RuleCall)cLocationAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cRepositoryKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cResolverTypeAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cResolverTypeTypeRefParserRuleCall_2_1_1_0 = (RuleCall)cResolverTypeAssignment_2_1_1.eContents().get(0);
		private final Assignment cContextBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cContextBlockContextBlock_CreationParserRuleCall_3_0 = (RuleCall)cContextBlockAssignment_3.eContents().get(0);
		
		//RepositoryDeclaration returns build::RepositoryDeclaration:
		//  {build::RepositoryDeclaration} documentation=DOCUMENTATION? (location=URI|
		//  "repository" resolverType=TypeRef) contextBlock=ContextBlock_Creation?;
		public ParserRule getRule() { return rule; }

		//{build::RepositoryDeclaration} documentation=DOCUMENTATION? (location=URI|
		//"repository" resolverType=TypeRef) contextBlock=ContextBlock_Creation?
		public Group getGroup() { return cGroup; }

		//{build::RepositoryDeclaration}
		public Action getRepositoryDeclarationAction_0() { return cRepositoryDeclarationAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//location=URI|"repository" resolverType=TypeRef
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//location=URI
		public Assignment getLocationAssignment_2_0() { return cLocationAssignment_2_0; }

		//URI
		public RuleCall getLocationURIParserRuleCall_2_0_0() { return cLocationURIParserRuleCall_2_0_0; }

		//"repository" resolverType=TypeRef
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"repository"
		public Keyword getRepositoryKeyword_2_1_0() { return cRepositoryKeyword_2_1_0; }

		//resolverType=TypeRef
		public Assignment getResolverTypeAssignment_2_1_1() { return cResolverTypeAssignment_2_1_1; }

		//TypeRef
		public RuleCall getResolverTypeTypeRefParserRuleCall_2_1_1_0() { return cResolverTypeTypeRefParserRuleCall_2_1_1_0; }

		//contextBlock=ContextBlock_Creation?
		public Assignment getContextBlockAssignment_3() { return cContextBlockAssignment_3; }

		//ContextBlock_Creation
		public RuleCall getContextBlockContextBlock_CreationParserRuleCall_3_0() { return cContextBlockContextBlock_CreationParserRuleCall_3_0; }
	}

	public class ResolutionStrategyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ResolutionStrategy");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cResolutionStrategyFirstParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cResolutionStrategyBestParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ResolutionStrategy returns build::ResolutionStrategy:
		//  ResolutionStrategyFirst|ResolutionStrategyBest;
		public ParserRule getRule() { return rule; }

		//ResolutionStrategyFirst|ResolutionStrategyBest
		public Alternatives getAlternatives() { return cAlternatives; }

		//ResolutionStrategyFirst
		public RuleCall getResolutionStrategyFirstParserRuleCall_0() { return cResolutionStrategyFirstParserRuleCall_0; }

		//ResolutionStrategyBest
		public RuleCall getResolutionStrategyBestParserRuleCall_1() { return cResolutionStrategyBestParserRuleCall_1; }
	}

	public class ResolutionStrategyFirstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ResolutionStrategyFirst");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cResolutionStrategyFirstAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSelectFirstKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRepositoriesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRepositoriesRepositoryConfigurationParserRuleCall_3_0 = (RuleCall)cRepositoriesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ResolutionStrategyFirst returns build::ResolutionStrategyFirst:
		//  {build::ResolutionStrategyFirst} "select-first" "{" repositories+=
		//  RepositoryConfiguration* "}";
		public ParserRule getRule() { return rule; }

		//{build::ResolutionStrategyFirst} "select-first" "{" repositories+=
		//RepositoryConfiguration* "}"
		public Group getGroup() { return cGroup; }

		//{build::ResolutionStrategyFirst}
		public Action getResolutionStrategyFirstAction_0() { return cResolutionStrategyFirstAction_0; }

		//"select-first"
		public Keyword getSelectFirstKeyword_1() { return cSelectFirstKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//repositories+=RepositoryConfiguration*
		public Assignment getRepositoriesAssignment_3() { return cRepositoriesAssignment_3; }

		//RepositoryConfiguration
		public RuleCall getRepositoriesRepositoryConfigurationParserRuleCall_3_0() { return cRepositoriesRepositoryConfigurationParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ResolutionStrategyBestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ResolutionStrategyBest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cResolutionStrategyBestAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSelectBestKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRepositoriesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRepositoriesRepositoryConfigurationParserRuleCall_3_0 = (RuleCall)cRepositoriesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ResolutionStrategyBest returns build::ResolutionStrategyBest:
		//  {build::ResolutionStrategyBest} "select-best" "{" repositories+=
		//  RepositoryConfiguration* "}";
		public ParserRule getRule() { return rule; }

		//{build::ResolutionStrategyBest} "select-best" "{" repositories+=
		//RepositoryConfiguration* "}"
		public Group getGroup() { return cGroup; }

		//{build::ResolutionStrategyBest}
		public Action getResolutionStrategyBestAction_0() { return cResolutionStrategyBestAction_0; }

		//"select-best"
		public Keyword getSelectBestKeyword_1() { return cSelectBestKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//repositories+=RepositoryConfiguration*
		public Assignment getRepositoriesAssignment_3() { return cRepositoriesAssignment_3; }

		//RepositoryConfiguration
		public RuleCall getRepositoriesRepositoryConfigurationParserRuleCall_3_0() { return cRepositoriesRepositoryConfigurationParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ContainerConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ContainerConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cContainerConfigurationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Keyword cContainerKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cAgentKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cAgentTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cAgentTypeTypeRefParserRuleCall_5_0 = (RuleCall)cAgentTypeAssignment_5.eContents().get(0);
		private final Assignment cContextBlockAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cContextBlockContextBlock_CreationParserRuleCall_6_0 = (RuleCall)cContextBlockAssignment_6.eContents().get(0);
		
		//ContainerConfiguration returns build::ContainerConfiguration:
		//  {build::ContainerConfiguration} documentation=DOCUMENTATION? "container" name=ID
		//  "agent" agentType=TypeRef contextBlock=ContextBlock_Creation?;
		public ParserRule getRule() { return rule; }

		//{build::ContainerConfiguration} documentation=DOCUMENTATION? "container" name=ID
		//"agent" agentType=TypeRef contextBlock=ContextBlock_Creation?
		public Group getGroup() { return cGroup; }

		//{build::ContainerConfiguration}
		public Action getContainerConfigurationAction_0() { return cContainerConfigurationAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//"container"
		public Keyword getContainerKeyword_2() { return cContainerKeyword_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//"agent"
		public Keyword getAgentKeyword_4() { return cAgentKeyword_4; }

		//agentType=TypeRef
		public Assignment getAgentTypeAssignment_5() { return cAgentTypeAssignment_5; }

		//TypeRef
		public RuleCall getAgentTypeTypeRefParserRuleCall_5_0() { return cAgentTypeTypeRefParserRuleCall_5_0; }

		//contextBlock=ContextBlock_Creation?
		public Assignment getContextBlockAssignment_6() { return cContextBlockAssignment_6; }

		//ContextBlock_Creation
		public RuleCall getContextBlockContextBlock_CreationParserRuleCall_6_0() { return cContextBlockContextBlock_CreationParserRuleCall_6_0; }
	}

	public class URIElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "URI");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//URI returns build::URI:
		//  STRING;
		public ParserRule getRule() { return rule; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}

	public class Concern_NamedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Concern_Named");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBConcernAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Keyword cConcernKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cExtendsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cSuperConcernsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cSuperConcernsBConcernCrossReference_4_1_0 = (CrossReference)cSuperConcernsAssignment_4_1.eContents().get(0);
		private final RuleCall cSuperConcernsBConcernIDTerminalRuleCall_4_1_0_1 = (RuleCall)cSuperConcernsBConcernCrossReference_4_1_0.eContents().get(1);
		private final Group cGroup_4_2 = (Group)cGroup_4.eContents().get(2);
		private final Keyword cCommaKeyword_4_2_0 = (Keyword)cGroup_4_2.eContents().get(0);
		private final Assignment cSuperConcernsAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final CrossReference cSuperConcernsBConcernCrossReference_4_2_1_0 = (CrossReference)cSuperConcernsAssignment_4_2_1.eContents().get(0);
		private final RuleCall cSuperConcernsBConcernIDTerminalRuleCall_4_2_1_0_1 = (RuleCall)cSuperConcernsBConcernCrossReference_4_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Group cGroup_6_0 = (Group)cAlternatives_6.eContents().get(0);
		private final Keyword cPropertiesKeyword_6_0_0 = (Keyword)cGroup_6_0.eContents().get(0);
		private final Assignment cPropertySetsAssignment_6_0_1 = (Assignment)cGroup_6_0.eContents().get(1);
		private final RuleCall cPropertySetsPropertySetParserRuleCall_6_0_1_0 = (RuleCall)cPropertySetsAssignment_6_0_1.eContents().get(0);
		private final Assignment cFunctionsAssignment_6_1 = (Assignment)cAlternatives_6.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_6_1_0 = (RuleCall)cFunctionsAssignment_6_1.eContents().get(0);
		private final Assignment cContextsAssignment_6_2 = (Assignment)cAlternatives_6.eContents().get(2);
		private final RuleCall cContextsBuildConcernContextParserRuleCall_6_2_0 = (RuleCall)cContextsAssignment_6_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Concern_Named returns be::BConcern:
		//  {be::BConcern} documentation=DOCUMENTATION? "concern" name=ID ("extends"
		//  superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)? "{" (
		//  "properties" propertySets+=PropertySet|functions+=Function|contexts+=
		//  BuildConcernContext)* "}";
		public ParserRule getRule() { return rule; }

		//{be::BConcern} documentation=DOCUMENTATION? "concern" name=ID ("extends"
		//superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)? "{" (
		//"properties" propertySets+=PropertySet|functions+=Function|contexts+=
		//BuildConcernContext)* "}"
		public Group getGroup() { return cGroup; }

		//{be::BConcern}
		public Action getBConcernAction_0() { return cBConcernAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//"concern"
		public Keyword getConcernKeyword_2() { return cConcernKeyword_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)?
		public Group getGroup_4() { return cGroup_4; }

		//"extends"
		public Keyword getExtendsKeyword_4_0() { return cExtendsKeyword_4_0; }

		//superConcerns+=[be::BConcern]
		public Assignment getSuperConcernsAssignment_4_1() { return cSuperConcernsAssignment_4_1; }

		//[be::BConcern]
		public CrossReference getSuperConcernsBConcernCrossReference_4_1_0() { return cSuperConcernsBConcernCrossReference_4_1_0; }

		//ID
		public RuleCall getSuperConcernsBConcernIDTerminalRuleCall_4_1_0_1() { return cSuperConcernsBConcernIDTerminalRuleCall_4_1_0_1; }

		//("," superConcerns+=[be::BConcern])*
		public Group getGroup_4_2() { return cGroup_4_2; }

		//","
		public Keyword getCommaKeyword_4_2_0() { return cCommaKeyword_4_2_0; }

		//superConcerns+=[be::BConcern]
		public Assignment getSuperConcernsAssignment_4_2_1() { return cSuperConcernsAssignment_4_2_1; }

		//[be::BConcern]
		public CrossReference getSuperConcernsBConcernCrossReference_4_2_1_0() { return cSuperConcernsBConcernCrossReference_4_2_1_0; }

		//ID
		public RuleCall getSuperConcernsBConcernIDTerminalRuleCall_4_2_1_0_1() { return cSuperConcernsBConcernIDTerminalRuleCall_4_2_1_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }

		//("properties" propertySets+=PropertySet|functions+=Function|contexts+=
		//BuildConcernContext)*
		public Alternatives getAlternatives_6() { return cAlternatives_6; }

		//"properties" propertySets+=PropertySet
		public Group getGroup_6_0() { return cGroup_6_0; }

		//"properties"
		public Keyword getPropertiesKeyword_6_0_0() { return cPropertiesKeyword_6_0_0; }

		//propertySets+=PropertySet
		public Assignment getPropertySetsAssignment_6_0_1() { return cPropertySetsAssignment_6_0_1; }

		//PropertySet
		public RuleCall getPropertySetsPropertySetParserRuleCall_6_0_1_0() { return cPropertySetsPropertySetParserRuleCall_6_0_1_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_6_1() { return cFunctionsAssignment_6_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_6_1_0() { return cFunctionsFunctionParserRuleCall_6_1_0; }

		//contexts+=BuildConcernContext
		public Assignment getContextsAssignment_6_2() { return cContextsAssignment_6_2; }

		//BuildConcernContext
		public RuleCall getContextsBuildConcernContextParserRuleCall_6_2_0() { return cContextsBuildConcernContextParserRuleCall_6_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class Concern_AnonymousElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Concern_Anonymous");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBConcernAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cExtendsKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSuperConcernsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cSuperConcernsBConcernCrossReference_1_1_0 = (CrossReference)cSuperConcernsAssignment_1_1.eContents().get(0);
		private final RuleCall cSuperConcernsBConcernIDTerminalRuleCall_1_1_0_1 = (RuleCall)cSuperConcernsBConcernCrossReference_1_1_0.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cSuperConcernsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final CrossReference cSuperConcernsBConcernCrossReference_1_2_1_0 = (CrossReference)cSuperConcernsAssignment_1_2_1.eContents().get(0);
		private final RuleCall cSuperConcernsBConcernIDTerminalRuleCall_1_2_1_0_1 = (RuleCall)cSuperConcernsBConcernCrossReference_1_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cPropertiesKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cPropertySetsAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cPropertySetsPropertySetParserRuleCall_3_0_1_0 = (RuleCall)cPropertySetsAssignment_3_0_1.eContents().get(0);
		private final Assignment cFunctionsAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_3_1_0 = (RuleCall)cFunctionsAssignment_3_1.eContents().get(0);
		private final Assignment cContextsAssignment_3_2 = (Assignment)cAlternatives_3.eContents().get(2);
		private final RuleCall cContextsBuildConcernContextParserRuleCall_3_2_0 = (RuleCall)cContextsAssignment_3_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Concern_Anonymous returns be::BConcern:
		//  {be::BConcern} ("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::
		//  BConcern])*)? "{" ("properties" propertySets+=PropertySet|functions+=Function|
		//  contexts+=BuildConcernContext)* "}";
		public ParserRule getRule() { return rule; }

		//{be::BConcern} ("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::
		//BConcern])*)? "{" ("properties" propertySets+=PropertySet|functions+=Function|
		//contexts+=BuildConcernContext)* "}"
		public Group getGroup() { return cGroup; }

		//{be::BConcern}
		public Action getBConcernAction_0() { return cBConcernAction_0; }

		//("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)?
		public Group getGroup_1() { return cGroup_1; }

		//"extends"
		public Keyword getExtendsKeyword_1_0() { return cExtendsKeyword_1_0; }

		//superConcerns+=[be::BConcern]
		public Assignment getSuperConcernsAssignment_1_1() { return cSuperConcernsAssignment_1_1; }

		//[be::BConcern]
		public CrossReference getSuperConcernsBConcernCrossReference_1_1_0() { return cSuperConcernsBConcernCrossReference_1_1_0; }

		//ID
		public RuleCall getSuperConcernsBConcernIDTerminalRuleCall_1_1_0_1() { return cSuperConcernsBConcernIDTerminalRuleCall_1_1_0_1; }

		//("," superConcerns+=[be::BConcern])*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//","
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }

		//superConcerns+=[be::BConcern]
		public Assignment getSuperConcernsAssignment_1_2_1() { return cSuperConcernsAssignment_1_2_1; }

		//[be::BConcern]
		public CrossReference getSuperConcernsBConcernCrossReference_1_2_1_0() { return cSuperConcernsBConcernCrossReference_1_2_1_0; }

		//ID
		public RuleCall getSuperConcernsBConcernIDTerminalRuleCall_1_2_1_0_1() { return cSuperConcernsBConcernIDTerminalRuleCall_1_2_1_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//("properties" propertySets+=PropertySet|functions+=Function|contexts+=
		//BuildConcernContext)*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//"properties" propertySets+=PropertySet
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"properties"
		public Keyword getPropertiesKeyword_3_0_0() { return cPropertiesKeyword_3_0_0; }

		//propertySets+=PropertySet
		public Assignment getPropertySetsAssignment_3_0_1() { return cPropertySetsAssignment_3_0_1; }

		//PropertySet
		public RuleCall getPropertySetsPropertySetParserRuleCall_3_0_1_0() { return cPropertySetsPropertySetParserRuleCall_3_0_1_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_3_1() { return cFunctionsAssignment_3_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_3_1_0() { return cFunctionsFunctionParserRuleCall_3_1_0; }

		//contexts+=BuildConcernContext
		public Assignment getContextsAssignment_3_2() { return cContextsAssignment_3_2; }

		//BuildConcernContext
		public RuleCall getContextsBuildConcernContextParserRuleCall_3_2_0() { return cContextsBuildConcernContextParserRuleCall_3_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3FunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Assignment cVisibilityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVisibilityVisibilityEnumRuleCall_2_0 = (RuleCall)cVisibilityAssignment_2.eContents().get(0);
		private final Assignment cExecutionModeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExecutionModeExecutionModeEnumRuleCall_3_0 = (RuleCall)cExecutionModeAssignment_3.eContents().get(0);
		private final Assignment cFinalAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cFinalFinalKeyword_4_0 = (Keyword)cFinalAssignment_4.eContents().get(0);
		private final Keyword cFunctionKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeTypeRefParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final Assignment cNameAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cNameIDTerminalRuleCall_7_0 = (RuleCall)cNameAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cLeftParenthesisKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Alternatives cAlternatives_8_1 = (Alternatives)cGroup_8.eContents().get(1);
		private final Group cGroup_8_1_0 = (Group)cAlternatives_8_1.eContents().get(0);
		private final Assignment cParametersAssignment_8_1_0_0 = (Assignment)cGroup_8_1_0.eContents().get(0);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_8_1_0_0_0 = (RuleCall)cParametersAssignment_8_1_0_0.eContents().get(0);
		private final Group cGroup_8_1_0_1 = (Group)cGroup_8_1_0.eContents().get(1);
		private final Keyword cCommaKeyword_8_1_0_1_0 = (Keyword)cGroup_8_1_0_1.eContents().get(0);
		private final Assignment cParametersAssignment_8_1_0_1_1 = (Assignment)cGroup_8_1_0_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_8_1_0_1_1_0 = (RuleCall)cParametersAssignment_8_1_0_1_1.eContents().get(0);
		private final Group cGroup_8_1_0_2 = (Group)cGroup_8_1_0.eContents().get(2);
		private final Keyword cCommaKeyword_8_1_0_2_0 = (Keyword)cGroup_8_1_0_2.eContents().get(0);
		private final Assignment cVarArgsAssignment_8_1_0_2_1 = (Assignment)cGroup_8_1_0_2.eContents().get(1);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_8_1_0_2_1_0 = (Keyword)cVarArgsAssignment_8_1_0_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_8_1_0_2_2 = (Assignment)cGroup_8_1_0_2.eContents().get(2);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_8_1_0_2_2_0 = (RuleCall)cParametersAssignment_8_1_0_2_2.eContents().get(0);
		private final Group cGroup_8_1_1 = (Group)cAlternatives_8_1.eContents().get(1);
		private final Assignment cVarArgsAssignment_8_1_1_0 = (Assignment)cGroup_8_1_1.eContents().get(0);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_8_1_1_0_0 = (Keyword)cVarArgsAssignment_8_1_1_0.eContents().get(0);
		private final Assignment cParametersAssignment_8_1_1_1 = (Assignment)cGroup_8_1_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_8_1_1_1_0 = (RuleCall)cParametersAssignment_8_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cWhenKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cGuardAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cGuardGuardExpressionParserRuleCall_9_1_0 = (RuleCall)cGuardAssignment_9_1.eContents().get(0);
		private final Alternatives cAlternatives_10 = (Alternatives)cGroup.eContents().get(10);
		private final Group cGroup_10_0 = (Group)cAlternatives_10.eContents().get(0);
		private final Keyword cColonKeyword_10_0_0 = (Keyword)cGroup_10_0.eContents().get(0);
		private final Assignment cFuncExprAssignment_10_0_1 = (Assignment)cGroup_10_0.eContents().get(1);
		private final RuleCall cFuncExprExpressionParserRuleCall_10_0_1_0 = (RuleCall)cFuncExprAssignment_10_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_10_0_2 = (Keyword)cGroup_10_0.eContents().get(2);
		private final Assignment cFuncExprAssignment_10_1 = (Assignment)cAlternatives_10.eContents().get(1);
		private final RuleCall cFuncExprBlockExpressionParserRuleCall_10_1_0 = (RuleCall)cFuncExprAssignment_10_1.eContents().get(0);
		
		//Function returns be::B3Function:
		//  {be::B3Function} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
		//  ExecutionMode? final?="final"? "function" returnType=TypeRef? name=ID ("(" (parameters
		//  +=ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
		//  parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
		//  ParameterDeclaration)? ")")? ("when" guard=GuardExpression)? (":" funcExpr=Expression
		//  ";"|funcExpr=BlockExpression); 
		//
		//        
		//	    
		//   	    
		//        	   	
		//   	    
		//   	
		//   	    
		//   	 
		////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
		public ParserRule getRule() { return rule; }

		//{be::B3Function} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
		//ExecutionMode? final?="final"? "function" returnType=TypeRef? name=ID ("(" (parameters
		//+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
		//parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
		//ParameterDeclaration)? ")")? ("when" guard=GuardExpression)? (":" funcExpr=Expression
		//";"|funcExpr=BlockExpression)   
		//	    
		//   	    
		//        	   	
		//   	    
		//   	
		//   	    
		//   	 
		////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
		public Group getGroup() { return cGroup; }

		//{be::B3Function}
		public Action getB3FunctionAction_0() { return cB3FunctionAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//visibility=Visibility?
		public Assignment getVisibilityAssignment_2() { return cVisibilityAssignment_2; }

		//Visibility
		public RuleCall getVisibilityVisibilityEnumRuleCall_2_0() { return cVisibilityVisibilityEnumRuleCall_2_0; }

		//executionMode=ExecutionMode?
		public Assignment getExecutionModeAssignment_3() { return cExecutionModeAssignment_3; }

		//ExecutionMode
		public RuleCall getExecutionModeExecutionModeEnumRuleCall_3_0() { return cExecutionModeExecutionModeEnumRuleCall_3_0; }

		//final?="final"?
		public Assignment getFinalAssignment_4() { return cFinalAssignment_4; }

		//"final"
		public Keyword getFinalFinalKeyword_4_0() { return cFinalFinalKeyword_4_0; }

		//"function"
		public Keyword getFunctionKeyword_5() { return cFunctionKeyword_5; }

		//returnType=TypeRef?
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }

		//TypeRef
		public RuleCall getReturnTypeTypeRefParserRuleCall_6_0() { return cReturnTypeTypeRefParserRuleCall_6_0; }

		//name=ID 
		//   	 
		////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
		public Assignment getNameAssignment_7() { return cNameAssignment_7; }

		//ID  
		////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
		public RuleCall getNameIDTerminalRuleCall_7_0() { return cNameIDTerminalRuleCall_7_0; }

		//("(" (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
		//varArgs?="..." parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
		//ParameterDeclaration)? ")")?
		public Group getGroup_8() { return cGroup_8; }

		//"("
		public Keyword getLeftParenthesisKeyword_8_0() { return cLeftParenthesisKeyword_8_0; }

		//(parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
		//varArgs?="..." parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
		//ParameterDeclaration)?
		public Alternatives getAlternatives_8_1() { return cAlternatives_8_1; }

		//parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
		//varArgs?="..." parameters+=ParameterDeclaration)?
		public Group getGroup_8_1_0() { return cGroup_8_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_8_1_0_0() { return cParametersAssignment_8_1_0_0; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_8_1_0_0_0() { return cParametersParameterDeclarationParserRuleCall_8_1_0_0_0; }

		//("," parameters+=ParameterDeclaration)*
		public Group getGroup_8_1_0_1() { return cGroup_8_1_0_1; }

		//","
		public Keyword getCommaKeyword_8_1_0_1_0() { return cCommaKeyword_8_1_0_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_8_1_0_1_1() { return cParametersAssignment_8_1_0_1_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_8_1_0_1_1_0() { return cParametersParameterDeclarationParserRuleCall_8_1_0_1_1_0; }

		//("," varArgs?="..." parameters+=ParameterDeclaration)?
		public Group getGroup_8_1_0_2() { return cGroup_8_1_0_2; }

		//","
		public Keyword getCommaKeyword_8_1_0_2_0() { return cCommaKeyword_8_1_0_2_0; }

		//varArgs?="..."
		public Assignment getVarArgsAssignment_8_1_0_2_1() { return cVarArgsAssignment_8_1_0_2_1; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_8_1_0_2_1_0() { return cVarArgsFullStopFullStopFullStopKeyword_8_1_0_2_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_8_1_0_2_2() { return cParametersAssignment_8_1_0_2_2; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_8_1_0_2_2_0() { return cParametersParameterDeclarationParserRuleCall_8_1_0_2_2_0; }

		//varArgs?="..." parameters+=ParameterDeclaration
		public Group getGroup_8_1_1() { return cGroup_8_1_1; }

		//varArgs?="..."
		public Assignment getVarArgsAssignment_8_1_1_0() { return cVarArgsAssignment_8_1_1_0; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_8_1_1_0_0() { return cVarArgsFullStopFullStopFullStopKeyword_8_1_1_0_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_8_1_1_1() { return cParametersAssignment_8_1_1_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_8_1_1_1_0() { return cParametersParameterDeclarationParserRuleCall_8_1_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_8_2() { return cRightParenthesisKeyword_8_2; }

		//("when" guard=GuardExpression)?
		public Group getGroup_9() { return cGroup_9; }

		//"when"
		public Keyword getWhenKeyword_9_0() { return cWhenKeyword_9_0; }

		//guard=GuardExpression
		public Assignment getGuardAssignment_9_1() { return cGuardAssignment_9_1; }

		//GuardExpression
		public RuleCall getGuardGuardExpressionParserRuleCall_9_1_0() { return cGuardGuardExpressionParserRuleCall_9_1_0; }

		//":" funcExpr=Expression ";"|funcExpr=BlockExpression
		public Alternatives getAlternatives_10() { return cAlternatives_10; }

		//":" funcExpr=Expression ";"
		public Group getGroup_10_0() { return cGroup_10_0; }

		//":"
		public Keyword getColonKeyword_10_0_0() { return cColonKeyword_10_0_0; }

		//funcExpr=Expression
		public Assignment getFuncExprAssignment_10_0_1() { return cFuncExprAssignment_10_0_1; }

		//Expression
		public RuleCall getFuncExprExpressionParserRuleCall_10_0_1_0() { return cFuncExprExpressionParserRuleCall_10_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_10_0_2() { return cSemicolonKeyword_10_0_2; }

		//funcExpr=BlockExpression
		public Assignment getFuncExprAssignment_10_1() { return cFuncExprAssignment_10_1; }

		//BlockExpression
		public RuleCall getFuncExprBlockExpressionParserRuleCall_10_1_0() { return cFuncExprBlockExpressionParserRuleCall_10_1_0; }
	}

	public class GuardExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GuardExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBGuardExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cColonKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cGuardExprAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cGuardExprExpressionParserRuleCall_0_1_1_0 = (RuleCall)cGuardExprAssignment_0_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_1_2 = (Keyword)cGroup_0_1.eContents().get(2);
		private final Assignment cGuardExprAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cGuardExprBlockExpressionParserRuleCall_1_0 = (RuleCall)cGuardExprAssignment_1.eContents().get(0);
		
		//GuardExpression returns be::BGuardExpression:
		//  {be::BGuardExpression} (":" guardExpr=Expression ";")|guardExpr=BlockExpression; 
		//	
		//        
		//	                
		//	
		////TypeParamDeclaration 
		////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
		////	;
		//		
		/// * EXPRESSIONS * /
		public ParserRule getRule() { return rule; }

		//{be::BGuardExpression} (":" guardExpr=Expression ";")|guardExpr=BlockExpression 
		//	
		//        
		//	                
		//	
		////TypeParamDeclaration 
		////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
		////	;
		//		
		/// * EXPRESSIONS * /
		public Alternatives getAlternatives() { return cAlternatives; }

		//{be::BGuardExpression} (":" guardExpr=Expression ";")
		public Group getGroup_0() { return cGroup_0; }

		//{be::BGuardExpression}
		public Action getBGuardExpressionAction_0_0() { return cBGuardExpressionAction_0_0; }

		//":" guardExpr=Expression ";"
		public Group getGroup_0_1() { return cGroup_0_1; }

		//":"
		public Keyword getColonKeyword_0_1_0() { return cColonKeyword_0_1_0; }

		//guardExpr=Expression
		public Assignment getGuardExprAssignment_0_1_1() { return cGuardExprAssignment_0_1_1; }

		//Expression
		public RuleCall getGuardExprExpressionParserRuleCall_0_1_1_0() { return cGuardExprExpressionParserRuleCall_0_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_0_1_2() { return cSemicolonKeyword_0_1_2; }

		//guardExpr=BlockExpression
		public Assignment getGuardExprAssignment_1() { return cGuardExprAssignment_1; }

		//BlockExpression
		public RuleCall getGuardExprBlockExpressionParserRuleCall_1_0() { return cGuardExprBlockExpressionParserRuleCall_1_0; }
	}

	public class AssignmentOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPlusSignEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cHyphenMinusEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAsteriskEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cSolidusEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPercentSignEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//AssignmentOperator returns ecore::EString:
		//  "="|"+="|"-="|"*="|"/="|"%="; 
		////TypeParamDeclaration 
		////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
		////	;
		//		
		/// * EXPRESSIONS * / 
		// 
		//	              	        
		//// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
		////	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>="
		public ParserRule getRule() { return rule; }

		//"="|"+="|"-="|"*="|"/="|"%=" 
		////TypeParamDeclaration 
		////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
		////	;
		//		
		/// * EXPRESSIONS * / 
		// 
		//	              	        
		//// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
		////	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>="
		public Alternatives getAlternatives() { return cAlternatives; }

		//"="
		public Keyword getEqualsSignKeyword_0() { return cEqualsSignKeyword_0; }

		//"+="
		public Keyword getPlusSignEqualsSignKeyword_1() { return cPlusSignEqualsSignKeyword_1; }

		//"-="
		public Keyword getHyphenMinusEqualsSignKeyword_2() { return cHyphenMinusEqualsSignKeyword_2; }

		//"*="
		public Keyword getAsteriskEqualsSignKeyword_3() { return cAsteriskEqualsSignKeyword_3; }

		//"/="
		public Keyword getSolidusEqualsSignKeyword_4() { return cSolidusEqualsSignKeyword_4; }

		//"%="    
		//// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
		////	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>="
		public Keyword getPercentSignEqualsSignKeyword_5() { return cPercentSignEqualsSignKeyword_5; }
	}

	public class RelationalOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTildeEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEqualsSignEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cExclamationMarkEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cExclamationMarkEqualsSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cGreaterThanSignEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLessThanSignEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cGreaterThanSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLessThanSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		
		//RelationalOperator returns ecore::EString:
		//  "~="|"=="|"==="|"!="|"!=="|">="|"<="|">"|"<"; 
		//	
		// 
		//	                  
		//	              
		//	
		//
		//// All expressions, including variable and value definitions. Note: order of rules is significant.
		public ParserRule getRule() { return rule; }

		//"~="|"=="|"==="|"!="|"!=="|">="|"<="|">"|"<" 
		//	
		// 
		//	                  
		//	              
		//	
		//
		//// All expressions, including variable and value definitions. Note: order of rules is significant.
		public Alternatives getAlternatives() { return cAlternatives; }

		//"~="
		public Keyword getTildeEqualsSignKeyword_0() { return cTildeEqualsSignKeyword_0; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_1() { return cEqualsSignEqualsSignKeyword_1; }

		//"==="
		public Keyword getEqualsSignEqualsSignEqualsSignKeyword_2() { return cEqualsSignEqualsSignEqualsSignKeyword_2; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_3() { return cExclamationMarkEqualsSignKeyword_3; }

		//"!=="
		public Keyword getExclamationMarkEqualsSignEqualsSignKeyword_4() { return cExclamationMarkEqualsSignEqualsSignKeyword_4; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_5() { return cGreaterThanSignEqualsSignKeyword_5; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_6() { return cLessThanSignEqualsSignKeyword_6; }

		//">"
		public Keyword getGreaterThanSignKeyword_7() { return cGreaterThanSignKeyword_7; }

		//"<"
		public Keyword getLessThanSignKeyword_8() { return cLessThanSignKeyword_8; }
	}

	public class TopLevelExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TopLevelExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVarDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cValDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAssignmentExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//TopLevelExpression returns be::BExpression:
		//  VarDeclaration|ValDeclaration|AssignmentExpression; 
		//
		//// All expressions, including variable and value definitions. Note: order of rules is significant.
		//     
		//	   
		//	  
		//	   
		//	
		//
		//// All expressions except variable and value definitions
		public ParserRule getRule() { return rule; }

		//VarDeclaration|ValDeclaration|AssignmentExpression 
		//
		//// All expressions, including variable and value definitions. Note: order of rules is significant.
		//     
		//	   
		//	  
		//	   
		//	
		//
		//// All expressions except variable and value definitions
		public Alternatives getAlternatives() { return cAlternatives; }

		//VarDeclaration
		public RuleCall getVarDeclarationParserRuleCall_0() { return cVarDeclarationParserRuleCall_0; }

		//ValDeclaration
		public RuleCall getValDeclarationParserRuleCall_1() { return cValDeclarationParserRuleCall_1; }

		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall_2() { return cAssignmentExpressionParserRuleCall_2; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cAssignmentExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression returns be::BExpression:
		//  AssignmentExpression; 
		//
		//// All expressions except variable and value definitions
		public ParserRule getRule() { return rule; }

		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall() { return cAssignmentExpressionParserRuleCall; }
	}

	public class AssignmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCachedExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBAssignmentExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFunctionNameAssignmentOperatorParserRuleCall_1_1_0 = (RuleCall)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprAssignmentExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//AssignmentExpression returns be::BExpression:
		//  CachedExpression ({be::BAssignmentExpression.leftExpr=current} functionName=
		//  AssignmentOperator rightExpr=AssignmentExpression)?;
		public ParserRule getRule() { return rule; }

		//CachedExpression ({be::BAssignmentExpression.leftExpr=current} functionName=
		//AssignmentOperator rightExpr=AssignmentExpression)?
		public Group getGroup() { return cGroup; }

		//CachedExpression
		public RuleCall getCachedExpressionParserRuleCall_0() { return cCachedExpressionParserRuleCall_0; }

		//({be::BAssignmentExpression.leftExpr=current} functionName=AssignmentOperator
		//rightExpr=AssignmentExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{be::BAssignmentExpression.leftExpr=current}
		public Action getBAssignmentExpressionLeftExprAction_1_0() { return cBAssignmentExpressionLeftExprAction_1_0; }

		//functionName=AssignmentOperator
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//AssignmentOperator
		public RuleCall getFunctionNameAssignmentOperatorParserRuleCall_1_1_0() { return cFunctionNameAssignmentOperatorParserRuleCall_1_1_0; }

		//rightExpr=AssignmentExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//AssignmentExpression
		public RuleCall getRightExprAssignmentExpressionParserRuleCall_1_2_0() { return cRightExprAssignmentExpressionParserRuleCall_1_2_0; }
	}

	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFinalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFinalFinalKeyword_1_0 = (Keyword)cFinalAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Keyword cVarKeyword_2_0_0 = (Keyword)cAlternatives_2_0.eContents().get(0);
		private final Assignment cTypeAssignment_2_0_1 = (Assignment)cAlternatives_2_0.eContents().get(1);
		private final RuleCall cTypeTypeRefParserRuleCall_2_0_1_0 = (RuleCall)cTypeAssignment_2_0_1.eContents().get(0);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cEqualsSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValueExprAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValueExprExpressionParserRuleCall_3_1_0 = (RuleCall)cValueExprAssignment_3_1.eContents().get(0);
		
		//VarDeclaration returns be::BExpression:
		//  {be::BDefValue} final?="final"? (("var"|type=TypeRef) name=ID) ("=" valueExpr=
		//  Expression)?;
		public ParserRule getRule() { return rule; }

		//{be::BDefValue} final?="final"? (("var"|type=TypeRef) name=ID) ("=" valueExpr=
		//Expression)?
		public Group getGroup() { return cGroup; }

		//{be::BDefValue}
		public Action getBDefValueAction_0() { return cBDefValueAction_0; }

		//final?="final"?
		public Assignment getFinalAssignment_1() { return cFinalAssignment_1; }

		//"final"
		public Keyword getFinalFinalKeyword_1_0() { return cFinalFinalKeyword_1_0; }

		//("var"|type=TypeRef) name=ID
		public Group getGroup_2() { return cGroup_2; }

		//"var"|type=TypeRef
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }

		//"var"
		public Keyword getVarKeyword_2_0_0() { return cVarKeyword_2_0_0; }

		//type=TypeRef
		public Assignment getTypeAssignment_2_0_1() { return cTypeAssignment_2_0_1; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_2_0_1_0() { return cTypeTypeRefParserRuleCall_2_0_1_0; }

		//name=ID
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_1_0() { return cNameIDTerminalRuleCall_2_1_0; }

		//("=" valueExpr=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"="
		public Keyword getEqualsSignKeyword_3_0() { return cEqualsSignKeyword_3_0; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_3_1() { return cValueExprAssignment_3_1; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_3_1_0() { return cValueExprExpressionParserRuleCall_3_1_0; }
	}

	public class ValDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFinalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFinalFinalKeyword_1_0 = (Keyword)cFinalAssignment_1.eContents().get(0);
		private final Assignment cImmutableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cImmutableValKeyword_2_0 = (Keyword)cImmutableAssignment_2.eContents().get(0);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeRefParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameIDTerminalRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cValueExprAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cValueExprExpressionParserRuleCall_6_0 = (RuleCall)cValueExprAssignment_6.eContents().get(0);
		
		//ValDeclaration returns be::BExpression:
		//  {be::BDefValue} final?="final"? immutable?="val" type=TypeRef? name=ID "=" valueExpr=
		//  Expression; 
		//
		//        
		//	     
		//	         
		//	      
		//	
		//
		//// TODO: typereference is simplified to only the name of a java type - for model imports
		//// the model is imported with name == namespace, and types in the model are referenced after
		//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
		//// referenced as mymodel::mytype
		//// There is more work required to link a reference to such a type and it is therefore deferred
		//// until we are up on Xtext 0.8 with better scoping and linking.
		//// For now, this is just proof of concept.
		////
		public ParserRule getRule() { return rule; }

		//{be::BDefValue} final?="final"? immutable?="val" type=TypeRef? name=ID "=" valueExpr=
		//Expression
		public Group getGroup() { return cGroup; }

		//{be::BDefValue}
		public Action getBDefValueAction_0() { return cBDefValueAction_0; }

		//final?="final"?
		public Assignment getFinalAssignment_1() { return cFinalAssignment_1; }

		//"final"
		public Keyword getFinalFinalKeyword_1_0() { return cFinalFinalKeyword_1_0; }

		//immutable?="val"
		public Assignment getImmutableAssignment_2() { return cImmutableAssignment_2; }

		//"val"
		public Keyword getImmutableValKeyword_2_0() { return cImmutableValKeyword_2_0; }

		//type=TypeRef?
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_3_0() { return cTypeTypeRefParserRuleCall_3_0; }

		//name=ID
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_4_0() { return cNameIDTerminalRuleCall_4_0; }

		//"="
		public Keyword getEqualsSignKeyword_5() { return cEqualsSignKeyword_5; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_6() { return cValueExprAssignment_6; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_6_0() { return cValueExprExpressionParserRuleCall_6_0; }
	}

	public class TypeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeRef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClosureTypeRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TypeRef returns be::IType:
		//  ClosureTypeRef|SimpleTypeRef; 
		//
		//// TODO: typereference is simplified to only the name of a java type - for model imports
		//// the model is imported with name == namespace, and types in the model are referenced after
		//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
		//// referenced as mymodel::mytype
		//// There is more work required to link a reference to such a type and it is therefore deferred
		//// until we are up on Xtext 0.8 with better scoping and linking.
		//// For now, this is just proof of concept.
		////
		public ParserRule getRule() { return rule; }

		//ClosureTypeRef|SimpleTypeRef 
		//
		//// TODO: typereference is simplified to only the name of a java type - for model imports
		//// the model is imported with name == namespace, and types in the model are referenced after
		//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
		//// referenced as mymodel::mytype
		//// There is more work required to link a reference to such a type and it is therefore deferred
		//// until we are up on Xtext 0.8 with better scoping and linking.
		//// For now, this is just proof of concept.
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//ClosureTypeRef
		public RuleCall getClosureTypeRefParserRuleCall_0() { return cClosureTypeRefParserRuleCall_0; }

		//SimpleTypeRef
		public RuleCall getSimpleTypeRefParserRuleCall_1() { return cSimpleTypeRefParserRuleCall_1; }
	}

	public class SimpleTypeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleTypeRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3ParameterizedTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cRawTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cRawTypeB3JavaImportCrossReference_1_0 = (CrossReference)cRawTypeAssignment_1.eContents().get(0);
		private final RuleCall cRawTypeB3JavaImportIDTerminalRuleCall_1_0_1 = (RuleCall)cRawTypeB3JavaImportCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLessThanSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cActualArgumentsListAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cActualArgumentsListB3JavaImportCrossReference_2_1_0 = (CrossReference)cActualArgumentsListAssignment_2_1.eContents().get(0);
		private final RuleCall cActualArgumentsListB3JavaImportIDTerminalRuleCall_2_1_0_1 = (RuleCall)cActualArgumentsListB3JavaImportCrossReference_2_1_0.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cActualArgumentsListAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final CrossReference cActualArgumentsListB3JavaImportCrossReference_2_2_1_0 = (CrossReference)cActualArgumentsListAssignment_2_2_1.eContents().get(0);
		private final RuleCall cActualArgumentsListB3JavaImportIDTerminalRuleCall_2_2_1_0_1 = (RuleCall)cActualArgumentsListB3JavaImportCrossReference_2_2_1_0.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		
		//SimpleTypeRef returns be::IType:
		//  {be::B3ParameterizedType} rawType=[be::B3JavaImport] ("<" actualArgumentsList+=[be
		//  ::B3JavaImport] ("," actualArgumentsList+=[be::B3JavaImport])* ">")?;  
		//	
		//         
		//	     
		//		                  
		////		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
		//	 
		//	
		//
		//// ClosureTypeRef declares parameters and return type	
		//// TODO: use TypeRef instead of direct reference to imported class
		public ParserRule getRule() { return rule; }

		//{be::B3ParameterizedType} rawType=[be::B3JavaImport] ("<" actualArgumentsList+=[be
		//::B3JavaImport] ("," actualArgumentsList+=[be::B3JavaImport])* ">")?    
		//	     
		//		                  
		////		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
		public Group getGroup() { return cGroup; }

		//{be::B3ParameterizedType}
		public Action getB3ParameterizedTypeAction_0() { return cB3ParameterizedTypeAction_0; }

		//rawType=[be::B3JavaImport]
		public Assignment getRawTypeAssignment_1() { return cRawTypeAssignment_1; }

		//[be::B3JavaImport]
		public CrossReference getRawTypeB3JavaImportCrossReference_1_0() { return cRawTypeB3JavaImportCrossReference_1_0; }

		//ID
		public RuleCall getRawTypeB3JavaImportIDTerminalRuleCall_1_0_1() { return cRawTypeB3JavaImportIDTerminalRuleCall_1_0_1; }

		//("<" actualArgumentsList+=[be::B3JavaImport] ("," actualArgumentsList+=[be::
		//B3JavaImport])* ">")?
		public Group getGroup_2() { return cGroup_2; }

		//"<"
		public Keyword getLessThanSignKeyword_2_0() { return cLessThanSignKeyword_2_0; }

		//actualArgumentsList+=[be::B3JavaImport]
		public Assignment getActualArgumentsListAssignment_2_1() { return cActualArgumentsListAssignment_2_1; }

		//[be::B3JavaImport]
		public CrossReference getActualArgumentsListB3JavaImportCrossReference_2_1_0() { return cActualArgumentsListB3JavaImportCrossReference_2_1_0; }

		//ID
		public RuleCall getActualArgumentsListB3JavaImportIDTerminalRuleCall_2_1_0_1() { return cActualArgumentsListB3JavaImportIDTerminalRuleCall_2_1_0_1; }

		//("," actualArgumentsList+=[be::B3JavaImport])*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//actualArgumentsList+=[be::B3JavaImport]
		public Assignment getActualArgumentsListAssignment_2_2_1() { return cActualArgumentsListAssignment_2_2_1; }

		//[be::B3JavaImport]
		public CrossReference getActualArgumentsListB3JavaImportCrossReference_2_2_1_0() { return cActualArgumentsListB3JavaImportCrossReference_2_2_1_0; }

		//ID
		public RuleCall getActualArgumentsListB3JavaImportIDTerminalRuleCall_2_2_1_0_1() { return cActualArgumentsListB3JavaImportIDTerminalRuleCall_2_2_1_0_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_2_3() { return cGreaterThanSignKeyword_2_3; }
	}

	public class ClosureTypeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClosureTypeRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3FunctionTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cAlternatives_1_1.eContents().get(0);
		private final Assignment cParameterTypesAssignment_1_1_0_0 = (Assignment)cGroup_1_1_0.eContents().get(0);
		private final CrossReference cParameterTypesB3JavaImportCrossReference_1_1_0_0_0 = (CrossReference)cParameterTypesAssignment_1_1_0_0.eContents().get(0);
		private final RuleCall cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_0_0_1 = (RuleCall)cParameterTypesB3JavaImportCrossReference_1_1_0_0_0.eContents().get(1);
		private final Group cGroup_1_1_0_1 = (Group)cGroup_1_1_0.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0_1_0 = (Keyword)cGroup_1_1_0_1.eContents().get(0);
		private final Assignment cParameterTypesAssignment_1_1_0_1_1 = (Assignment)cGroup_1_1_0_1.eContents().get(1);
		private final CrossReference cParameterTypesB3JavaImportCrossReference_1_1_0_1_1_0 = (CrossReference)cParameterTypesAssignment_1_1_0_1_1.eContents().get(0);
		private final RuleCall cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_1_1_0_1 = (RuleCall)cParameterTypesB3JavaImportCrossReference_1_1_0_1_1_0.eContents().get(1);
		private final Group cGroup_1_1_0_2 = (Group)cGroup_1_1_0.eContents().get(2);
		private final Keyword cCommaKeyword_1_1_0_2_0 = (Keyword)cGroup_1_1_0_2.eContents().get(0);
		private final Assignment cVarArgsAssignment_1_1_0_2_1 = (Assignment)cGroup_1_1_0_2.eContents().get(1);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_1_1_0_2_1_0 = (Keyword)cVarArgsAssignment_1_1_0_2_1.eContents().get(0);
		private final Assignment cParameterTypesAssignment_1_1_0_2_2 = (Assignment)cGroup_1_1_0_2.eContents().get(2);
		private final CrossReference cParameterTypesB3JavaImportCrossReference_1_1_0_2_2_0 = (CrossReference)cParameterTypesAssignment_1_1_0_2_2.eContents().get(0);
		private final RuleCall cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_2_2_0_1 = (RuleCall)cParameterTypesB3JavaImportCrossReference_1_1_0_2_2_0.eContents().get(1);
		private final Group cGroup_1_1_1 = (Group)cAlternatives_1_1.eContents().get(1);
		private final Assignment cVarArgsAssignment_1_1_1_0 = (Assignment)cGroup_1_1_1.eContents().get(0);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_1_1_1_0_0 = (Keyword)cVarArgsAssignment_1_1_1_0.eContents().get(0);
		private final Assignment cParameterTypesAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final CrossReference cParameterTypesB3JavaImportCrossReference_1_1_1_1_0 = (CrossReference)cParameterTypesAssignment_1_1_1_1.eContents().get(0);
		private final RuleCall cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_1_1_0_1 = (RuleCall)cParameterTypesB3JavaImportCrossReference_1_1_1_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cReturnTypeAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final CrossReference cReturnTypeB3JavaImportCrossReference_1_4_0 = (CrossReference)cReturnTypeAssignment_1_4.eContents().get(0);
		private final RuleCall cReturnTypeB3JavaImportIDTerminalRuleCall_1_4_0_1 = (RuleCall)cReturnTypeB3JavaImportCrossReference_1_4_0.eContents().get(1);
		
		//ClosureTypeRef returns be::IType:
		//  {be::B3FunctionType} ("(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[
		//  be::B3JavaImport])* ("," varArgs?="..." parameterTypes+=[be::B3JavaImport])?|
		//  varArgs?="..." parameterTypes+=[be::B3JavaImport])? ")" "=>" returnType=[be::
		//  B3JavaImport]); 
		//	
		//
		//// ClosureTypeRef declares parameters and return type	
		//// TODO: use TypeRef instead of direct reference to imported class
		//         
		//	
		//		                     
		//			                
		//		 	                    
		//		 
		//	              
		//	
		//
		//// TODO: TypeParam's and Wildcard refs currently unused. Support should be added
		////
		public ParserRule getRule() { return rule; }

		//{be::B3FunctionType} ("(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[
		//be::B3JavaImport])* ("," varArgs?="..." parameterTypes+=[be::B3JavaImport])?|
		//varArgs?="..." parameterTypes+=[be::B3JavaImport])? ")" "=>" returnType=[be::
		//B3JavaImport])
		public Group getGroup() { return cGroup; }

		//{be::B3FunctionType}
		public Action getB3FunctionTypeAction_0() { return cB3FunctionTypeAction_0; }

		//"(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[be::B3JavaImport])* (
		//"," varArgs?="..." parameterTypes+=[be::B3JavaImport])?|varArgs?="..."
		//parameterTypes+=[be::B3JavaImport])? ")" "=>" returnType=[be::B3JavaImport]
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//(parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[be::B3JavaImport])* (","
		//varArgs?="..." parameterTypes+=[be::B3JavaImport])?|varArgs?="..." parameterTypes
		//+=[be::B3JavaImport])?
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[be::B3JavaImport])* (","
		//varArgs?="..." parameterTypes+=[be::B3JavaImport])?
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }

		//parameterTypes+=[be::B3JavaImport]
		public Assignment getParameterTypesAssignment_1_1_0_0() { return cParameterTypesAssignment_1_1_0_0; }

		//[be::B3JavaImport]
		public CrossReference getParameterTypesB3JavaImportCrossReference_1_1_0_0_0() { return cParameterTypesB3JavaImportCrossReference_1_1_0_0_0; }

		//ID
		public RuleCall getParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_0_0_1() { return cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_0_0_1; }

		//("," parameterTypes+=[be::B3JavaImport])*
		public Group getGroup_1_1_0_1() { return cGroup_1_1_0_1; }

		//","
		public Keyword getCommaKeyword_1_1_0_1_0() { return cCommaKeyword_1_1_0_1_0; }

		//parameterTypes+=[be::B3JavaImport]
		public Assignment getParameterTypesAssignment_1_1_0_1_1() { return cParameterTypesAssignment_1_1_0_1_1; }

		//[be::B3JavaImport]
		public CrossReference getParameterTypesB3JavaImportCrossReference_1_1_0_1_1_0() { return cParameterTypesB3JavaImportCrossReference_1_1_0_1_1_0; }

		//ID
		public RuleCall getParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_1_1_0_1() { return cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_1_1_0_1; }

		//("," varArgs?="..." parameterTypes+=[be::B3JavaImport])?
		public Group getGroup_1_1_0_2() { return cGroup_1_1_0_2; }

		//","
		public Keyword getCommaKeyword_1_1_0_2_0() { return cCommaKeyword_1_1_0_2_0; }

		//varArgs?="..."
		public Assignment getVarArgsAssignment_1_1_0_2_1() { return cVarArgsAssignment_1_1_0_2_1; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_1_1_0_2_1_0() { return cVarArgsFullStopFullStopFullStopKeyword_1_1_0_2_1_0; }

		//parameterTypes+=[be::B3JavaImport]
		public Assignment getParameterTypesAssignment_1_1_0_2_2() { return cParameterTypesAssignment_1_1_0_2_2; }

		//[be::B3JavaImport]
		public CrossReference getParameterTypesB3JavaImportCrossReference_1_1_0_2_2_0() { return cParameterTypesB3JavaImportCrossReference_1_1_0_2_2_0; }

		//ID
		public RuleCall getParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_2_2_0_1() { return cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_2_2_0_1; }

		//varArgs?="..." parameterTypes+=[be::B3JavaImport]
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//varArgs?="..."
		public Assignment getVarArgsAssignment_1_1_1_0() { return cVarArgsAssignment_1_1_1_0; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_1_1_1_0_0() { return cVarArgsFullStopFullStopFullStopKeyword_1_1_1_0_0; }

		//parameterTypes+=[be::B3JavaImport]
		public Assignment getParameterTypesAssignment_1_1_1_1() { return cParameterTypesAssignment_1_1_1_1; }

		//[be::B3JavaImport]
		public CrossReference getParameterTypesB3JavaImportCrossReference_1_1_1_1_0() { return cParameterTypesB3JavaImportCrossReference_1_1_1_1_0; }

		//ID
		public RuleCall getParameterTypesB3JavaImportIDTerminalRuleCall_1_1_1_1_0_1() { return cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_1_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1_3() { return cEqualsSignGreaterThanSignKeyword_1_3; }

		//returnType=[be::B3JavaImport]
		public Assignment getReturnTypeAssignment_1_4() { return cReturnTypeAssignment_1_4; }

		//[be::B3JavaImport]
		public CrossReference getReturnTypeB3JavaImportCrossReference_1_4_0() { return cReturnTypeB3JavaImportCrossReference_1_4_0; }

		//ID
		public RuleCall getReturnTypeB3JavaImportIDTerminalRuleCall_1_4_0_1() { return cReturnTypeB3JavaImportIDTerminalRuleCall_1_4_0_1; }
	}

	public class TypeParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeParam");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeRefParamParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWildcardRefParamParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TypeParam returns be::IType:
		//  TypeRefParam|WildcardRefParam; 
		//
		//// TODO: TypeParam's and Wildcard refs currently unused. Support should be added
		////
		public ParserRule getRule() { return rule; }

		//TypeRefParam|WildcardRefParam 
		//
		//// TODO: TypeParam's and Wildcard refs currently unused. Support should be added
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeRefParam
		public RuleCall getTypeRefParamParserRuleCall_0() { return cTypeRefParamParserRuleCall_0; }

		//WildcardRefParam
		public RuleCall getWildcardRefParamParserRuleCall_1() { return cWildcardRefParamParserRuleCall_1; }
	}

	public class TypeRefParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeRefParam");
		private final RuleCall cTypeRefParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TypeRefParam returns be::IType:
		//  TypeRef;
		public ParserRule getRule() { return rule; }

		//TypeRef
		public RuleCall getTypeRefParserRuleCall() { return cTypeRefParserRuleCall; }
	}

	public class WildcardRefParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WildcardRefParam");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3WildcardTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cExtendsKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cUpperBoundsListAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cUpperBoundsListTypeRefParserRuleCall_2_0_1_0 = (RuleCall)cUpperBoundsListAssignment_2_0_1.eContents().get(0);
		private final Group cGroup_2_0_2 = (Group)cGroup_2_0.eContents().get(2);
		private final Keyword cCommaKeyword_2_0_2_0 = (Keyword)cGroup_2_0_2.eContents().get(0);
		private final Assignment cUpperBoundsListAssignment_2_0_2_1 = (Assignment)cGroup_2_0_2.eContents().get(1);
		private final RuleCall cUpperBoundsListTypeRefParserRuleCall_2_0_2_1_0 = (RuleCall)cUpperBoundsListAssignment_2_0_2_1.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cSuperKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cLowerBoundsListAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cLowerBoundsListTypeRefParserRuleCall_2_1_1_0 = (RuleCall)cLowerBoundsListAssignment_2_1_1.eContents().get(0);
		
		//WildcardRefParam returns be::IType:
		//  {be::B3WildcardType} "?" ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=
		//  TypeRef)*|"super" lowerBoundsList+=TypeRef)?;
		public ParserRule getRule() { return rule; }

		//{be::B3WildcardType} "?" ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=
		//TypeRef)*|"super" lowerBoundsList+=TypeRef)?
		public Group getGroup() { return cGroup; }

		//{be::B3WildcardType}
		public Action getB3WildcardTypeAction_0() { return cB3WildcardTypeAction_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1() { return cQuestionMarkKeyword_1; }

		//("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=TypeRef)*|"super"
		//lowerBoundsList+=TypeRef)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"extends" upperBoundsList+=TypeRef ("," upperBoundsList+=TypeRef)*
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"extends"
		public Keyword getExtendsKeyword_2_0_0() { return cExtendsKeyword_2_0_0; }

		//upperBoundsList+=TypeRef
		public Assignment getUpperBoundsListAssignment_2_0_1() { return cUpperBoundsListAssignment_2_0_1; }

		//TypeRef
		public RuleCall getUpperBoundsListTypeRefParserRuleCall_2_0_1_0() { return cUpperBoundsListTypeRefParserRuleCall_2_0_1_0; }

		//("," upperBoundsList+=TypeRef)*
		public Group getGroup_2_0_2() { return cGroup_2_0_2; }

		//","
		public Keyword getCommaKeyword_2_0_2_0() { return cCommaKeyword_2_0_2_0; }

		//upperBoundsList+=TypeRef
		public Assignment getUpperBoundsListAssignment_2_0_2_1() { return cUpperBoundsListAssignment_2_0_2_1; }

		//TypeRef
		public RuleCall getUpperBoundsListTypeRefParserRuleCall_2_0_2_1_0() { return cUpperBoundsListTypeRefParserRuleCall_2_0_2_1_0; }

		//"super" lowerBoundsList+=TypeRef
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"super"
		public Keyword getSuperKeyword_2_1_0() { return cSuperKeyword_2_1_0; }

		//lowerBoundsList+=TypeRef
		public Assignment getLowerBoundsListAssignment_2_1_1() { return cLowerBoundsListAssignment_2_1_1; }

		//TypeRef
		public RuleCall getLowerBoundsListTypeRefParserRuleCall_2_1_1_0() { return cLowerBoundsListTypeRefParserRuleCall_2_1_1_0; }
	}

	public class CachedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CachedExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBCachedExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cCachedKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExprAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExprOrExpressionParserRuleCall_0_2_0 = (RuleCall)cExprAssignment_0_2.eContents().get(0);
		private final RuleCall cOrExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//CachedExpression returns be::BExpression:
		//  {be::BCachedExpression} "cached" expr=OrExpression|OrExpression;
		public ParserRule getRule() { return rule; }

		//{be::BCachedExpression} "cached" expr=OrExpression|OrExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{be::BCachedExpression} "cached" expr=OrExpression
		public Group getGroup_0() { return cGroup_0; }

		//{be::BCachedExpression}
		public Action getBCachedExpressionAction_0_0() { return cBCachedExpressionAction_0_0; }

		//"cached"
		public Keyword getCachedKeyword_0_1() { return cCachedKeyword_0_1; }

		//expr=OrExpression
		public Assignment getExprAssignment_0_2() { return cExprAssignment_0_2; }

		//OrExpression
		public RuleCall getExprOrExpressionParserRuleCall_0_2_0() { return cExprOrExpressionParserRuleCall_0_2_0; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_1() { return cOrExpressionParserRuleCall_1; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBOrExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//OrExpression returns be::BExpression:
		//  AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*;
		public ParserRule getRule() { return rule; }

		//AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BOrExpression.leftExpr=current}
		public Action getBOrExpressionLeftExprAction_1_0() { return cBOrExpressionLeftExprAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//rightExpr=AndExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//AndExpression
		public RuleCall getRightExprAndExpressionParserRuleCall_1_2_0() { return cRightExprAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBAndExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprRelationalExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//AndExpression returns be::BExpression:
		//  RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
		//  RelationalExpression)*; 
		//	
		//      
		//	      
		//	
		//
		//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language with a different grammar).
		//// BitwiseExpression returns be::BExpression :
		//// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
		//RelationalExpression)*
		public Group getGroup() { return cGroup; }

		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }

		//({be::BAndExpression.leftExpr=current} "&&" rightExpr=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BAndExpression.leftExpr=current}
		public Action getBAndExpressionLeftExprAction_1_0() { return cBAndExpressionLeftExprAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//rightExpr=RelationalExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//RelationalExpression
		public RuleCall getRightExprRelationalExpressionParserRuleCall_1_2_0() { return cRightExprRelationalExpressionParserRuleCall_1_2_0; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInstanceOfExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFunctionNameRelationalOperatorParserRuleCall_1_1_0 = (RuleCall)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprInstanceOfExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//RelationalExpression returns be::BExpression:
		//  InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//  RelationalOperator rightExpr=InstanceOfExpression)*; 
		//
		//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language with a different grammar).
		//// BitwiseExpression returns be::BExpression :
		//// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//RelationalOperator rightExpr=InstanceOfExpression)*
		public Group getGroup() { return cGroup; }

		//InstanceOfExpression
		public RuleCall getInstanceOfExpressionParserRuleCall_0() { return cInstanceOfExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName=RelationalOperator
		//rightExpr=InstanceOfExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName=RelationalOperator
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//RelationalOperator
		public RuleCall getFunctionNameRelationalOperatorParserRuleCall_1_1_0() { return cFunctionNameRelationalOperatorParserRuleCall_1_1_0; }

		//rightExpr=InstanceOfExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//InstanceOfExpression
		public RuleCall getRightExprInstanceOfExpressionParserRuleCall_1_2_0() { return cRightExprInstanceOfExpressionParserRuleCall_1_2_0; }
	}

	public class InstanceOfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstanceOfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cFunctionNameInstanceofKeyword_1_1_0 = (Keyword)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprLiteralTypeParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//InstanceOfExpression returns be::BExpression:
		//  AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//  "instanceof" rightExpr=LiteralType)*; 
		//
		//      
		//	        
		//	
		//
		//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language with a different grammar).
		//// ShiftExpression returns be::BExpression:
		//// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
		public ParserRule getRule() { return rule; }

		//AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//"instanceof" rightExpr=LiteralType)*
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName="instanceof" rightExpr=
		//LiteralType)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName="instanceof"
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//"instanceof"
		public Keyword getFunctionNameInstanceofKeyword_1_1_0() { return cFunctionNameInstanceofKeyword_1_1_0; }

		//rightExpr=LiteralType
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//LiteralType
		public RuleCall getRightExprLiteralTypeParserRuleCall_1_2_0() { return cRightExprLiteralTypeParserRuleCall_1_2_0; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_1_0 = (Alternatives)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Keyword cFunctionNamePlusSignKeyword_1_1_0_0 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cFunctionNameHyphenMinusKeyword_1_1_0_1 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//AdditiveExpression returns be::BExpression:
		//  MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//  ( "+" | "-" ) rightExpr=MultiplicativeExpression)*; 
		//
		//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language with a different grammar).
		//// ShiftExpression returns be::BExpression:
		//// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
		public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//( "+" | "-" ) rightExpr=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName=( "+" | "-" ) rightExpr=
		//MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName=( "+" | "-" )
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//"+"|"-"
		public Alternatives getFunctionNameAlternatives_1_1_0() { return cFunctionNameAlternatives_1_1_0; }

		//"+"
		public Keyword getFunctionNamePlusSignKeyword_1_1_0_0() { return cFunctionNamePlusSignKeyword_1_1_0_0; }

		//"-"
		public Keyword getFunctionNameHyphenMinusKeyword_1_1_0_1() { return cFunctionNameHyphenMinusKeyword_1_1_0_1; }

		//rightExpr=MultiplicativeExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//MultiplicativeExpression
		public RuleCall getRightExprMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightExprMultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSetExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_1_0 = (Alternatives)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Keyword cFunctionNameAsteriskKeyword_1_1_0_0 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cFunctionNameSolidusKeyword_1_1_0_1 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(1);
		private final Keyword cFunctionNamePercentSignKeyword_1_1_0_2 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprSetExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//MultiplicativeExpression returns be::BExpression:
		//  SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" |
		//  "%" ) rightExpr=SetExpression)*;
		public ParserRule getRule() { return rule; }

		//SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" |
		//"%" ) rightExpr=SetExpression)*
		public Group getGroup() { return cGroup; }

		//SetExpression
		public RuleCall getSetExpressionParserRuleCall_0() { return cSetExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" | "%" ) rightExpr=
		//SetExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName=( "*" | "/" | "%" )
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//"*"|"/"|"%"
		public Alternatives getFunctionNameAlternatives_1_1_0() { return cFunctionNameAlternatives_1_1_0; }

		//"*"
		public Keyword getFunctionNameAsteriskKeyword_1_1_0_0() { return cFunctionNameAsteriskKeyword_1_1_0_0; }

		//"/"
		public Keyword getFunctionNameSolidusKeyword_1_1_0_1() { return cFunctionNameSolidusKeyword_1_1_0_1; }

		//"%"
		public Keyword getFunctionNamePercentSignKeyword_1_1_0_2() { return cFunctionNamePercentSignKeyword_1_1_0_2; }

		//rightExpr=SetExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//SetExpression
		public RuleCall getRightExprSetExpressionParserRuleCall_1_2_0() { return cRightExprSetExpressionParserRuleCall_1_2_0; }
	}

	public class SetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOrInfixExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cFunctionNameFullStopFullStopKeyword_1_1_0 = (Keyword)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprUnaryOrInfixExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//SetExpression returns be::BExpression:
		//  UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//  ".." rightExpr=UnaryOrInfixExpression)*;
		public ParserRule getRule() { return rule; }

		//UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//".." rightExpr=UnaryOrInfixExpression)*
		public Group getGroup() { return cGroup; }

		//UnaryOrInfixExpression
		public RuleCall getUnaryOrInfixExpressionParserRuleCall_0() { return cUnaryOrInfixExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName=".." rightExpr=
		//UnaryOrInfixExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName=".."
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//".."
		public Keyword getFunctionNameFullStopFullStopKeyword_1_1_0() { return cFunctionNameFullStopFullStopKeyword_1_1_0; }

		//rightExpr=UnaryOrInfixExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//UnaryOrInfixExpression
		public RuleCall getRightExprUnaryOrInfixExpressionParserRuleCall_1_2_0() { return cRightExprUnaryOrInfixExpressionParserRuleCall_1_2_0; }
	}

	public class UnaryOrInfixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOrInfixExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPostopExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPreopExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//UnaryOrInfixExpression returns be::BExpression:
		//  PostopExpression|UnaryExpression|PreopExpression; 
		//
		//    
		//	   
		//	  
		//	  
		//	 
		//	
		//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language with a different grammar).
		//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
		//// UnaryExpression returns be::BExpression:
		////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
		public ParserRule getRule() { return rule; }

		//PostopExpression|UnaryExpression|PreopExpression 
		//
		//    
		//	   
		//	  
		//	  
		//	 
		//	
		//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language with a different grammar).
		//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
		//// UnaryExpression returns be::BExpression:
		////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
		public Alternatives getAlternatives() { return cAlternatives; }

		//PostopExpression
		public RuleCall getPostopExpressionParserRuleCall_0() { return cPostopExpressionParserRuleCall_0; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_1() { return cUnaryExpressionParserRuleCall_1; }

		//PreopExpression
		public RuleCall getPreopExpressionParserRuleCall_2() { return cPreopExpressionParserRuleCall_2; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBUnaryOpExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_0 = (Alternatives)cFunctionNameAssignment_1.eContents().get(0);
		private final Keyword cFunctionNameExclamationMarkKeyword_1_0_0 = (Keyword)cFunctionNameAlternatives_1_0.eContents().get(0);
		private final Keyword cFunctionNameHyphenMinusKeyword_1_0_1 = (Keyword)cFunctionNameAlternatives_1_0.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprInfixExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//UnaryExpression returns be::BExpression:
		//  {be::BUnaryOpExpression} functionName=( "!" | "-" ) expr=InfixExpression;  
		//	
		//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language with a different grammar).
		//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
		//// UnaryExpression returns be::BExpression:
		////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
		public ParserRule getRule() { return rule; }

		//{be::BUnaryOpExpression} functionName=( "!" | "-" ) expr=InfixExpression
		public Group getGroup() { return cGroup; }

		//{be::BUnaryOpExpression}
		public Action getBUnaryOpExpressionAction_0() { return cBUnaryOpExpressionAction_0; }

		//functionName=( "!" | "-" )
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }

		//"!"|"-"
		public Alternatives getFunctionNameAlternatives_1_0() { return cFunctionNameAlternatives_1_0; }

		//"!"
		public Keyword getFunctionNameExclamationMarkKeyword_1_0_0() { return cFunctionNameExclamationMarkKeyword_1_0_0; }

		//"-"
		public Keyword getFunctionNameHyphenMinusKeyword_1_0_1() { return cFunctionNameHyphenMinusKeyword_1_0_1; }

		//expr=InfixExpression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//InfixExpression
		public RuleCall getExprInfixExpressionParserRuleCall_2_0() { return cExprInfixExpressionParserRuleCall_2_0; }
	}

	public class PreopExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreopExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBUnaryPreOpExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_0 = (Alternatives)cFunctionNameAssignment_1.eContents().get(0);
		private final Keyword cFunctionNamePlusSignPlusSignKeyword_1_0_0 = (Keyword)cFunctionNameAlternatives_1_0.eContents().get(0);
		private final Keyword cFunctionNameHyphenMinusHyphenMinusKeyword_1_0_1 = (Keyword)cFunctionNameAlternatives_1_0.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprInfixExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//PreopExpression returns be::BExpression:
		//  {be::BUnaryPreOpExpression} functionName=( "++" | "--" ) expr=InfixExpression;
		public ParserRule getRule() { return rule; }

		//{be::BUnaryPreOpExpression} functionName=( "++" | "--" ) expr=InfixExpression
		public Group getGroup() { return cGroup; }

		//{be::BUnaryPreOpExpression}
		public Action getBUnaryPreOpExpressionAction_0() { return cBUnaryPreOpExpressionAction_0; }

		//functionName=( "++" | "--" )
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }

		//"++"|"--"
		public Alternatives getFunctionNameAlternatives_1_0() { return cFunctionNameAlternatives_1_0; }

		//"++"
		public Keyword getFunctionNamePlusSignPlusSignKeyword_1_0_0() { return cFunctionNamePlusSignPlusSignKeyword_1_0_0; }

		//"--"
		public Keyword getFunctionNameHyphenMinusHyphenMinusKeyword_1_0_1() { return cFunctionNameHyphenMinusHyphenMinusKeyword_1_0_1; }

		//expr=InfixExpression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//InfixExpression
		public RuleCall getExprInfixExpressionParserRuleCall_2_0() { return cExprInfixExpressionParserRuleCall_2_0; }
	}

	public class PostopExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostopExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBUnaryPostOpExpressionExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_1_0 = (Alternatives)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Keyword cFunctionNameHyphenMinusHyphenMinusKeyword_1_1_0_0 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cFunctionNamePlusSignPlusSignKeyword_1_1_0_1 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(1);
		
		//PostopExpression returns be::BExpression:
		//  InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++"
		//  ))?;
		public ParserRule getRule() { return rule; }

		//InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++"
		//))?
		public Group getGroup() { return cGroup; }

		//InfixExpression
		public RuleCall getInfixExpressionParserRuleCall_0() { return cInfixExpressionParserRuleCall_0; }

		//({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++" ))?
		public Group getGroup_1() { return cGroup_1; }

		//{be::BUnaryPostOpExpression.expr=current}
		public Action getBUnaryPostOpExpressionExprAction_1_0() { return cBUnaryPostOpExpressionExprAction_1_0; }

		//functionName=( "--" | "++" )
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//"--"|"++"
		public Alternatives getFunctionNameAlternatives_1_1_0() { return cFunctionNameAlternatives_1_1_0; }

		//"--"
		public Keyword getFunctionNameHyphenMinusHyphenMinusKeyword_1_1_0_0() { return cFunctionNameHyphenMinusHyphenMinusKeyword_1_1_0_0; }

		//"++"
		public Keyword getFunctionNamePlusSignPlusSignKeyword_1_1_0_1() { return cFunctionNamePlusSignPlusSignKeyword_1_1_0_1; }
	}

	public class InfixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCallExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cBCallExpressionFuncExprAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cNameAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_1_0_2_0 = (RuleCall)cNameAssignment_1_0_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_0_3 = (Keyword)cGroup_1_0.eContents().get(3);
		private final Assignment cParameterListAssignment_1_0_4 = (Assignment)cGroup_1_0.eContents().get(4);
		private final RuleCall cParameterListParameterListParserRuleCall_1_0_4_0 = (RuleCall)cParameterListAssignment_1_0_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_0_5 = (Keyword)cGroup_1_0.eContents().get(5);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cBAtExpressionObjExprAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cIndexExprAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cIndexExprExpressionParserRuleCall_1_1_2_0 = (RuleCall)cIndexExprAssignment_1_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_3 = (Keyword)cGroup_1_1.eContents().get(3);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cBFeatureExpressionObjExprAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cFullStopKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cFeatureNameAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cFeatureNameIDTerminalRuleCall_1_2_2_0 = (RuleCall)cFeatureNameAssignment_1_2_2.eContents().get(0);
		
		//InfixExpression returns be::BExpression:
		//  CallExpression ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=
		//  ParameterList? ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|
		//  {be::BFeatureExpression.objExpr=current} "." featureName=ID)*;
		public ParserRule getRule() { return rule; }

		//CallExpression ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=
		//ParameterList? ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|
		//{be::BFeatureExpression.objExpr=current} "." featureName=ID)*
		public Group getGroup() { return cGroup; }

		//CallExpression
		public RuleCall getCallExpressionParserRuleCall_0() { return cCallExpressionParserRuleCall_0; }

		//({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=ParameterList?
		//")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|{be::
		//BFeatureExpression.objExpr=current} "." featureName=ID)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=ParameterList?
		//")"
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{be::BCallExpression.funcExpr=current}
		public Action getBCallExpressionFuncExprAction_1_0_0() { return cBCallExpressionFuncExprAction_1_0_0; }

		//"."
		public Keyword getFullStopKeyword_1_0_1() { return cFullStopKeyword_1_0_1; }

		//name=ID
		public Assignment getNameAssignment_1_0_2() { return cNameAssignment_1_0_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_2_0() { return cNameIDTerminalRuleCall_1_0_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0_3() { return cLeftParenthesisKeyword_1_0_3; }

		//parameterList=ParameterList?
		public Assignment getParameterListAssignment_1_0_4() { return cParameterListAssignment_1_0_4; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_1_0_4_0() { return cParameterListParameterListParserRuleCall_1_0_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_0_5() { return cRightParenthesisKeyword_1_0_5; }

		//{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{be::BAtExpression.objExpr=current}
		public Action getBAtExpressionObjExprAction_1_1_0() { return cBAtExpressionObjExprAction_1_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1_1() { return cLeftSquareBracketKeyword_1_1_1; }

		//indexExpr=Expression
		public Assignment getIndexExprAssignment_1_1_2() { return cIndexExprAssignment_1_1_2; }

		//Expression
		public RuleCall getIndexExprExpressionParserRuleCall_1_1_2_0() { return cIndexExprExpressionParserRuleCall_1_1_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_1_3() { return cRightSquareBracketKeyword_1_1_3; }

		//{be::BFeatureExpression.objExpr=current} "." featureName=ID
		public Group getGroup_1_2() { return cGroup_1_2; }

		//{be::BFeatureExpression.objExpr=current}
		public Action getBFeatureExpressionObjExprAction_1_2_0() { return cBFeatureExpressionObjExprAction_1_2_0; }

		//"."
		public Keyword getFullStopKeyword_1_2_1() { return cFullStopKeyword_1_2_1; }

		//featureName=ID
		public Assignment getFeatureNameAssignment_1_2_2() { return cFeatureNameAssignment_1_2_2; }

		//ID
		public RuleCall getFeatureNameIDTerminalRuleCall_1_2_2_0() { return cFeatureNameIDTerminalRuleCall_1_2_2_0; }
	}

	public class CallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBCallExpressionFuncExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cParameterListAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cParameterListParameterListParserRuleCall_1_2_0 = (RuleCall)cParameterListAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//CallExpression returns be::BExpression:
		//  PrimaryExpression ({be::BCallExpression.funcExpr=current} "(" parameterList=
		//  ParameterList? ")")*;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression ({be::BCallExpression.funcExpr=current} "(" parameterList=
		//ParameterList? ")")*
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//({be::BCallExpression.funcExpr=current} "(" parameterList=ParameterList? ")")*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BCallExpression.funcExpr=current}
		public Action getBCallExpressionFuncExprAction_1_0() { return cBCallExpressionFuncExprAction_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//parameterList=ParameterList?
		public Assignment getParameterListAssignment_1_2() { return cParameterListAssignment_1_2; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_1_2_0() { return cParameterListParameterListParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFeatureCallParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstructorCallExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPropertyValueParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cKeywordVariablesParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cParanthesizedExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cIfExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cBlockExpressionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cSwitchExpressionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cThrowExpressionParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cTryCatchExpressionParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cWildcardExpressionParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		
		//PrimaryExpression returns be::BExpression:
		//  FeatureCall|ConstructorCallExpression|VariableValue|Literal|PropertyValue|
		//  KeywordVariables|ParanthesizedExpression|IfExpression|BlockExpression|
		//  SwitchExpression|ThrowExpression|TryCatchExpression|WildcardExpression; 
		//		
		//    
		//	  
		//	  
		//	  
		//	   
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		////	| WithExpression
		//	 
		//	
		////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
		////WithClauseExpression returns Expression : {WithClauseExpression} 
		////	withclause=WithClause expr = BlockExpression 
		////	;
		////WithContextExpression returns Expresion : {WithContextExpression } 
		////	"with" "context" context = Expression expr = BlockExpression
		////	;
		public ParserRule getRule() { return rule; }

		//FeatureCall|ConstructorCallExpression|VariableValue|Literal|PropertyValue|
		//KeywordVariables|ParanthesizedExpression|IfExpression|BlockExpression|
		//SwitchExpression|ThrowExpression|TryCatchExpression|WildcardExpression 
		//		
		//    
		//	  
		//	  
		//	  
		//	   
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		////	| WithExpression
		//	 
		//	
		////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
		////WithClauseExpression returns Expression : {WithClauseExpression} 
		////	withclause=WithClause expr = BlockExpression 
		////	;
		////WithContextExpression returns Expresion : {WithContextExpression } 
		////	"with" "context" context = Expression expr = BlockExpression
		////	;
		public Alternatives getAlternatives() { return cAlternatives; }

		//FeatureCall
		public RuleCall getFeatureCallParserRuleCall_0() { return cFeatureCallParserRuleCall_0; }

		//ConstructorCallExpression
		public RuleCall getConstructorCallExpressionParserRuleCall_1() { return cConstructorCallExpressionParserRuleCall_1; }

		//VariableValue
		public RuleCall getVariableValueParserRuleCall_2() { return cVariableValueParserRuleCall_2; }

		//Literal
		public RuleCall getLiteralParserRuleCall_3() { return cLiteralParserRuleCall_3; }

		//PropertyValue
		public RuleCall getPropertyValueParserRuleCall_4() { return cPropertyValueParserRuleCall_4; }

		//KeywordVariables
		public RuleCall getKeywordVariablesParserRuleCall_5() { return cKeywordVariablesParserRuleCall_5; }

		//ParanthesizedExpression
		public RuleCall getParanthesizedExpressionParserRuleCall_6() { return cParanthesizedExpressionParserRuleCall_6; }

		//IfExpression
		public RuleCall getIfExpressionParserRuleCall_7() { return cIfExpressionParserRuleCall_7; }

		//BlockExpression
		public RuleCall getBlockExpressionParserRuleCall_8() { return cBlockExpressionParserRuleCall_8; }

		//SwitchExpression
		public RuleCall getSwitchExpressionParserRuleCall_9() { return cSwitchExpressionParserRuleCall_9; }

		//ThrowExpression
		public RuleCall getThrowExpressionParserRuleCall_10() { return cThrowExpressionParserRuleCall_10; }

		//TryCatchExpression
		public RuleCall getTryCatchExpressionParserRuleCall_11() { return cTryCatchExpressionParserRuleCall_11; }

		//WildcardExpression   
		////	| WithExpression
		public RuleCall getWildcardExpressionParserRuleCall_12() { return cWildcardExpressionParserRuleCall_12; }
	}

	public class WildcardExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WildcardExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralAnyAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword c_Keyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//WildcardExpression returns be::BExpression:
		//  {be::BLiteralAny} "_"; 
		//	
		////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
		////WithClauseExpression returns Expression : {WithClauseExpression} 
		////	withclause=WithClause expr = BlockExpression 
		////	;
		////WithContextExpression returns Expresion : {WithContextExpression } 
		////	"with" "context" context = Expression expr = BlockExpression
		////	;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralAny} "_"
		public Group getGroup() { return cGroup; }

		//{be::BLiteralAny}
		public Action getBLiteralAnyAction_0() { return cBLiteralAnyAction_0; }

		//"_"
		public Keyword get_Keyword_1() { return c_Keyword_1; }
	}

	public class ThrowExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ThrowExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBThrowExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cThrowKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//ThrowExpression returns be::BExpression:
		//  {be::BThrowExpression} "throw" expr=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BThrowExpression} "throw" expr=Expression
		public Group getGroup() { return cGroup; }

		//{be::BThrowExpression}
		public Action getBThrowExpressionAction_0() { return cBThrowExpressionAction_0; }

		//"throw"
		public Keyword getThrowKeyword_1() { return cThrowKeyword_1; }

		//expr=Expression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }
	}

	public class TryCatchExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TryCatchExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBTryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTryKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTryExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTryExprExpressionParserRuleCall_2_0 = (RuleCall)cTryExprAssignment_2.eContents().get(0);
		private final Assignment cCatchBlocksAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCatchBlocksCatchBlockParserRuleCall_3_0 = (RuleCall)cCatchBlocksAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cFinallyKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cFinallyExprAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cFinallyExprExpressionParserRuleCall_4_1_0 = (RuleCall)cFinallyExprAssignment_4_1.eContents().get(0);
		private final Keyword cEndtryKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//TryCatchExpression returns be::BExpression:
		//  {be::BTryExpression} "try" tryExpr=Expression catchBlocks+=CatchBlock* ("finally"
		//  finallyExpr=Expression)? "endtry";
		public ParserRule getRule() { return rule; }

		//{be::BTryExpression} "try" tryExpr=Expression catchBlocks+=CatchBlock* ("finally"
		//finallyExpr=Expression)? "endtry"
		public Group getGroup() { return cGroup; }

		//{be::BTryExpression}
		public Action getBTryExpressionAction_0() { return cBTryExpressionAction_0; }

		//"try"
		public Keyword getTryKeyword_1() { return cTryKeyword_1; }

		//tryExpr=Expression
		public Assignment getTryExprAssignment_2() { return cTryExprAssignment_2; }

		//Expression
		public RuleCall getTryExprExpressionParserRuleCall_2_0() { return cTryExprExpressionParserRuleCall_2_0; }

		//catchBlocks+=CatchBlock*
		public Assignment getCatchBlocksAssignment_3() { return cCatchBlocksAssignment_3; }

		//CatchBlock
		public RuleCall getCatchBlocksCatchBlockParserRuleCall_3_0() { return cCatchBlocksCatchBlockParserRuleCall_3_0; }

		//("finally" finallyExpr=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"finally"
		public Keyword getFinallyKeyword_4_0() { return cFinallyKeyword_4_0; }

		//finallyExpr=Expression
		public Assignment getFinallyExprAssignment_4_1() { return cFinallyExprAssignment_4_1; }

		//Expression
		public RuleCall getFinallyExprExpressionParserRuleCall_4_1_0() { return cFinallyExprExpressionParserRuleCall_4_1_0; }

		//"endtry"
		public Keyword getEndtryKeyword_5() { return cEndtryKeyword_5; }
	}

	public class CatchBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CatchBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBCatchAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCatchKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExceptionTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExceptionTypeTypeRefParserRuleCall_2_0 = (RuleCall)cExceptionTypeAssignment_2.eContents().get(0);
		private final Assignment cVarnameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarnameIDTerminalRuleCall_3_0 = (RuleCall)cVarnameAssignment_3.eContents().get(0);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCatchExprAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCatchExprExpressionParserRuleCall_5_0 = (RuleCall)cCatchExprAssignment_5.eContents().get(0);
		
		//CatchBlock returns be::BCatch:
		//  {be::BCatch} "catch" exceptionType=TypeRef varname=ID ":" catchExpr=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BCatch} "catch" exceptionType=TypeRef varname=ID ":" catchExpr=Expression
		public Group getGroup() { return cGroup; }

		//{be::BCatch}
		public Action getBCatchAction_0() { return cBCatchAction_0; }

		//"catch"
		public Keyword getCatchKeyword_1() { return cCatchKeyword_1; }

		//exceptionType=TypeRef
		public Assignment getExceptionTypeAssignment_2() { return cExceptionTypeAssignment_2; }

		//TypeRef
		public RuleCall getExceptionTypeTypeRefParserRuleCall_2_0() { return cExceptionTypeTypeRefParserRuleCall_2_0; }

		//varname=ID
		public Assignment getVarnameAssignment_3() { return cVarnameAssignment_3; }

		//ID
		public RuleCall getVarnameIDTerminalRuleCall_3_0() { return cVarnameIDTerminalRuleCall_3_0; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//catchExpr=Expression
		public Assignment getCatchExprAssignment_5() { return cCatchExprAssignment_5; }

		//Expression
		public RuleCall getCatchExprExpressionParserRuleCall_5_0() { return cCatchExprExpressionParserRuleCall_5_0; }
	}

	public class SwitchExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SwitchExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBSwitchExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSwitchKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSwitchExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSwitchExpressionExpressionParserRuleCall_2_0 = (RuleCall)cSwitchExpressionAssignment_2.eContents().get(0);
		private final Assignment cCaseListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCaseListCaseParserRuleCall_3_0 = (RuleCall)cCaseListAssignment_3.eContents().get(0);
		private final Keyword cEndswitchKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SwitchExpression returns be::BExpression:
		//  {be::BSwitchExpression} "switch" switchExpression=Expression? caseList+=Case+
		//  "endswitch";
		public ParserRule getRule() { return rule; }

		//{be::BSwitchExpression} "switch" switchExpression=Expression? caseList+=Case+
		//"endswitch"
		public Group getGroup() { return cGroup; }

		//{be::BSwitchExpression}
		public Action getBSwitchExpressionAction_0() { return cBSwitchExpressionAction_0; }

		//"switch"
		public Keyword getSwitchKeyword_1() { return cSwitchKeyword_1; }

		//switchExpression=Expression?
		public Assignment getSwitchExpressionAssignment_2() { return cSwitchExpressionAssignment_2; }

		//Expression
		public RuleCall getSwitchExpressionExpressionParserRuleCall_2_0() { return cSwitchExpressionExpressionParserRuleCall_2_0; }

		//caseList+=Case+
		public Assignment getCaseListAssignment_3() { return cCaseListAssignment_3; }

		//Case
		public RuleCall getCaseListCaseParserRuleCall_3_0() { return cCaseListCaseParserRuleCall_3_0; }

		//"endswitch"
		public Keyword getEndswitchKeyword_4() { return cEndswitchKeyword_4; }
	}

	public class CaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Case");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBCaseAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCaseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExprExpressionParserRuleCall_2_0 = (RuleCall)cConditionExprAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenExprExpressionParserRuleCall_4_0 = (RuleCall)cThenExprAssignment_4.eContents().get(0);
		
		//Case returns be::BCase:
		//  {be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression
		public Group getGroup() { return cGroup; }

		//{be::BCase}
		public Action getBCaseAction_0() { return cBCaseAction_0; }

		//"case"
		public Keyword getCaseKeyword_1() { return cCaseKeyword_1; }

		//conditionExpr=Expression
		public Assignment getConditionExprAssignment_2() { return cConditionExprAssignment_2; }

		//Expression
		public RuleCall getConditionExprExpressionParserRuleCall_2_0() { return cConditionExprExpressionParserRuleCall_2_0; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//thenExpr=Expression
		public Assignment getThenExprAssignment_4() { return cThenExprAssignment_4; }

		//Expression
		public RuleCall getThenExprExpressionParserRuleCall_4_0() { return cThenExprExpressionParserRuleCall_4_0; }
	}

	public class BlockExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBChainedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpressionsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionsTopLevelExpressionParserRuleCall_2_0_0 = (RuleCall)cExpressionsAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BlockExpression returns be::BExpression:
		//  {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}";
		public ParserRule getRule() { return rule; }

		//{be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"
		public Group getGroup() { return cGroup; }

		//{be::BChainedExpression}
		public Action getBChainedExpressionAction_0() { return cBChainedExpressionAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(expressions+=TopLevelExpression ";")*
		public Group getGroup_2() { return cGroup_2; }

		//expressions+=TopLevelExpression
		public Assignment getExpressionsAssignment_2_0() { return cExpressionsAssignment_2_0; }

		//TopLevelExpression
		public RuleCall getExpressionsTopLevelExpressionParserRuleCall_2_0_0() { return cExpressionsTopLevelExpressionParserRuleCall_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class IfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBIfExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExprExpressionParserRuleCall_2_0 = (RuleCall)cConditionExprAssignment_2.eContents().get(0);
		private final Keyword cThenKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenExprExpressionParserRuleCall_4_0 = (RuleCall)cThenExprAssignment_4.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cElseExprAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cElseExprElseIfExpressionParserRuleCall_5_0_0 = (RuleCall)cElseExprAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cElseKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cElseExprAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cElseExprExpressionParserRuleCall_5_1_1_0 = (RuleCall)cElseExprAssignment_5_1_1.eContents().get(0);
		private final Keyword cEndifKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IfExpression returns be::BExpression:
		//  {be::BIfExpression} "if" conditionExpr=Expression "then" thenExpr=Expression (
		//  elseExpr=ElseIfExpression|"else" elseExpr=Expression)? "endif";
		public ParserRule getRule() { return rule; }

		//{be::BIfExpression} "if" conditionExpr=Expression "then" thenExpr=Expression (
		//elseExpr=ElseIfExpression|"else" elseExpr=Expression)? "endif"
		public Group getGroup() { return cGroup; }

		//{be::BIfExpression}
		public Action getBIfExpressionAction_0() { return cBIfExpressionAction_0; }

		//"if"
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }

		//conditionExpr=Expression
		public Assignment getConditionExprAssignment_2() { return cConditionExprAssignment_2; }

		//Expression
		public RuleCall getConditionExprExpressionParserRuleCall_2_0() { return cConditionExprExpressionParserRuleCall_2_0; }

		//"then"
		public Keyword getThenKeyword_3() { return cThenKeyword_3; }

		//thenExpr=Expression
		public Assignment getThenExprAssignment_4() { return cThenExprAssignment_4; }

		//Expression
		public RuleCall getThenExprExpressionParserRuleCall_4_0() { return cThenExprExpressionParserRuleCall_4_0; }

		//(elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//elseExpr=ElseIfExpression
		public Assignment getElseExprAssignment_5_0() { return cElseExprAssignment_5_0; }

		//ElseIfExpression
		public RuleCall getElseExprElseIfExpressionParserRuleCall_5_0_0() { return cElseExprElseIfExpressionParserRuleCall_5_0_0; }

		//"else" elseExpr=Expression
		public Group getGroup_5_1() { return cGroup_5_1; }

		//"else"
		public Keyword getElseKeyword_5_1_0() { return cElseKeyword_5_1_0; }

		//elseExpr=Expression
		public Assignment getElseExprAssignment_5_1_1() { return cElseExprAssignment_5_1_1; }

		//Expression
		public RuleCall getElseExprExpressionParserRuleCall_5_1_1_0() { return cElseExprExpressionParserRuleCall_5_1_1_0; }

		//"endif"
		public Keyword getEndifKeyword_6() { return cEndifKeyword_6; }
	}

	public class ElseIfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElseIfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBIfExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cElseifKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExprExpressionParserRuleCall_2_0 = (RuleCall)cConditionExprAssignment_2.eContents().get(0);
		private final Keyword cThenKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenExprExpressionParserRuleCall_4_0 = (RuleCall)cThenExprAssignment_4.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cElseExprAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cElseExprElseIfExpressionParserRuleCall_5_0_0 = (RuleCall)cElseExprAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cElseKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cElseExprAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cElseExprExpressionParserRuleCall_5_1_1_0 = (RuleCall)cElseExprAssignment_5_1_1.eContents().get(0);
		
		//ElseIfExpression returns be::BExpression:
		//  {be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression (
		//  elseExpr=ElseIfExpression|"else" elseExpr=Expression)?;
		public ParserRule getRule() { return rule; }

		//{be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression (
		//elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
		public Group getGroup() { return cGroup; }

		//{be::BIfExpression}
		public Action getBIfExpressionAction_0() { return cBIfExpressionAction_0; }

		//"elseif"
		public Keyword getElseifKeyword_1() { return cElseifKeyword_1; }

		//conditionExpr=Expression
		public Assignment getConditionExprAssignment_2() { return cConditionExprAssignment_2; }

		//Expression
		public RuleCall getConditionExprExpressionParserRuleCall_2_0() { return cConditionExprExpressionParserRuleCall_2_0; }

		//"then"
		public Keyword getThenKeyword_3() { return cThenKeyword_3; }

		//thenExpr=Expression
		public Assignment getThenExprAssignment_4() { return cThenExprAssignment_4; }

		//Expression
		public RuleCall getThenExprExpressionParserRuleCall_4_0() { return cThenExprExpressionParserRuleCall_4_0; }

		//(elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//elseExpr=ElseIfExpression
		public Assignment getElseExprAssignment_5_0() { return cElseExprAssignment_5_0; }

		//ElseIfExpression
		public RuleCall getElseExprElseIfExpressionParserRuleCall_5_0_0() { return cElseExprElseIfExpressionParserRuleCall_5_0_0; }

		//"else" elseExpr=Expression
		public Group getGroup_5_1() { return cGroup_5_1; }

		//"else"
		public Keyword getElseKeyword_5_1_0() { return cElseKeyword_5_1_0; }

		//elseExpr=Expression
		public Assignment getElseExprAssignment_5_1_1() { return cElseExprAssignment_5_1_1; }

		//Expression
		public RuleCall getElseExprExpressionParserRuleCall_5_1_1_0() { return cElseExprExpressionParserRuleCall_5_1_1_0; }
	}

	public class PropertyValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBVariableExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PropertyValue returns be::BExpression:
		//  {be::BVariableExpression} name=PID;
		public ParserRule getRule() { return rule; }

		//{be::BVariableExpression} name=PID
		public Group getGroup() { return cGroup; }

		//{be::BVariableExpression}
		public Action getBVariableExpressionAction_0() { return cBVariableExpressionAction_0; }

		//name=PID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_1_0() { return cNamePIDTerminalRuleCall_1_0; }
	}

	public class VariableValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBVariableExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//VariableValue returns be::BExpression:
		//  {be::BVariableExpression} name=ID;
		public ParserRule getRule() { return rule; }

		//{be::BVariableExpression} name=ID
		public Group getGroup() { return cGroup; }

		//{be::BVariableExpression}
		public Action getBVariableExpressionAction_0() { return cBVariableExpressionAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class KeywordVariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "KeywordVariables");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBVariableExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final Keyword cNameInputKeyword_1_0_0 = (Keyword)cNameAlternatives_1_0.eContents().get(0);
		private final Keyword cNameOutputKeyword_1_0_1 = (Keyword)cNameAlternatives_1_0.eContents().get(1);
		private final Keyword cNamePropertiesKeyword_1_0_2 = (Keyword)cNameAlternatives_1_0.eContents().get(2);
		private final Keyword cNameUnitKeyword_1_0_3 = (Keyword)cNameAlternatives_1_0.eContents().get(3);
		
		//KeywordVariables returns be::BExpression:
		//  {be::BVariableExpression} name=( "input" | "output" | "properties" | "unit" );
		public ParserRule getRule() { return rule; }

		//{be::BVariableExpression} name=( "input" | "output" | "properties" | "unit" )
		public Group getGroup() { return cGroup; }

		//{be::BVariableExpression}
		public Action getBVariableExpressionAction_0() { return cBVariableExpressionAction_0; }

		//name=( "input" | "output" | "properties" | "unit" )
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//"input"|"output"|"properties"|"unit"
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }

		//"input"
		public Keyword getNameInputKeyword_1_0_0() { return cNameInputKeyword_1_0_0; }

		//"output"
		public Keyword getNameOutputKeyword_1_0_1() { return cNameOutputKeyword_1_0_1; }

		//"properties"
		public Keyword getNamePropertiesKeyword_1_0_2() { return cNamePropertiesKeyword_1_0_2; }

		//"unit"
		public Keyword getNameUnitKeyword_1_0_3() { return cNameUnitKeyword_1_0_3; }
	}

	public class FeatureCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeatureCall");
		private final RuleCall cOperationCallParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//FeatureCall returns be::BExpression:
		//  OperationCall;
		public ParserRule getRule() { return rule; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall() { return cOperationCallParserRuleCall; }
	}

	public class OperationCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBCallExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNamePIDTerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParameterListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParameterListParameterListParserRuleCall_3_0 = (RuleCall)cParameterListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//OperationCall returns be::BCallExpression:
		//  {be::BCallExpression} name=( ID | PID ) "(" parameterList=ParameterList? ")";
		public ParserRule getRule() { return rule; }

		//{be::BCallExpression} name=( ID | PID ) "(" parameterList=ParameterList? ")"
		public Group getGroup() { return cGroup; }

		//{be::BCallExpression}
		public Action getBCallExpressionAction_0() { return cBCallExpressionAction_0; }

		//name=( ID | PID )
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID|PID
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_0() { return cNameIDTerminalRuleCall_1_0_0; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_1_0_1() { return cNamePIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//parameterList=ParameterList?
		public Assignment getParameterListAssignment_3() { return cParameterListAssignment_3; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_3_0() { return cParameterListParameterListParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class ConstructorCallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstructorCallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBCreateExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNewKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeExprLiteralTypeParserRuleCall_2_0 = (RuleCall)cTypeExprAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParameterListAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParameterListParameterListParserRuleCall_3_1_0 = (RuleCall)cParameterListAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cAsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cAliasAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cAliasIDTerminalRuleCall_4_1_0 = (RuleCall)cAliasAssignment_4_1.eContents().get(0);
		private final Assignment cContextBlockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cContextBlockContextBlock_CreationParserRuleCall_5_0 = (RuleCall)cContextBlockAssignment_5.eContents().get(0);
		
		//ConstructorCallExpression returns be::BExpression:
		//  {be::BCreateExpression} "new" typeExpr=LiteralType ("(" parameterList=ParameterList?
		//  ")")? ("as" alias=ID)? contextBlock=ContextBlock_Creation?; 
		//
		//         
		//	   
		//	    
		//	   
		//	    
		//	
		//
		//// Used in a concern to describe pointcuts/advice for units and/or builders
		public ParserRule getRule() { return rule; }

		//{be::BCreateExpression} "new" typeExpr=LiteralType ("(" parameterList=ParameterList?
		//")")? ("as" alias=ID)? contextBlock=ContextBlock_Creation?
		public Group getGroup() { return cGroup; }

		//{be::BCreateExpression}
		public Action getBCreateExpressionAction_0() { return cBCreateExpressionAction_0; }

		//"new"
		public Keyword getNewKeyword_1() { return cNewKeyword_1; }

		//typeExpr=LiteralType
		public Assignment getTypeExprAssignment_2() { return cTypeExprAssignment_2; }

		//LiteralType
		public RuleCall getTypeExprLiteralTypeParserRuleCall_2_0() { return cTypeExprLiteralTypeParserRuleCall_2_0; }

		//("(" parameterList=ParameterList? ")")?
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//parameterList=ParameterList?
		public Assignment getParameterListAssignment_3_1() { return cParameterListAssignment_3_1; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_3_1_0() { return cParameterListParameterListParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }

		//("as" alias=ID)?
		public Group getGroup_4() { return cGroup_4; }

		//"as"
		public Keyword getAsKeyword_4_0() { return cAsKeyword_4_0; }

		//alias=ID
		public Assignment getAliasAssignment_4_1() { return cAliasAssignment_4_1; }

		//ID
		public RuleCall getAliasIDTerminalRuleCall_4_1_0() { return cAliasIDTerminalRuleCall_4_1_0; }

		//contextBlock=ContextBlock_Creation?
		public Assignment getContextBlockAssignment_5() { return cContextBlockAssignment_5; }

		//ContextBlock_Creation
		public RuleCall getContextBlockContextBlock_CreationParserRuleCall_5_0() { return cContextBlockContextBlock_CreationParserRuleCall_5_0; }
	}

	public class BuildConcernContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuildConcernContext");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnitConcernContextParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBuilderConcernContextParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BuildConcernContext returns be::BConcernContext:
		//  UnitConcernContext|BuilderConcernContext; 
		//
		//// Used in a concern to describe pointcuts/advice for units and/or builders
		//       
		//	  
		//	  
		//	
		//	
		//// Advice for units consists of Builders, and advice for Builders
		public ParserRule getRule() { return rule; }

		//UnitConcernContext|BuilderConcernContext 
		//
		//// Used in a concern to describe pointcuts/advice for units and/or builders
		//       
		//	  
		//	  
		//	
		//	
		//// Advice for units consists of Builders, and advice for Builders
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnitConcernContext
		public RuleCall getUnitConcernContextParserRuleCall_0() { return cUnitConcernContextParserRuleCall_0; }

		//BuilderConcernContext
		public RuleCall getBuilderConcernContextParserRuleCall_1() { return cBuilderConcernContextParserRuleCall_1; }
	}

	public class UnitConcernContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitConcernContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnitConcernContextAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cContextKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cUnitKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cQueryAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cQueryUnitOrExpressionParserRuleCall_3_0 = (RuleCall)cQueryAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cFunctionsAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cFunctionsBuilderParserRuleCall_5_0_0 = (RuleCall)cFunctionsAssignment_5_0.eContents().get(0);
		private final Assignment cBuilderContextsAssignment_5_1 = (Assignment)cAlternatives_5.eContents().get(1);
		private final RuleCall cBuilderContextsBuilderConcernContextParserRuleCall_5_1_0 = (RuleCall)cBuilderContextsAssignment_5_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//UnitConcernContext returns build::UnitConcernContext:
		//  {build::UnitConcernContext} "context" "unit" query=UnitOrExpression "{" (functions+=
		//  Builder|builderContexts+=BuilderConcernContext)* "}"; 
		//	
		//// Advice for units consists of Builders, and advice for Builders
		//        
		//	        
		//	
		//	      
		//	      
		//	
		//	
		//	
		//	
		//// Advice for Builders
		public ParserRule getRule() { return rule; }

		//{build::UnitConcernContext} "context" "unit" query=UnitOrExpression "{" (functions+=
		//Builder|builderContexts+=BuilderConcernContext)* "}"
		public Group getGroup() { return cGroup; }

		//{build::UnitConcernContext}
		public Action getUnitConcernContextAction_0() { return cUnitConcernContextAction_0; }

		//"context"
		public Keyword getContextKeyword_1() { return cContextKeyword_1; }

		//"unit"
		public Keyword getUnitKeyword_2() { return cUnitKeyword_2; }

		//query=UnitOrExpression
		public Assignment getQueryAssignment_3() { return cQueryAssignment_3; }

		//UnitOrExpression
		public RuleCall getQueryUnitOrExpressionParserRuleCall_3_0() { return cQueryUnitOrExpressionParserRuleCall_3_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//(functions+=Builder|builderContexts+=BuilderConcernContext)*
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//functions+=Builder
		public Assignment getFunctionsAssignment_5_0() { return cFunctionsAssignment_5_0; }

		//Builder
		public RuleCall getFunctionsBuilderParserRuleCall_5_0_0() { return cFunctionsBuilderParserRuleCall_5_0_0; }

		//builderContexts+=BuilderConcernContext
		public Assignment getBuilderContextsAssignment_5_1() { return cBuilderContextsAssignment_5_1; }

		//BuilderConcernContext
		public RuleCall getBuilderContextsBuilderConcernContextParserRuleCall_5_1_0() { return cBuilderContextsBuilderConcernContextParserRuleCall_5_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class BuilderConcernContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderConcernContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuilderConcernContextAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cContextKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cBuilderKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cQueryAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cQueryBuilderOrExpressionParserRuleCall_3_0 = (RuleCall)cQueryAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Group cGroup_5_0 = (Group)cAlternatives_5.eContents().get(0);
		private final Keyword cPlusSignKeyword_5_0_0 = (Keyword)cGroup_5_0.eContents().get(0);
		private final Keyword cInputKeyword_5_0_1 = (Keyword)cGroup_5_0.eContents().get(1);
		private final Assignment cInputAdditionsAssignment_5_0_2 = (Assignment)cGroup_5_0.eContents().get(2);
		private final RuleCall cInputAdditionsPrerequisiteParserRuleCall_5_0_2_0 = (RuleCall)cInputAdditionsAssignment_5_0_2.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cInputRemovalsAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cInputRemovalsInputPredicateParserRuleCall_5_1_1_0 = (RuleCall)cInputRemovalsAssignment_5_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5_1_2 = (Keyword)cGroup_5_1.eContents().get(2);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Group cGroup_6_0 = (Group)cAlternatives_6.eContents().get(0);
		private final Keyword cPlusSignKeyword_6_0_0 = (Keyword)cGroup_6_0.eContents().get(0);
		private final Keyword cOutputKeyword_6_0_1 = (Keyword)cGroup_6_0.eContents().get(1);
		private final Assignment cOutputAdditionsAssignment_6_0_2 = (Assignment)cGroup_6_0.eContents().get(2);
		private final RuleCall cOutputAdditionsPathVectorParserRuleCall_6_0_2_0 = (RuleCall)cOutputAdditionsAssignment_6_0_2.eContents().get(0);
		private final Group cGroup_6_1 = (Group)cAlternatives_6.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_6_1_0 = (Keyword)cGroup_6_1.eContents().get(0);
		private final Keyword cOutputKeyword_6_1_1 = (Keyword)cGroup_6_1.eContents().get(1);
		private final Assignment cOutputRemovalsAssignment_6_1_2 = (Assignment)cGroup_6_1.eContents().get(2);
		private final RuleCall cOutputRemovalsOutputPredicateParserRuleCall_6_1_2_0 = (RuleCall)cOutputRemovalsAssignment_6_1_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_6_1_3 = (Keyword)cGroup_6_1.eContents().get(3);
		private final Assignment cFuncExprAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFuncExprBlockExpressionParserRuleCall_7_0 = (RuleCall)cFuncExprAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//BuilderConcernContext returns build::BuilderConcernContext:
		//  {build::BuilderConcernContext} "context" "builder" query=BuilderOrExpression "{" ("+"
		//  "input" inputAdditions+=Prerequisite|"-" inputRemovals+=InputPredicate ";")* ("+"
		//  "output" outputAdditions+=PathVector|"-" "output" outputRemovals+=OutputPredicate
		//  ";")* funcExpr=BlockExpression? "}"; 
		//	
		//// Advice for Builders	
		//        
		//	         
		//	             
		//		          
		//		
		//		          
		//		            
		//		// TODO: annotations
		//		       // replaces the builder's funcExpression TODO: around? etc?
		public ParserRule getRule() { return rule; }

		//{build::BuilderConcernContext} "context" "builder" query=BuilderOrExpression "{" ("+"
		//"input" inputAdditions+=Prerequisite|"-" inputRemovals+=InputPredicate ";")* ("+"
		//"output" outputAdditions+=PathVector|"-" "output" outputRemovals+=OutputPredicate
		//";")* funcExpr=BlockExpression? "}"   
		//	         
		//	             
		//		          
		//		
		//		          
		//		            
		//		// TODO: annotations
		//		       // replaces the builder's funcExpression TODO: around? etc?
		public Group getGroup() { return cGroup; }

		//{build::BuilderConcernContext}
		public Action getBuilderConcernContextAction_0() { return cBuilderConcernContextAction_0; }

		//"context"
		public Keyword getContextKeyword_1() { return cContextKeyword_1; }

		//"builder"
		public Keyword getBuilderKeyword_2() { return cBuilderKeyword_2; }

		//query=BuilderOrExpression
		public Assignment getQueryAssignment_3() { return cQueryAssignment_3; }

		//BuilderOrExpression
		public RuleCall getQueryBuilderOrExpressionParserRuleCall_3_0() { return cQueryBuilderOrExpressionParserRuleCall_3_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//("+" "input" inputAdditions+=Prerequisite|"-" inputRemovals+=InputPredicate ";")*
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//"+" "input" inputAdditions+=Prerequisite
		public Group getGroup_5_0() { return cGroup_5_0; }

		//"+"
		public Keyword getPlusSignKeyword_5_0_0() { return cPlusSignKeyword_5_0_0; }

		//"input"
		public Keyword getInputKeyword_5_0_1() { return cInputKeyword_5_0_1; }

		//inputAdditions+=Prerequisite
		public Assignment getInputAdditionsAssignment_5_0_2() { return cInputAdditionsAssignment_5_0_2; }

		//Prerequisite
		public RuleCall getInputAdditionsPrerequisiteParserRuleCall_5_0_2_0() { return cInputAdditionsPrerequisiteParserRuleCall_5_0_2_0; }

		//"-" inputRemovals+=InputPredicate ";"
		public Group getGroup_5_1() { return cGroup_5_1; }

		//"-"
		public Keyword getHyphenMinusKeyword_5_1_0() { return cHyphenMinusKeyword_5_1_0; }

		//inputRemovals+=InputPredicate
		public Assignment getInputRemovalsAssignment_5_1_1() { return cInputRemovalsAssignment_5_1_1; }

		//InputPredicate
		public RuleCall getInputRemovalsInputPredicateParserRuleCall_5_1_1_0() { return cInputRemovalsInputPredicateParserRuleCall_5_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5_1_2() { return cSemicolonKeyword_5_1_2; }

		//("+" "output" outputAdditions+=PathVector|"-" "output" outputRemovals+=
		//OutputPredicate ";")*
		public Alternatives getAlternatives_6() { return cAlternatives_6; }

		//"+" "output" outputAdditions+=PathVector
		public Group getGroup_6_0() { return cGroup_6_0; }

		//"+"
		public Keyword getPlusSignKeyword_6_0_0() { return cPlusSignKeyword_6_0_0; }

		//"output"
		public Keyword getOutputKeyword_6_0_1() { return cOutputKeyword_6_0_1; }

		//outputAdditions+=PathVector
		public Assignment getOutputAdditionsAssignment_6_0_2() { return cOutputAdditionsAssignment_6_0_2; }

		//PathVector
		public RuleCall getOutputAdditionsPathVectorParserRuleCall_6_0_2_0() { return cOutputAdditionsPathVectorParserRuleCall_6_0_2_0; }

		//"-" "output" outputRemovals+=OutputPredicate ";"
		public Group getGroup_6_1() { return cGroup_6_1; }

		//"-"
		public Keyword getHyphenMinusKeyword_6_1_0() { return cHyphenMinusKeyword_6_1_0; }

		//"output"
		public Keyword getOutputKeyword_6_1_1() { return cOutputKeyword_6_1_1; }

		//outputRemovals+=OutputPredicate
		public Assignment getOutputRemovalsAssignment_6_1_2() { return cOutputRemovalsAssignment_6_1_2; }

		//OutputPredicate
		public RuleCall getOutputRemovalsOutputPredicateParserRuleCall_6_1_2_0() { return cOutputRemovalsOutputPredicateParserRuleCall_6_1_2_0; }

		//";"
		public Keyword getSemicolonKeyword_6_1_3() { return cSemicolonKeyword_6_1_3; }

		//funcExpr=BlockExpression?
		public Assignment getFuncExprAssignment_7() { return cFuncExprAssignment_7; }

		//BlockExpression
		public RuleCall getFuncExprBlockExpressionParserRuleCall_7_0() { return cFuncExprBlockExpressionParserRuleCall_7_0; }

		//"}"   // replaces the builder's funcExpression TODO: around? etc?
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}

	public class UnitOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnitAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBOrExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprUnitAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//UnitOrExpression returns be::BExpression:
		//  UnitAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=
		//  UnitAndExpression)*;
		public ParserRule getRule() { return rule; }

		//UnitAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=
		//UnitAndExpression)*
		public Group getGroup() { return cGroup; }

		//UnitAndExpression
		public RuleCall getUnitAndExpressionParserRuleCall_0() { return cUnitAndExpressionParserRuleCall_0; }

		//({be::BOrExpression.leftExpr=current} "||" rightExpr=UnitAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BOrExpression.leftExpr=current}
		public Action getBOrExpressionLeftExprAction_1_0() { return cBOrExpressionLeftExprAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//rightExpr=UnitAndExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//UnitAndExpression
		public RuleCall getRightExprUnitAndExpressionParserRuleCall_1_2_0() { return cRightExprUnitAndExpressionParserRuleCall_1_2_0; }
	}

	public class UnitAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnitNotOrPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBAndExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprUnitNotOrPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//UnitAndExpression returns be::BExpression:
		//  UnitNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
		//  UnitNotOrPrimaryExpression)*;
		public ParserRule getRule() { return rule; }

		//UnitNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
		//UnitNotOrPrimaryExpression)*
		public Group getGroup() { return cGroup; }

		//UnitNotOrPrimaryExpression
		public RuleCall getUnitNotOrPrimaryExpressionParserRuleCall_0() { return cUnitNotOrPrimaryExpressionParserRuleCall_0; }

		//({be::BAndExpression.leftExpr=current} "&&" rightExpr=UnitNotOrPrimaryExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BAndExpression.leftExpr=current}
		public Action getBAndExpressionLeftExprAction_1_0() { return cBAndExpressionLeftExprAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//rightExpr=UnitNotOrPrimaryExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//UnitNotOrPrimaryExpression
		public RuleCall getRightExprUnitNotOrPrimaryExpressionParserRuleCall_1_2_0() { return cRightExprUnitNotOrPrimaryExpressionParserRuleCall_1_2_0; }
	}

	public class UnitNotOrPrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitNotOrPrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnitNotExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnitPrimaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//UnitNotOrPrimaryExpression returns be::BExpression:
		//  UnitNotExpression|UnitPrimaryExpression;
		public ParserRule getRule() { return rule; }

		//UnitNotExpression|UnitPrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnitNotExpression
		public RuleCall getUnitNotExpressionParserRuleCall_0() { return cUnitNotExpressionParserRuleCall_0; }

		//UnitPrimaryExpression
		public RuleCall getUnitPrimaryExpressionParserRuleCall_1() { return cUnitPrimaryExpressionParserRuleCall_1; }
	}

	public class UnitNotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitNotExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBUnaryOpExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFunctionNameExclamationMarkKeyword_1_0 = (Keyword)cFunctionNameAssignment_1.eContents().get(0);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprUnitPrimaryExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//UnitNotExpression returns be::BExpression:
		//  {be::BUnaryOpExpression} functionName="!" expr=UnitPrimaryExpression;
		public ParserRule getRule() { return rule; }

		//{be::BUnaryOpExpression} functionName="!" expr=UnitPrimaryExpression
		public Group getGroup() { return cGroup; }

		//{be::BUnaryOpExpression}
		public Action getBUnaryOpExpressionAction_0() { return cBUnaryOpExpressionAction_0; }

		//functionName="!"
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }

		//"!"
		public Keyword getFunctionNameExclamationMarkKeyword_1_0() { return cFunctionNameExclamationMarkKeyword_1_0; }

		//expr=UnitPrimaryExpression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//UnitPrimaryExpression
		public RuleCall getExprUnitPrimaryExpressionParserRuleCall_2_0() { return cExprUnitPrimaryExpressionParserRuleCall_2_0; }
	}

	public class UnitPrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitPrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRequiresPredicateParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cImplementsPredcicateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cProvidesPredicateParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUnitNamePredicateParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cGroupedUnitPrimaryExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//UnitPrimaryExpression returns be::BExpression:
		//  RequiresPredicate|ImplementsPredcicate|ProvidesPredicate|UnitNamePredicate|
		//  GroupedUnitPrimaryExpression;
		public ParserRule getRule() { return rule; }

		//RequiresPredicate|ImplementsPredcicate|ProvidesPredicate|UnitNamePredicate|
		//GroupedUnitPrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//RequiresPredicate
		public RuleCall getRequiresPredicateParserRuleCall_0() { return cRequiresPredicateParserRuleCall_0; }

		//ImplementsPredcicate
		public RuleCall getImplementsPredcicateParserRuleCall_1() { return cImplementsPredcicateParserRuleCall_1; }

		//ProvidesPredicate
		public RuleCall getProvidesPredicateParserRuleCall_2() { return cProvidesPredicateParserRuleCall_2; }

		//UnitNamePredicate
		public RuleCall getUnitNamePredicateParserRuleCall_3() { return cUnitNamePredicateParserRuleCall_3; }

		//GroupedUnitPrimaryExpression
		public RuleCall getGroupedUnitPrimaryExpressionParserRuleCall_4() { return cGroupedUnitPrimaryExpressionParserRuleCall_4; }
	}

	public class GroupedUnitPrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupedUnitPrimaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cUnitOrExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//GroupedUnitPrimaryExpression returns be::BExpression:
		//  "(" UnitOrExpression ")";
		public ParserRule getRule() { return rule; }

		//"(" UnitOrExpression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//UnitOrExpression
		public RuleCall getUnitOrExpressionParserRuleCall_1() { return cUnitOrExpressionParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class RequiresPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RequiresPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRequiresPredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cMetaAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cMetaMetaKeyword_1_0 = (Keyword)cMetaAssignment_1.eContents().get(0);
		private final Keyword cRequiresKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCapabilityPredicateAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCapabilityPredicateCapabilityPredicateParserRuleCall_3_0 = (RuleCall)cCapabilityPredicateAssignment_3.eContents().get(0);
		
		//RequiresPredicate returns be::BExpression:
		//  {build::RequiresPredicate} meta?="meta"? "requires" capabilityPredicate=
		//  CapabilityPredicate;
		public ParserRule getRule() { return rule; }

		//{build::RequiresPredicate} meta?="meta"? "requires" capabilityPredicate=
		//CapabilityPredicate
		public Group getGroup() { return cGroup; }

		//{build::RequiresPredicate}
		public Action getRequiresPredicateAction_0() { return cRequiresPredicateAction_0; }

		//meta?="meta"?
		public Assignment getMetaAssignment_1() { return cMetaAssignment_1; }

		//"meta"
		public Keyword getMetaMetaKeyword_1_0() { return cMetaMetaKeyword_1_0; }

		//"requires"
		public Keyword getRequiresKeyword_2() { return cRequiresKeyword_2; }

		//capabilityPredicate=CapabilityPredicate
		public Assignment getCapabilityPredicateAssignment_3() { return cCapabilityPredicateAssignment_3; }

		//CapabilityPredicate
		public RuleCall getCapabilityPredicateCapabilityPredicateParserRuleCall_3_0() { return cCapabilityPredicateCapabilityPredicateParserRuleCall_3_0; }
	}

	public class ImplementsPredcicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImplementsPredcicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cImplementsPredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cImplementsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeRefParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//ImplementsPredcicate returns be::BExpression:
		//  {build::ImplementsPredicate} "implements" type=TypeRef;
		public ParserRule getRule() { return rule; }

		//{build::ImplementsPredicate} "implements" type=TypeRef
		public Group getGroup() { return cGroup; }

		//{build::ImplementsPredicate}
		public Action getImplementsPredicateAction_0() { return cImplementsPredicateAction_0; }

		//"implements"
		public Keyword getImplementsKeyword_1() { return cImplementsKeyword_1; }

		//type=TypeRef
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_2_0() { return cTypeTypeRefParserRuleCall_2_0; }
	}

	public class ProvidesPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProvidesPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProvidesPredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cProvidesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCapabilityPredicateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCapabilityPredicateCapabilityPredicateParserRuleCall_2_0 = (RuleCall)cCapabilityPredicateAssignment_2.eContents().get(0);
		
		//ProvidesPredicate returns be::BExpression:
		//  {build::ProvidesPredicate} "provides" capabilityPredicate=CapabilityPredicate;
		public ParserRule getRule() { return rule; }

		//{build::ProvidesPredicate} "provides" capabilityPredicate=CapabilityPredicate
		public Group getGroup() { return cGroup; }

		//{build::ProvidesPredicate}
		public Action getProvidesPredicateAction_0() { return cProvidesPredicateAction_0; }

		//"provides"
		public Keyword getProvidesKeyword_1() { return cProvidesKeyword_1; }

		//capabilityPredicate=CapabilityPredicate
		public Assignment getCapabilityPredicateAssignment_2() { return cCapabilityPredicateAssignment_2; }

		//CapabilityPredicate
		public RuleCall getCapabilityPredicateCapabilityPredicateParserRuleCall_2_0() { return cCapabilityPredicateCapabilityPredicateParserRuleCall_2_0; }
	}

	public class UnitNamePredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitNamePredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnitNamePredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNamePredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePredicateNamePredicateParserRuleCall_1_0 = (RuleCall)cNamePredicateAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSolidusKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVersionRangeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVersionRangeVersionRangeLiteralParserRuleCall_2_1_0 = (RuleCall)cVersionRangeAssignment_2_1.eContents().get(0);
		
		//UnitNamePredicate returns build::CapabilityPredicate:
		//  {build::UnitNamePredicate} namePredicate=NamePredicate ("/" versionRange=
		//  VersionRangeLiteral)?;
		public ParserRule getRule() { return rule; }

		//{build::UnitNamePredicate} namePredicate=NamePredicate ("/" versionRange=
		//VersionRangeLiteral)?
		public Group getGroup() { return cGroup; }

		//{build::UnitNamePredicate}
		public Action getUnitNamePredicateAction_0() { return cUnitNamePredicateAction_0; }

		//namePredicate=NamePredicate
		public Assignment getNamePredicateAssignment_1() { return cNamePredicateAssignment_1; }

		//NamePredicate
		public RuleCall getNamePredicateNamePredicateParserRuleCall_1_0() { return cNamePredicateNamePredicateParserRuleCall_1_0; }

		//("/" versionRange=VersionRangeLiteral)?
		public Group getGroup_2() { return cGroup_2; }

		//"/"
		public Keyword getSolidusKeyword_2_0() { return cSolidusKeyword_2_0; }

		//versionRange=VersionRangeLiteral
		public Assignment getVersionRangeAssignment_2_1() { return cVersionRangeAssignment_2_1; }

		//VersionRangeLiteral
		public RuleCall getVersionRangeVersionRangeLiteralParserRuleCall_2_1_0() { return cVersionRangeVersionRangeLiteralParserRuleCall_2_1_0; }
	}

	public class BuilderNamePredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderNamePredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuilderNamePredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNamePredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePredicateNamePredicateParserRuleCall_1_0 = (RuleCall)cNamePredicateAssignment_1.eContents().get(0);
		
		//BuilderNamePredicate returns build::BuilderNamePredicate:
		//  {build::BuilderNamePredicate} namePredicate=NamePredicate;
		public ParserRule getRule() { return rule; }

		//{build::BuilderNamePredicate} namePredicate=NamePredicate
		public Group getGroup() { return cGroup; }

		//{build::BuilderNamePredicate}
		public Action getBuilderNamePredicateAction_0() { return cBuilderNamePredicateAction_0; }

		//namePredicate=NamePredicate
		public Assignment getNamePredicateAssignment_1() { return cNamePredicateAssignment_1; }

		//NamePredicate
		public RuleCall getNamePredicateNamePredicateParserRuleCall_1_0() { return cNamePredicateNamePredicateParserRuleCall_1_0; }
	}

	public class InputPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InputPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInputPredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cInputKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cCapabilityPredicateAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cCapabilityPredicateCapabilityPredicateParserRuleCall_2_0_0 = (RuleCall)cCapabilityPredicateAssignment_2_0.eContents().get(0);
		private final Assignment cCapabilityPredicateAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cCapabilityPredicateUnitNamePredicateParserRuleCall_2_1_0 = (RuleCall)cCapabilityPredicateAssignment_2_1.eContents().get(0);
		private final Keyword cUnitKeyword_2_2 = (Keyword)cAlternatives_2.eContents().get(2);
		private final Keyword cNumberSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBuilderPredicateAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBuilderPredicateNamePredicateParserRuleCall_4_0 = (RuleCall)cBuilderPredicateAssignment_4.eContents().get(0);
		
		//InputPredicate returns build::InputPredicate:
		//  {build::InputPredicate} "input" (capabilityPredicate=CapabilityPredicate|
		//  capabilityPredicate=UnitNamePredicate|"unit"?) "#" builderPredicate=NamePredicate;
		public ParserRule getRule() { return rule; }

		//{build::InputPredicate} "input" (capabilityPredicate=CapabilityPredicate|
		//capabilityPredicate=UnitNamePredicate|"unit"?) "#" builderPredicate=NamePredicate
		public Group getGroup() { return cGroup; }

		//{build::InputPredicate}
		public Action getInputPredicateAction_0() { return cInputPredicateAction_0; }

		//"input"
		public Keyword getInputKeyword_1() { return cInputKeyword_1; }

		//capabilityPredicate=CapabilityPredicate|capabilityPredicate=UnitNamePredicate|
		//"unit"?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//capabilityPredicate=CapabilityPredicate
		public Assignment getCapabilityPredicateAssignment_2_0() { return cCapabilityPredicateAssignment_2_0; }

		//CapabilityPredicate
		public RuleCall getCapabilityPredicateCapabilityPredicateParserRuleCall_2_0_0() { return cCapabilityPredicateCapabilityPredicateParserRuleCall_2_0_0; }

		//capabilityPredicate=UnitNamePredicate
		public Assignment getCapabilityPredicateAssignment_2_1() { return cCapabilityPredicateAssignment_2_1; }

		//UnitNamePredicate
		public RuleCall getCapabilityPredicateUnitNamePredicateParserRuleCall_2_1_0() { return cCapabilityPredicateUnitNamePredicateParserRuleCall_2_1_0; }

		//"unit"?
		public Keyword getUnitKeyword_2_2() { return cUnitKeyword_2_2; }

		//"#"
		public Keyword getNumberSignKeyword_3() { return cNumberSignKeyword_3; }

		//builderPredicate=NamePredicate
		public Assignment getBuilderPredicateAssignment_4() { return cBuilderPredicateAssignment_4; }

		//NamePredicate
		public RuleCall getBuilderPredicateNamePredicateParserRuleCall_4_0() { return cBuilderPredicateNamePredicateParserRuleCall_4_0; }
	}

	public class OutputPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OutputPredicate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cOutputPredicateAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cPathVectorAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cPathVectorBasePathPredicateParserRuleCall_0_1_0 = (RuleCall)cPathVectorAssignment_0_1.eContents().get(0);
		private final Assignment cPathVectorAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cPathVectorPathPredicateParserRuleCall_1_0 = (RuleCall)cPathVectorAssignment_1.eContents().get(0);
		private final Assignment cPathPatternAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cPathPatternRegexpLiteralParserRuleCall_2_0 = (RuleCall)cPathPatternAssignment_2.eContents().get(0);
		
		//OutputPredicate returns build::OutputPredicate:
		//  {build::OutputPredicate} pathVector=BasePathPredicate|pathVector=PathPredicate|
		//  pathPattern=RegexpLiteral;
		public ParserRule getRule() { return rule; }

		//{build::OutputPredicate} pathVector=BasePathPredicate|pathVector=PathPredicate|
		//pathPattern=RegexpLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//{build::OutputPredicate} pathVector=BasePathPredicate
		public Group getGroup_0() { return cGroup_0; }

		//{build::OutputPredicate}
		public Action getOutputPredicateAction_0_0() { return cOutputPredicateAction_0_0; }

		//pathVector=BasePathPredicate
		public Assignment getPathVectorAssignment_0_1() { return cPathVectorAssignment_0_1; }

		//BasePathPredicate
		public RuleCall getPathVectorBasePathPredicateParserRuleCall_0_1_0() { return cPathVectorBasePathPredicateParserRuleCall_0_1_0; }

		//pathVector=PathPredicate
		public Assignment getPathVectorAssignment_1() { return cPathVectorAssignment_1; }

		//PathPredicate
		public RuleCall getPathVectorPathPredicateParserRuleCall_1_0() { return cPathVectorPathPredicateParserRuleCall_1_0; }

		//pathPattern=RegexpLiteral
		public Assignment getPathPatternAssignment_2() { return cPathPatternAssignment_2; }

		//RegexpLiteral
		public RuleCall getPathPatternRegexpLiteralParserRuleCall_2_0() { return cPathPatternRegexpLiteralParserRuleCall_2_0; }
	}

	public class BasePathPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasePathPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPathVectorElementAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBasePathAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBasePathPathParserRuleCall_1_0 = (RuleCall)cBasePathAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPathsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPathsPathParserRuleCall_3_0 = (RuleCall)cPathsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cPathsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cPathsPathParserRuleCall_4_1_0 = (RuleCall)cPathsAssignment_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//BasePathPredicate returns build::PathVectorElement:
		//  {build::PathVectorElement} basePath=Path "[" paths+=Path ("," paths+=Path)* "]";
		public ParserRule getRule() { return rule; }

		//{build::PathVectorElement} basePath=Path "[" paths+=Path ("," paths+=Path)* "]"
		public Group getGroup() { return cGroup; }

		//{build::PathVectorElement}
		public Action getPathVectorElementAction_0() { return cPathVectorElementAction_0; }

		//basePath=Path
		public Assignment getBasePathAssignment_1() { return cBasePathAssignment_1; }

		//Path
		public RuleCall getBasePathPathParserRuleCall_1_0() { return cBasePathPathParserRuleCall_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//paths+=Path
		public Assignment getPathsAssignment_3() { return cPathsAssignment_3; }

		//Path
		public RuleCall getPathsPathParserRuleCall_3_0() { return cPathsPathParserRuleCall_3_0; }

		//("," paths+=Path)*
		public Group getGroup_4() { return cGroup_4; }

		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }

		//paths+=Path
		public Assignment getPathsAssignment_4_1() { return cPathsAssignment_4_1; }

		//Path
		public RuleCall getPathsPathParserRuleCall_4_1_0() { return cPathsPathParserRuleCall_4_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }
	}

	public class PathPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPathVectorElementAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPathsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathsPathParserRuleCall_1_0 = (RuleCall)cPathsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPathsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPathsPathParserRuleCall_2_1_0 = (RuleCall)cPathsAssignment_2_1.eContents().get(0);
		
		//PathPredicate returns build::PathVectorElement:
		//  {build::PathVectorElement} paths+=Path ("," paths+=Path)*;
		public ParserRule getRule() { return rule; }

		//{build::PathVectorElement} paths+=Path ("," paths+=Path)*
		public Group getGroup() { return cGroup; }

		//{build::PathVectorElement}
		public Action getPathVectorElementAction_0() { return cPathVectorElementAction_0; }

		//paths+=Path
		public Assignment getPathsAssignment_1() { return cPathsAssignment_1; }

		//Path
		public RuleCall getPathsPathParserRuleCall_1_0() { return cPathsPathParserRuleCall_1_0; }

		//("," paths+=Path)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//paths+=Path
		public Assignment getPathsAssignment_2_1() { return cPathsAssignment_2_1; }

		//Path
		public RuleCall getPathsPathParserRuleCall_2_1_0() { return cPathsPathParserRuleCall_2_1_0; }
	}

	public class CapabilityPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CapabilityPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCapabilityPredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameSpacePredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSpacePredicateNamePredicateParserRuleCall_1_0 = (RuleCall)cNameSpacePredicateAssignment_1.eContents().get(0);
		private final Keyword cSolidusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNamePredicateAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNamePredicateNamePredicateParserRuleCall_3_0 = (RuleCall)cNamePredicateAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cSolidusKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cVersionRangeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cVersionRangeVersionRangeLiteralParserRuleCall_4_1_0 = (RuleCall)cVersionRangeAssignment_4_1.eContents().get(0);
		
		//CapabilityPredicate returns build::CapabilityPredicate:
		//  {build::CapabilityPredicate} nameSpacePredicate=NamePredicate "/" namePredicate=
		//  NamePredicate ("/" versionRange=VersionRangeLiteral)?;
		public ParserRule getRule() { return rule; }

		//{build::CapabilityPredicate} nameSpacePredicate=NamePredicate "/" namePredicate=
		//NamePredicate ("/" versionRange=VersionRangeLiteral)?
		public Group getGroup() { return cGroup; }

		//{build::CapabilityPredicate}
		public Action getCapabilityPredicateAction_0() { return cCapabilityPredicateAction_0; }

		//nameSpacePredicate=NamePredicate
		public Assignment getNameSpacePredicateAssignment_1() { return cNameSpacePredicateAssignment_1; }

		//NamePredicate
		public RuleCall getNameSpacePredicateNamePredicateParserRuleCall_1_0() { return cNameSpacePredicateNamePredicateParserRuleCall_1_0; }

		//"/"
		public Keyword getSolidusKeyword_2() { return cSolidusKeyword_2; }

		//namePredicate=NamePredicate
		public Assignment getNamePredicateAssignment_3() { return cNamePredicateAssignment_3; }

		//NamePredicate
		public RuleCall getNamePredicateNamePredicateParserRuleCall_3_0() { return cNamePredicateNamePredicateParserRuleCall_3_0; }

		//("/" versionRange=VersionRangeLiteral)?
		public Group getGroup_4() { return cGroup_4; }

		//"/"
		public Keyword getSolidusKeyword_4_0() { return cSolidusKeyword_4_0; }

		//versionRange=VersionRangeLiteral
		public Assignment getVersionRangeAssignment_4_1() { return cVersionRangeAssignment_4_1; }

		//VersionRangeLiteral
		public RuleCall getVersionRangeVersionRangeLiteralParserRuleCall_4_1_0() { return cVersionRangeVersionRangeLiteralParserRuleCall_4_1_0; }
	}

	public class NamePredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamePredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNamePredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cNameEscapedQualifiedNameParserRuleCall_1_0_0 = (RuleCall)cNameAssignment_1_0.eContents().get(0);
		private final Assignment cNamePatternAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cNamePatternRegexpLiteralParserRuleCall_1_1_0 = (RuleCall)cNamePatternAssignment_1_1.eContents().get(0);
		private final Assignment cNamePatternAssignment_1_2 = (Assignment)cAlternatives_1.eContents().get(2);
		private final RuleCall cNamePatternWildcardExpressionParserRuleCall_1_2_0 = (RuleCall)cNamePatternAssignment_1_2.eContents().get(0);
		
		//NamePredicate returns build::NamePredicate:
		//  {build::NamePredicate} (name=EscapedQualifiedName|namePattern=RegexpLiteral|
		//  namePattern=WildcardExpression);
		public ParserRule getRule() { return rule; }

		//{build::NamePredicate} (name=EscapedQualifiedName|namePattern=RegexpLiteral|
		//namePattern=WildcardExpression)
		public Group getGroup() { return cGroup; }

		//{build::NamePredicate}
		public Action getNamePredicateAction_0() { return cNamePredicateAction_0; }

		//name=EscapedQualifiedName|namePattern=RegexpLiteral|namePattern=
		//WildcardExpression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//name=EscapedQualifiedName
		public Assignment getNameAssignment_1_0() { return cNameAssignment_1_0; }

		//EscapedQualifiedName
		public RuleCall getNameEscapedQualifiedNameParserRuleCall_1_0_0() { return cNameEscapedQualifiedNameParserRuleCall_1_0_0; }

		//namePattern=RegexpLiteral
		public Assignment getNamePatternAssignment_1_1() { return cNamePatternAssignment_1_1; }

		//RegexpLiteral
		public RuleCall getNamePatternRegexpLiteralParserRuleCall_1_1_0() { return cNamePatternRegexpLiteralParserRuleCall_1_1_0; }

		//namePattern=WildcardExpression
		public Assignment getNamePatternAssignment_1_2() { return cNamePatternAssignment_1_2; }

		//WildcardExpression
		public RuleCall getNamePatternWildcardExpressionParserRuleCall_1_2_0() { return cNamePatternWildcardExpressionParserRuleCall_1_2_0; }
	}

	public class BuilderOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBuilderAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBOrExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprBuilderAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//BuilderOrExpression returns be::BExpression:
		//  BuilderAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=
		//  BuilderAndExpression)*;
		public ParserRule getRule() { return rule; }

		//BuilderAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=
		//BuilderAndExpression)*
		public Group getGroup() { return cGroup; }

		//BuilderAndExpression
		public RuleCall getBuilderAndExpressionParserRuleCall_0() { return cBuilderAndExpressionParserRuleCall_0; }

		//({be::BOrExpression.leftExpr=current} "||" rightExpr=BuilderAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BOrExpression.leftExpr=current}
		public Action getBOrExpressionLeftExprAction_1_0() { return cBOrExpressionLeftExprAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//rightExpr=BuilderAndExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//BuilderAndExpression
		public RuleCall getRightExprBuilderAndExpressionParserRuleCall_1_2_0() { return cRightExprBuilderAndExpressionParserRuleCall_1_2_0; }
	}

	public class BuilderAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBuilderNotOrPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBAndExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprBuilderNotOrPrimaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//BuilderAndExpression returns be::BExpression:
		//  BuilderNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr
		//  =BuilderNotOrPrimaryExpression)*;
		public ParserRule getRule() { return rule; }

		//BuilderNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr
		//=BuilderNotOrPrimaryExpression)*
		public Group getGroup() { return cGroup; }

		//BuilderNotOrPrimaryExpression
		public RuleCall getBuilderNotOrPrimaryExpressionParserRuleCall_0() { return cBuilderNotOrPrimaryExpressionParserRuleCall_0; }

		//({be::BAndExpression.leftExpr=current} "&&" rightExpr=
		//BuilderNotOrPrimaryExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BAndExpression.leftExpr=current}
		public Action getBAndExpressionLeftExprAction_1_0() { return cBAndExpressionLeftExprAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//rightExpr=BuilderNotOrPrimaryExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//BuilderNotOrPrimaryExpression
		public RuleCall getRightExprBuilderNotOrPrimaryExpressionParserRuleCall_1_2_0() { return cRightExprBuilderNotOrPrimaryExpressionParserRuleCall_1_2_0; }
	}

	public class BuilderNotOrPrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderNotOrPrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBuilderNotExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBuilderPrimaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BuilderNotOrPrimaryExpression returns be::BExpression:
		//  BuilderNotExpression|BuilderPrimaryExpression;
		public ParserRule getRule() { return rule; }

		//BuilderNotExpression|BuilderPrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//BuilderNotExpression
		public RuleCall getBuilderNotExpressionParserRuleCall_0() { return cBuilderNotExpressionParserRuleCall_0; }

		//BuilderPrimaryExpression
		public RuleCall getBuilderPrimaryExpressionParserRuleCall_1() { return cBuilderPrimaryExpressionParserRuleCall_1; }
	}

	public class BuilderNotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderNotExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBUnaryOpExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFunctionNameExclamationMarkKeyword_1_0 = (Keyword)cFunctionNameAssignment_1.eContents().get(0);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprBuilderPrimaryExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//BuilderNotExpression returns be::BExpression:
		//  {be::BUnaryOpExpression} functionName="!" expr=BuilderPrimaryExpression;
		public ParserRule getRule() { return rule; }

		//{be::BUnaryOpExpression} functionName="!" expr=BuilderPrimaryExpression
		public Group getGroup() { return cGroup; }

		//{be::BUnaryOpExpression}
		public Action getBUnaryOpExpressionAction_0() { return cBUnaryOpExpressionAction_0; }

		//functionName="!"
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }

		//"!"
		public Keyword getFunctionNameExclamationMarkKeyword_1_0() { return cFunctionNameExclamationMarkKeyword_1_0; }

		//expr=BuilderPrimaryExpression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//BuilderPrimaryExpression
		public RuleCall getExprBuilderPrimaryExpressionParserRuleCall_2_0() { return cExprBuilderPrimaryExpressionParserRuleCall_2_0; }
	}

	public class BuilderPrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderPrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInputPredicateParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cProvidesPredicateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBuilderNamePredicateParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cGroupedBuilderPrimaryExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//BuilderPrimaryExpression returns be::BExpression:
		//  InputPredicate|ProvidesPredicate|BuilderNamePredicate|
		//  GroupedBuilderPrimaryExpression;
		public ParserRule getRule() { return rule; }

		//InputPredicate|ProvidesPredicate|BuilderNamePredicate|
		//GroupedBuilderPrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//InputPredicate
		public RuleCall getInputPredicateParserRuleCall_0() { return cInputPredicateParserRuleCall_0; }

		//ProvidesPredicate
		public RuleCall getProvidesPredicateParserRuleCall_1() { return cProvidesPredicateParserRuleCall_1; }

		//BuilderNamePredicate
		public RuleCall getBuilderNamePredicateParserRuleCall_2() { return cBuilderNamePredicateParserRuleCall_2; }

		//GroupedBuilderPrimaryExpression
		public RuleCall getGroupedBuilderPrimaryExpressionParserRuleCall_3() { return cGroupedBuilderPrimaryExpressionParserRuleCall_3; }
	}

	public class GroupedBuilderPrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupedBuilderPrimaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cBuilderOrExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//GroupedBuilderPrimaryExpression returns be::BExpression:
		//  "(" BuilderOrExpression ")";
		public ParserRule getRule() { return rule; }

		//"(" BuilderOrExpression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//BuilderOrExpression
		public RuleCall getBuilderOrExpressionParserRuleCall_1() { return cBuilderOrExpressionParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class ContextBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ContextBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBChainedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cExpressionsAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cExpressionsFunctionParserRuleCall_2_0_0 = (RuleCall)cExpressionsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cExpressionsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cExpressionsTopLevelExpressionParserRuleCall_2_1_0_0 = (RuleCall)cExpressionsAssignment_2_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ContextBlock returns be::BExpression:
		//  {be::BChainedExpression} "{" (expressions+=Function|expressions+=
		//  TopLevelExpression ";")* "}"; 
		//
		//
		//         
		//	      
		////		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		//		     
		////		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		public ParserRule getRule() { return rule; }

		//{be::BChainedExpression} "{" (expressions+=Function|expressions+=
		//TopLevelExpression ";")* "}"    
		//	      
		////		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		//		     
		////		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		public Group getGroup() { return cGroup; }

		//{be::BChainedExpression}
		public Action getBChainedExpressionAction_0() { return cBChainedExpressionAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(expressions+=Function|expressions+=TopLevelExpression ";")*       
		////		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		//		     
		////		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//expressions+=Function
		public Assignment getExpressionsAssignment_2_0() { return cExpressionsAssignment_2_0; }

		//Function
		public RuleCall getExpressionsFunctionParserRuleCall_2_0_0() { return cExpressionsFunctionParserRuleCall_2_0_0; }

		//expressions+=TopLevelExpression ";"
		public Group getGroup_2_1() { return cGroup_2_1; }

		//expressions+=TopLevelExpression
		public Assignment getExpressionsAssignment_2_1_0() { return cExpressionsAssignment_2_1_0; }

		//TopLevelExpression
		public RuleCall getExpressionsTopLevelExpressionParserRuleCall_2_1_0_0() { return cExpressionsTopLevelExpressionParserRuleCall_2_1_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1_1() { return cSemicolonKeyword_2_1_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ContextBlock_CreationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ContextBlock_Creation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBChainedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpressionsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionsTopLevelExpressionParserRuleCall_2_0_0 = (RuleCall)cExpressionsAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ContextBlock_Creation returns be::BExpression:
		//  {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"; 
		//
		//         
		//	       
		//	
		//					
		////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
		////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = PropertySet_Named ;
		////FunctionDefinition returns be::BExpression : {be::BDefFunction} function = Function;
		////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
		public ParserRule getRule() { return rule; }

		//{be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"
		public Group getGroup() { return cGroup; }

		//{be::BChainedExpression}
		public Action getBChainedExpressionAction_0() { return cBChainedExpressionAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(expressions+=TopLevelExpression ";")*
		public Group getGroup_2() { return cGroup_2; }

		//expressions+=TopLevelExpression
		public Assignment getExpressionsAssignment_2_0() { return cExpressionsAssignment_2_0; }

		//TopLevelExpression
		public RuleCall getExpressionsTopLevelExpressionParserRuleCall_2_0_0() { return cExpressionsTopLevelExpressionParserRuleCall_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRegexpLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLiteralMapParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralListParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLiteralFunctionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Literal returns be::BExpression:
		//  ValueLiteral|RegexpLiteral|LiteralMap|LiteralList|LiteralFunction; 
		//					
		////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
		////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = PropertySet_Named ;
		////FunctionDefinition returns be::BExpression : {be::BDefFunction} function = Function;
		////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
		public ParserRule getRule() { return rule; }

		//ValueLiteral|RegexpLiteral|LiteralMap|LiteralList|LiteralFunction 
		//					
		////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
		////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = PropertySet_Named ;
		////FunctionDefinition returns be::BExpression : {be::BDefFunction} function = Function;
		////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
		public Alternatives getAlternatives() { return cAlternatives; }

		//ValueLiteral
		public RuleCall getValueLiteralParserRuleCall_0() { return cValueLiteralParserRuleCall_0; }

		//RegexpLiteral
		public RuleCall getRegexpLiteralParserRuleCall_1() { return cRegexpLiteralParserRuleCall_1; }

		//LiteralMap
		public RuleCall getLiteralMapParserRuleCall_2() { return cLiteralMapParserRuleCall_2; }

		//LiteralList
		public RuleCall getLiteralListParserRuleCall_3() { return cLiteralListParserRuleCall_3; }

		//LiteralFunction
		public RuleCall getLiteralFunctionParserRuleCall_4() { return cLiteralFunctionParserRuleCall_4; }
	}

	public class LiteralListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralList");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBLiteralListExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLessThanSignKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cEntryTypeAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cEntryTypeTypeRefParserRuleCall_0_2_1_0 = (RuleCall)cEntryTypeAssignment_0_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_0_2_2 = (Keyword)cGroup_0_2.eContents().get(2);
		private final Assignment cEntriesAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cEntriesExpressionParserRuleCall_0_3_0 = (RuleCall)cEntriesAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cCommaKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cEntriesAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cEntriesExpressionParserRuleCall_0_4_1_0 = (RuleCall)cEntriesAssignment_0_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBLiteralListExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cEntryTypeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cEntryTypeTypeRefParserRuleCall_1_3_0 = (RuleCall)cEntryTypeAssignment_1_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cRightSquareBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		
		//LiteralList returns be::BExpression:
		//  {be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
		//  entries+=Expression)* "]"|{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">"
		//  "]";
		public ParserRule getRule() { return rule; }

		//{be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
		//entries+=Expression)* "]"|{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">"
		//"]"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
		//entries+=Expression)* "]"
		public Group getGroup_0() { return cGroup_0; }

		//{be::BLiteralListExpression}
		public Action getBLiteralListExpressionAction_0_0() { return cBLiteralListExpressionAction_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_1() { return cLeftSquareBracketKeyword_0_1; }

		//("<" entryType=TypeRef ">")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"<"
		public Keyword getLessThanSignKeyword_0_2_0() { return cLessThanSignKeyword_0_2_0; }

		//entryType=TypeRef
		public Assignment getEntryTypeAssignment_0_2_1() { return cEntryTypeAssignment_0_2_1; }

		//TypeRef
		public RuleCall getEntryTypeTypeRefParserRuleCall_0_2_1_0() { return cEntryTypeTypeRefParserRuleCall_0_2_1_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_0_2_2() { return cGreaterThanSignKeyword_0_2_2; }

		//entries+=Expression
		public Assignment getEntriesAssignment_0_3() { return cEntriesAssignment_0_3; }

		//Expression
		public RuleCall getEntriesExpressionParserRuleCall_0_3_0() { return cEntriesExpressionParserRuleCall_0_3_0; }

		//("," entries+=Expression)*
		public Group getGroup_0_4() { return cGroup_0_4; }

		//","
		public Keyword getCommaKeyword_0_4_0() { return cCommaKeyword_0_4_0; }

		//entries+=Expression
		public Assignment getEntriesAssignment_0_4_1() { return cEntriesAssignment_0_4_1; }

		//Expression
		public RuleCall getEntriesExpressionParserRuleCall_0_4_1_0() { return cEntriesExpressionParserRuleCall_0_4_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_5() { return cRightSquareBracketKeyword_0_5; }

		//{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">" "]"
		public Group getGroup_1() { return cGroup_1; }

		//{be::BLiteralListExpression}
		public Action getBLiteralListExpressionAction_1_0() { return cBLiteralListExpressionAction_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_2() { return cLessThanSignKeyword_1_2; }

		//entryType=TypeRef
		public Assignment getEntryTypeAssignment_1_3() { return cEntryTypeAssignment_1_3; }

		//TypeRef
		public RuleCall getEntryTypeTypeRefParserRuleCall_1_3_0() { return cEntryTypeTypeRefParserRuleCall_1_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_4() { return cGreaterThanSignKeyword_1_4; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_5() { return cRightSquareBracketKeyword_1_5; }
	}

	public class LiteralMapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralMap");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBLiteralMapExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLessThanSignKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cKeyTypeAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cKeyTypeTypeRefParserRuleCall_0_2_1_0 = (RuleCall)cKeyTypeAssignment_0_2_1.eContents().get(0);
		private final Keyword cCommaKeyword_0_2_2 = (Keyword)cGroup_0_2.eContents().get(2);
		private final Assignment cValueTypeAssignment_0_2_3 = (Assignment)cGroup_0_2.eContents().get(3);
		private final RuleCall cValueTypeTypeRefParserRuleCall_0_2_3_0 = (RuleCall)cValueTypeAssignment_0_2_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_0_2_4 = (Keyword)cGroup_0_2.eContents().get(4);
		private final Assignment cEntriesAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cEntriesMapEntryParserRuleCall_0_3_0 = (RuleCall)cEntriesAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cCommaKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cEntriesAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cEntriesMapEntryParserRuleCall_0_4_1_0 = (RuleCall)cEntriesAssignment_0_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBLiteralMapExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cKeyTypeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cKeyTypeTypeRefParserRuleCall_1_3_0 = (RuleCall)cKeyTypeAssignment_1_3.eContents().get(0);
		private final Keyword cCommaKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cValueTypeAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cValueTypeTypeRefParserRuleCall_1_5_0 = (RuleCall)cValueTypeAssignment_1_5.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		private final Keyword cRightSquareBracketKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		
		//LiteralMap returns be::BExpression:
		//  {be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
		//  entries+=MapEntry ("," entries+=MapEntry)* "]"|{be::BLiteralMapExpression} "[" "<"
		//  keyType=TypeRef "," valueType=TypeRef ">" "]"; 
		//	
		//     
		//	                                
		//	                 
		//	
		//
		//// A lambda enclosed in { }
		public ParserRule getRule() { return rule; }

		//{be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
		//entries+=MapEntry ("," entries+=MapEntry)* "]"|{be::BLiteralMapExpression} "[" "<"
		//keyType=TypeRef "," valueType=TypeRef ">" "]" 
		//	
		//     
		//	                                
		//	                 
		//	
		//
		//// A lambda enclosed in { }
		public Alternatives getAlternatives() { return cAlternatives; }

		//{be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
		//entries+=MapEntry ("," entries+=MapEntry)* "]"
		public Group getGroup_0() { return cGroup_0; }

		//{be::BLiteralMapExpression}
		public Action getBLiteralMapExpressionAction_0_0() { return cBLiteralMapExpressionAction_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_1() { return cLeftSquareBracketKeyword_0_1; }

		//("<" keyType=TypeRef "," valueType=TypeRef ">")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"<"
		public Keyword getLessThanSignKeyword_0_2_0() { return cLessThanSignKeyword_0_2_0; }

		//keyType=TypeRef
		public Assignment getKeyTypeAssignment_0_2_1() { return cKeyTypeAssignment_0_2_1; }

		//TypeRef
		public RuleCall getKeyTypeTypeRefParserRuleCall_0_2_1_0() { return cKeyTypeTypeRefParserRuleCall_0_2_1_0; }

		//","
		public Keyword getCommaKeyword_0_2_2() { return cCommaKeyword_0_2_2; }

		//valueType=TypeRef
		public Assignment getValueTypeAssignment_0_2_3() { return cValueTypeAssignment_0_2_3; }

		//TypeRef
		public RuleCall getValueTypeTypeRefParserRuleCall_0_2_3_0() { return cValueTypeTypeRefParserRuleCall_0_2_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_0_2_4() { return cGreaterThanSignKeyword_0_2_4; }

		//entries+=MapEntry
		public Assignment getEntriesAssignment_0_3() { return cEntriesAssignment_0_3; }

		//MapEntry
		public RuleCall getEntriesMapEntryParserRuleCall_0_3_0() { return cEntriesMapEntryParserRuleCall_0_3_0; }

		//("," entries+=MapEntry)*
		public Group getGroup_0_4() { return cGroup_0_4; }

		//","
		public Keyword getCommaKeyword_0_4_0() { return cCommaKeyword_0_4_0; }

		//entries+=MapEntry
		public Assignment getEntriesAssignment_0_4_1() { return cEntriesAssignment_0_4_1; }

		//MapEntry
		public RuleCall getEntriesMapEntryParserRuleCall_0_4_1_0() { return cEntriesMapEntryParserRuleCall_0_4_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_5() { return cRightSquareBracketKeyword_0_5; }

		//{be::BLiteralMapExpression} "[" "<" keyType=TypeRef "," valueType=TypeRef ">" "]"
		public Group getGroup_1() { return cGroup_1; }

		//{be::BLiteralMapExpression}
		public Action getBLiteralMapExpressionAction_1_0() { return cBLiteralMapExpressionAction_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_2() { return cLessThanSignKeyword_1_2; }

		//keyType=TypeRef
		public Assignment getKeyTypeAssignment_1_3() { return cKeyTypeAssignment_1_3; }

		//TypeRef
		public RuleCall getKeyTypeTypeRefParserRuleCall_1_3_0() { return cKeyTypeTypeRefParserRuleCall_1_3_0; }

		//","
		public Keyword getCommaKeyword_1_4() { return cCommaKeyword_1_4; }

		//valueType=TypeRef
		public Assignment getValueTypeAssignment_1_5() { return cValueTypeAssignment_1_5; }

		//TypeRef
		public RuleCall getValueTypeTypeRefParserRuleCall_1_5_0() { return cValueTypeTypeRefParserRuleCall_1_5_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_6() { return cGreaterThanSignKeyword_1_6; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_7() { return cRightSquareBracketKeyword_1_7; }
	}

	public class LiteralFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cClosureExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//LiteralFunction returns be::BExpression:
		//  "{" ClosureExpression "}"; 
		//
		//// A lambda enclosed in { }
		//      
		//	    
		//	
		//
		////LiteralFunction returns be::BExpression : {be::B3Function} 
		////	'{' ('<' returnType=TypeRef '>')?
		////	(
		////	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
		////		(',' varArgs?="..." parameters += ParameterDeclaration)?)
		////	| 	(    varArgs?="..." parameters += ParameterDeclaration)
		////	)? 
		////	'|' funcExpr=OneOrManyExpressions '}'
		////	;
		//
		//// A lambda (without delimiters)
		public ParserRule getRule() { return rule; }

		//"{" ClosureExpression "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//ClosureExpression
		public RuleCall getClosureExpressionParserRuleCall_1() { return cClosureExpressionParserRuleCall_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class ClosureExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClosureExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3FunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cReturnTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cReturnTypeTypeRefParserRuleCall_1_1_0 = (RuleCall)cReturnTypeAssignment_1_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_2_0_0_0 = (RuleCall)cParametersAssignment_2_0_0.eContents().get(0);
		private final Group cGroup_2_0_1 = (Group)cGroup_2_0.eContents().get(1);
		private final Keyword cCommaKeyword_2_0_1_0 = (Keyword)cGroup_2_0_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_0_1_1 = (Assignment)cGroup_2_0_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_2_0_1_1_0 = (RuleCall)cParametersAssignment_2_0_1_1.eContents().get(0);
		private final Group cGroup_2_0_2 = (Group)cGroup_2_0.eContents().get(2);
		private final Keyword cCommaKeyword_2_0_2_0 = (Keyword)cGroup_2_0_2.eContents().get(0);
		private final Assignment cVarArgsAssignment_2_0_2_1 = (Assignment)cGroup_2_0_2.eContents().get(1);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_2_0_2_1_0 = (Keyword)cVarArgsAssignment_2_0_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_0_2_2 = (Assignment)cGroup_2_0_2.eContents().get(2);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_2_0_2_2_0 = (RuleCall)cParametersAssignment_2_0_2_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cVarArgsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_2_1_0_0 = (Keyword)cVarArgsAssignment_2_1_0.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_2_1_1_0 = (RuleCall)cParametersAssignment_2_1_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFuncExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFuncExprOneOrManyExpressionsParserRuleCall_4_0 = (RuleCall)cFuncExprAssignment_4.eContents().get(0);
		
		//ClosureExpression returns be::BExpression:
		//  {be::B3Function} ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (","
		//  parameters+=ParameterDeclaration)* ("," varArgs?="..." parameters+=
		//  ParameterDeclaration)?|varArgs?="..." parameters+=ParameterDeclaration)? "|"
		//  funcExpr=OneOrManyExpressions; 
		//
		////LiteralFunction returns be::BExpression : {be::B3Function} 
		////	'{' ('<' returnType=TypeRef '>')?
		////	(
		////	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
		////		(',' varArgs?="..." parameters += ParameterDeclaration)?)
		////	| 	(    varArgs?="..." parameters += ParameterDeclaration)
		////	)? 
		////	'|' funcExpr=OneOrManyExpressions '}'
		////	;
		//
		//// A lambda (without delimiters)
		public ParserRule getRule() { return rule; }

		//{be::B3Function} ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (","
		//parameters+=ParameterDeclaration)* ("," varArgs?="..." parameters+=
		//ParameterDeclaration)?|varArgs?="..." parameters+=ParameterDeclaration)? "|"
		//funcExpr=OneOrManyExpressions
		public Group getGroup() { return cGroup; }

		//{be::B3Function}
		public Action getB3FunctionAction_0() { return cB3FunctionAction_0; }

		//("<" returnType=TypeRef ">")?
		public Group getGroup_1() { return cGroup_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0() { return cLessThanSignKeyword_1_0; }

		//returnType=TypeRef
		public Assignment getReturnTypeAssignment_1_1() { return cReturnTypeAssignment_1_1; }

		//TypeRef
		public RuleCall getReturnTypeTypeRefParserRuleCall_1_1_0() { return cReturnTypeTypeRefParserRuleCall_1_1_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_2() { return cGreaterThanSignKeyword_1_2; }

		//(parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
		//varArgs?="..." parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
		//ParameterDeclaration)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)* (","
		//varArgs?="..." parameters+=ParameterDeclaration)?
		public Group getGroup_2_0() { return cGroup_2_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_2_0_0() { return cParametersAssignment_2_0_0; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_2_0_0_0() { return cParametersParameterDeclarationParserRuleCall_2_0_0_0; }

		//("," parameters+=ParameterDeclaration)*
		public Group getGroup_2_0_1() { return cGroup_2_0_1; }

		//","
		public Keyword getCommaKeyword_2_0_1_0() { return cCommaKeyword_2_0_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_2_0_1_1() { return cParametersAssignment_2_0_1_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_2_0_1_1_0() { return cParametersParameterDeclarationParserRuleCall_2_0_1_1_0; }

		//("," varArgs?="..." parameters+=ParameterDeclaration)?
		public Group getGroup_2_0_2() { return cGroup_2_0_2; }

		//","
		public Keyword getCommaKeyword_2_0_2_0() { return cCommaKeyword_2_0_2_0; }

		//varArgs?="..."
		public Assignment getVarArgsAssignment_2_0_2_1() { return cVarArgsAssignment_2_0_2_1; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_2_0_2_1_0() { return cVarArgsFullStopFullStopFullStopKeyword_2_0_2_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_2_0_2_2() { return cParametersAssignment_2_0_2_2; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_2_0_2_2_0() { return cParametersParameterDeclarationParserRuleCall_2_0_2_2_0; }

		//varArgs?="..." parameters+=ParameterDeclaration
		public Group getGroup_2_1() { return cGroup_2_1; }

		//varArgs?="..."
		public Assignment getVarArgsAssignment_2_1_0() { return cVarArgsAssignment_2_1_0; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_2_1_0_0() { return cVarArgsFullStopFullStopFullStopKeyword_2_1_0_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_2_1_1() { return cParametersAssignment_2_1_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_2_1_1_0() { return cParametersParameterDeclarationParserRuleCall_2_1_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }

		//funcExpr=OneOrManyExpressions
		public Assignment getFuncExprAssignment_4() { return cFuncExprAssignment_4; }

		//OneOrManyExpressions
		public RuleCall getFuncExprOneOrManyExpressionsParserRuleCall_4_0() { return cFuncExprOneOrManyExpressionsParserRuleCall_4_0; }
	}

	public class OneOrManyExpressionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OneOrManyExpressions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockExpressionWithoutBracketsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//OneOrManyExpressions returns be::BExpression:
		//  BlockExpressionWithoutBrackets|Expression;
		public ParserRule getRule() { return rule; }

		//BlockExpressionWithoutBrackets|Expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//BlockExpressionWithoutBrackets
		public RuleCall getBlockExpressionWithoutBracketsParserRuleCall_0() { return cBlockExpressionWithoutBracketsParserRuleCall_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}

	public class BlockExpressionWithoutBracketsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockExpressionWithoutBrackets");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBChainedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionsTopLevelExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionsAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//BlockExpressionWithoutBrackets returns be::BExpression:
		//  {be::BChainedExpression} (expressions+=TopLevelExpression ";")+;
		public ParserRule getRule() { return rule; }

		//{be::BChainedExpression} (expressions+=TopLevelExpression ";")+
		public Group getGroup() { return cGroup; }

		//{be::BChainedExpression}
		public Action getBChainedExpressionAction_0() { return cBChainedExpressionAction_0; }

		//(expressions+=TopLevelExpression ";")+
		public Group getGroup_1() { return cGroup_1; }

		//expressions+=TopLevelExpression
		public Assignment getExpressionsAssignment_1_0() { return cExpressionsAssignment_1_0; }

		//TopLevelExpression
		public RuleCall getExpressionsTopLevelExpressionParserRuleCall_1_0_0() { return cExpressionsTopLevelExpressionParserRuleCall_1_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}

	public class MapEntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MapEntry");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBMapEntryAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cKeyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKeyKeyLiteralParserRuleCall_1_0 = (RuleCall)cKeyAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//MapEntry returns be::BMapEntry:
		//  {be::BMapEntry} key=KeyLiteral ":" value=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BMapEntry} key=KeyLiteral ":" value=Expression
		public Group getGroup() { return cGroup; }

		//{be::BMapEntry}
		public Action getBMapEntryAction_0() { return cBMapEntryAction_0; }

		//key=KeyLiteral
		public Assignment getKeyAssignment_1() { return cKeyAssignment_1; }

		//KeyLiteral
		public RuleCall getKeyKeyLiteralParserRuleCall_1_0() { return cKeyKeyLiteralParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
	}

	public class KeyLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "KeyLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cValueAlternatives_1_0 = (Alternatives)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueIDTerminalRuleCall_1_0_0 = (RuleCall)cValueAlternatives_1_0.eContents().get(0);
		private final RuleCall cValuePIDTerminalRuleCall_1_0_1 = (RuleCall)cValueAlternatives_1_0.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0_2 = (RuleCall)cValueAlternatives_1_0.eContents().get(2);
		
		//KeyLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=( ID | PID | STRING );
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=( ID | PID | STRING )
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=( ID | PID | STRING )
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//ID|PID|STRING
		public Alternatives getValueAlternatives_1_0() { return cValueAlternatives_1_0; }

		//ID
		public RuleCall getValueIDTerminalRuleCall_1_0_0() { return cValueIDTerminalRuleCall_1_0_0; }

		//PID
		public RuleCall getValuePIDTerminalRuleCall_1_0_1() { return cValuePIDTerminalRuleCall_1_0_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0_2() { return cValueSTRINGTerminalRuleCall_1_0_2; }
	}

	public class LiteralTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeRefParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		
		//LiteralType returns be::BExpression:
		//  {be::BLiteralType} type=TypeRef;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralType} type=TypeRef
		public Group getGroup() { return cGroup; }

		//{be::BLiteralType}
		public Action getBLiteralTypeAction_0() { return cBLiteralTypeAction_0; }

		//type=TypeRef
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_1_0() { return cTypeTypeRefParserRuleCall_1_0; }
	}

	public class ValueLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRealLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegerLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNullLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStringLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cUnitLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//ValueLiteral returns be::BExpression:
		//  BooleanLiteral|RealLiteral|IntegerLiteral|NullLiteral|StringLiteral|UnitLiteral; 
		//
		//     
		//	   
		//	     // SEE ISSUE 297089 - must be placed before IntegerLiteral
		//	    
		//	   
		//	  
		////	| QueryLiteral
		public ParserRule getRule() { return rule; }

		//BooleanLiteral|RealLiteral|IntegerLiteral|NullLiteral|StringLiteral|UnitLiteral 
		//
		//     
		//	   
		//	     // SEE ISSUE 297089 - must be placed before IntegerLiteral
		//	    
		//	   
		//	  
		////	| QueryLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }

		//RealLiteral      // SEE ISSUE 297089 - must be placed before IntegerLiteral
		public RuleCall getRealLiteralParserRuleCall_1() { return cRealLiteralParserRuleCall_1; }

		//IntegerLiteral
		public RuleCall getIntegerLiteralParserRuleCall_2() { return cIntegerLiteralParserRuleCall_2; }

		//NullLiteral
		public RuleCall getNullLiteralParserRuleCall_3() { return cNullLiteralParserRuleCall_3; }

		//StringLiteral   
		////	| QueryLiteral
		public RuleCall getStringLiteralParserRuleCall_4() { return cStringLiteralParserRuleCall_4; }

		//UnitLiteral
		public RuleCall getUnitLiteralParserRuleCall_5() { return cUnitLiteralParserRuleCall_5; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBooleanValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//BooleanLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=BooleanValue;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=BooleanValue
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=BooleanValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//BooleanValue
		public RuleCall getValueBooleanValueParserRuleCall_1_0() { return cValueBooleanValueParserRuleCall_1_0; }
	}

	public class IntegerLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueIntValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//IntegerLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=IntValue;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=IntValue
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=IntValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//IntValue
		public RuleCall getValueIntValueParserRuleCall_1_0() { return cValueIntValueParserRuleCall_1_0; }
	}

	public class UnitLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cValueUnitKeyword_1_0 = (Keyword)cValueAssignment_1.eContents().get(0);
		
		//UnitLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value="unit";
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value="unit"
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value="unit"
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//"unit"
		public Keyword getValueUnitKeyword_1_0() { return cValueUnitKeyword_1_0; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//StringLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=STRING;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=STRING
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}

	public class RealLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RealLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueRealValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//RealLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=RealValue;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=RealValue
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=RealValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//RealValue
		public RuleCall getValueRealValueParserRuleCall_1_0() { return cValueRealValueParserRuleCall_1_0; }
	}

	public class RegexpLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RegexpLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBRegularExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPatternAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPatternREGULAR_EXPRTerminalRuleCall_1_0 = (RuleCall)cPatternAssignment_1.eContents().get(0);
		
		//RegexpLiteral returns be::BExpression:
		//  {be::BRegularExpression} pattern=REGULAR_EXPR; 
		//	
		//        
		//	    
		//	
		//
		//// Note: NullLiteral has a java null value as its value
		public ParserRule getRule() { return rule; }

		//{be::BRegularExpression} pattern=REGULAR_EXPR
		public Group getGroup() { return cGroup; }

		//{be::BRegularExpression}
		public Action getBRegularExpressionAction_0() { return cBRegularExpressionAction_0; }

		//pattern=REGULAR_EXPR
		public Assignment getPatternAssignment_1() { return cPatternAssignment_1; }

		//REGULAR_EXPR
		public RuleCall getPatternREGULAR_EXPRTerminalRuleCall_1_0() { return cPatternREGULAR_EXPRTerminalRuleCall_1_0; }
	}

	public class NullLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NullLiteral returns be::BExpression:
		//  {be::BLiteralExpression} "null"; 
		//
		//// Note: NullLiteral has a java null value as its value
		//	         
		//	
		//	
		//
		////ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
		////SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
		//
		//// Has conversion rule
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} "null"
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}

	public class BooleanValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BooleanValue returns ecore::EBooleanObject:
		//  "true"|"false"; 
		//
		////ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
		////SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
		//
		//// Has conversion rule
		//              
		//
		//// Has conversion rule
		public ParserRule getRule() { return rule; }

		//"true"|"false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class RealValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RealValue");
		private final RuleCall cREALParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//RealValue returns ecore::EDoubleObject:
		//  REAL; 
		//
		//// Has conversion rule
		//        
		//
		//// Has conversion rule that handles decimal, octal, and hexadecimal values with radix
		public ParserRule getRule() { return rule; }

		//REAL
		public RuleCall getREALParserRuleCall() { return cREALParserRuleCall; }
	}

	public class IntValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//IntValue returns ecore::EIntegerObject:
		//  INT|HEX; 
		//
		//// Has conversion rule that handles decimal, octal, and hexadecimal values with radix
		public ParserRule getRule() { return rule; }

		//INT|HEX 
		//
		//// Has conversion rule that handles decimal, octal, and hexadecimal values with radix
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1() { return cHEXTerminalRuleCall_1; }
	}

	public class ParanthesizedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParanthesizedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParanthesizedExpression returns be::BExpression:
		//  "(" Expression ")"; 
		//	
		//       
		//	    
		//		
		//
		//// Has conversion rule
		public ParserRule getRule() { return rule; }

		//"(" Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class VersionLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VersionLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//VersionLiteral returns build::Version:
		//  STRING|AlfanumSym; 	
		//
		//// Has conversion rule
		//    
		//	    
		//	  
		//	
		//
		//// Has conversion rule
		public ParserRule getRule() { return rule; }

		//STRING|AlfanumSym 	
		//
		//// Has conversion rule
		//    
		//	    
		//	  
		//	
		//
		//// Has conversion rule
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_1() { return cAlfanumSymParserRuleCall_1; }
	}

	public class VersionRangeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VersionRangeLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0_1_0 = (RuleCall)cAlternatives_0_1.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_0_1_1 = (RuleCall)cAlternatives_0_1.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Alternatives cAlternatives_0_2_1 = (Alternatives)cGroup_0_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0_2_1_0 = (RuleCall)cAlternatives_0_2_1.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_0_2_1_1 = (RuleCall)cAlternatives_0_2_1.eContents().get(1);
		private final Alternatives cAlternatives_0_3 = (Alternatives)cGroup_0.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_0_3_0 = (Keyword)cAlternatives_0_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_3_1 = (Keyword)cAlternatives_0_3.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cAlternatives.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//VersionRangeLiteral returns build::VersionRange:
		//  ("["|"(") (STRING|AlfanumSym) ("," (STRING|AlfanumSym))? ("]"|")")|(STRING|
		//  AlfanumSym); 
		//
		//// Has conversion rule
		//    
		//	                      
		//	      
		//	
		//
		//// Reference to qualified named item, possibly in unit, this or super, or
		//// this.super, or unit.super
		//// TODO: super, unit, this - not yet handled - subject to change?
		public ParserRule getRule() { return rule; }

		//("["|"(") (STRING|AlfanumSym) ("," (STRING|AlfanumSym))? ("]"|")")|(STRING|
		//AlfanumSym) 
		//
		//// Has conversion rule
		//    
		//	                      
		//	      
		//	
		//
		//// Reference to qualified named item, possibly in unit, this or super, or
		//// this.super, or unit.super
		//// TODO: super, unit, this - not yet handled - subject to change?
		public Alternatives getAlternatives() { return cAlternatives; }

		//("["|"(") (STRING|AlfanumSym) ("," (STRING|AlfanumSym))? ("]"|")")
		public Group getGroup_0() { return cGroup_0; }

		//"["|"("
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_0_0() { return cLeftSquareBracketKeyword_0_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0_1() { return cLeftParenthesisKeyword_0_0_1; }

		//STRING|AlfanumSym
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0_1_0() { return cSTRINGTerminalRuleCall_0_1_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_0_1_1() { return cAlfanumSymParserRuleCall_0_1_1; }

		//("," (STRING|AlfanumSym))?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//","
		public Keyword getCommaKeyword_0_2_0() { return cCommaKeyword_0_2_0; }

		//STRING|AlfanumSym
		public Alternatives getAlternatives_0_2_1() { return cAlternatives_0_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0_2_1_0() { return cSTRINGTerminalRuleCall_0_2_1_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_0_2_1_1() { return cAlfanumSymParserRuleCall_0_2_1_1; }

		//"]"|")"
		public Alternatives getAlternatives_0_3() { return cAlternatives_0_3; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_3_0() { return cRightSquareBracketKeyword_0_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_3_1() { return cRightParenthesisKeyword_0_3_1; }

		//STRING|AlfanumSym
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1_0() { return cSTRINGTerminalRuleCall_1_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_1_1() { return cAlfanumSymParserRuleCall_1_1; }
	}

	public class QIDREFElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QIDREF");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cSuperKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Group cGroup_0_0_1 = (Group)cAlternatives_0_0.eContents().get(1);
		private final Alternatives cAlternatives_0_0_1_0 = (Alternatives)cGroup_0_0_1.eContents().get(0);
		private final Keyword cUnitKeyword_0_0_1_0_0 = (Keyword)cAlternatives_0_0_1_0.eContents().get(0);
		private final Keyword cThisKeyword_0_0_1_0_1 = (Keyword)cAlternatives_0_0_1_0.eContents().get(1);
		private final Group cGroup_0_0_1_1 = (Group)cGroup_0_0_1.eContents().get(1);
		private final Keyword cFullStopKeyword_0_0_1_1_0 = (Keyword)cGroup_0_0_1_1.eContents().get(0);
		private final Keyword cSuperKeyword_0_0_1_1_1 = (Keyword)cGroup_0_0_1_1.eContents().get(1);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cFullStopKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final RuleCall cQIDParserRuleCall_0_1_1 = (RuleCall)cGroup_0_1.eContents().get(1);
		private final RuleCall cQIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//QIDREF returns ecore::EString:
		//  ("super"|("unit"|"this") ("." "super")?) ("." QID)?|QID; 
		//
		//// Reference to qualified named item, possibly in unit, this or super, or
		//// this.super, or unit.super
		//// TODO: super, unit, this - not yet handled - subject to change?
		//                        
		//
		//// Qualified name
		public ParserRule getRule() { return rule; }

		//("super"|("unit"|"this") ("." "super")?) ("." QID)?|QID 
		//
		//// Reference to qualified named item, possibly in unit, this or super, or
		//// this.super, or unit.super
		//// TODO: super, unit, this - not yet handled - subject to change?
		//                        
		//
		//// Qualified name
		public Alternatives getAlternatives() { return cAlternatives; }

		//("super"|("unit"|"this") ("." "super")?) ("." QID)?
		public Group getGroup_0() { return cGroup_0; }

		//"super"|("unit"|"this") ("." "super")?
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"super"
		public Keyword getSuperKeyword_0_0_0() { return cSuperKeyword_0_0_0; }

		//("unit"|"this") ("." "super")?
		public Group getGroup_0_0_1() { return cGroup_0_0_1; }

		//"unit"|"this"
		public Alternatives getAlternatives_0_0_1_0() { return cAlternatives_0_0_1_0; }

		//"unit"
		public Keyword getUnitKeyword_0_0_1_0_0() { return cUnitKeyword_0_0_1_0_0; }

		//"this"
		public Keyword getThisKeyword_0_0_1_0_1() { return cThisKeyword_0_0_1_0_1; }

		//("." "super")?
		public Group getGroup_0_0_1_1() { return cGroup_0_0_1_1; }

		//"."
		public Keyword getFullStopKeyword_0_0_1_1_0() { return cFullStopKeyword_0_0_1_1_0; }

		//"super"
		public Keyword getSuperKeyword_0_0_1_1_1() { return cSuperKeyword_0_0_1_1_1; }

		//("." QID)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"."
		public Keyword getFullStopKeyword_0_1_0() { return cFullStopKeyword_0_1_0; }

		//QID
		public RuleCall getQIDParserRuleCall_0_1_1() { return cQIDParserRuleCall_0_1_1; }

		//QID
		public RuleCall getQIDParserRuleCall_1() { return cQIDParserRuleCall_1; }
	}

	public class QIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Alternatives cAlternatives_2_2 = (Alternatives)cGroup_2.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_2_2_0 = (RuleCall)cAlternatives_2_2.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_2_2_1 = (RuleCall)cAlternatives_2_2.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_2_2_2 = (RuleCall)cAlternatives_2_2.eContents().get(2);
		
		//QID returns ecore::EString hidden ( ):
		//  ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)*; 
		//
		//// Qualified name
		//               
		//
		//// Allows a qualified name, or a string to be used as a name
		public ParserRule getRule() { return rule; }

		//ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//(INT|HEX|ID)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_0() { return cINTTerminalRuleCall_1_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1_1() { return cHEXTerminalRuleCall_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_2() { return cIDTerminalRuleCall_1_2; }

		//("." ID (INT|HEX|ID)*)*
		public Group getGroup_2() { return cGroup_2; }

		//"."
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_2_1() { return cIDTerminalRuleCall_2_1; }

		//(INT|HEX|ID)*
		public Alternatives getAlternatives_2_2() { return cAlternatives_2_2; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_2_0() { return cINTTerminalRuleCall_2_2_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_2_2_1() { return cHEXTerminalRuleCall_2_2_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_2_2_2() { return cIDTerminalRuleCall_2_2_2; }
	}

	public class EscapedQualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EscapedQualifiedName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EscapedQualifiedName returns ecore::EString:
		//  STRING|QID;  
		//
		//// Allows a qualified name, or a string to be used as a name
		public ParserRule getRule() { return rule; }

		//STRING|QID  
		//
		//// Allows a qualified name, or a string to be used as a name
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//QID
		public RuleCall getQIDParserRuleCall_1() { return cQIDParserRuleCall_1; }
	}

	public class InterfaceNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InterfaceName");
		private final RuleCall cQIDParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//InterfaceName returns ecore::EString:
		//  QID; 
		//	     
		//
		//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
		public ParserRule getRule() { return rule; }

		//QID
		public RuleCall getQIDParserRuleCall() { return cQIDParserRuleCall; }
	}

	public class UnitNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitName");
		private final RuleCall cEscapedQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//UnitName returns ecore::EString:
		//  EscapedQualifiedName; 
		//
		//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall() { return cEscapedQualifiedNameParserRuleCall; }
	}

	public class BuilderNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderName");
		private final RuleCall cEscapedQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BuilderName returns ecore::EString:
		//  EscapedQualifiedName;
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall() { return cEscapedQualifiedNameParserRuleCall; }
	}

	public class CapabilityNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CapabilityName");
		private final RuleCall cEscapedQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//CapabilityName returns ecore::EString:
		//  EscapedQualifiedName;
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall() { return cEscapedQualifiedNameParserRuleCall; }
	}

	public class SeparatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Separator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cCommercialAtKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDollarSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPercentSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cAmpersandKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cPlusSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cEqualsSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cAsteriskKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cLessThanSignKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cGreaterThanSignKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cColonKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cQuestionMarkKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		
		//Separator returns ecore::EString:
		//  "."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?"; 
		//
		//
		//// Version, and VersionRange
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public ParserRule getRule() { return rule; }

		//"."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?" 
		//
		//
		//// Version, and VersionRange
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }

		//"!"
		public Keyword getExclamationMarkKeyword_2() { return cExclamationMarkKeyword_2; }

		//"@"
		public Keyword getCommercialAtKeyword_3() { return cCommercialAtKeyword_3; }

		//"$"
		public Keyword getDollarSignKeyword_4() { return cDollarSignKeyword_4; }

		//"%"
		public Keyword getPercentSignKeyword_5() { return cPercentSignKeyword_5; }

		//"&"
		public Keyword getAmpersandKeyword_6() { return cAmpersandKeyword_6; }

		//"+"
		public Keyword getPlusSignKeyword_7() { return cPlusSignKeyword_7; }

		//"="
		public Keyword getEqualsSignKeyword_8() { return cEqualsSignKeyword_8; }

		//"*"
		public Keyword getAsteriskKeyword_9() { return cAsteriskKeyword_9; }

		//"<"
		public Keyword getLessThanSignKeyword_10() { return cLessThanSignKeyword_10; }

		//">"
		public Keyword getGreaterThanSignKeyword_11() { return cGreaterThanSignKeyword_11; }

		//":"
		public Keyword getColonKeyword_12() { return cColonKeyword_12; }

		//"?"
		public Keyword getQuestionMarkKeyword_13() { return cQuestionMarkKeyword_13; }
	}

	public class AlfanumSymElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AlfanumSym");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cHEXTerminalRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cEXT_INTTerminalRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cSeparatorParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cHEXTerminalRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		private final RuleCall cEXT_INTTerminalRuleCall_1_4 = (RuleCall)cAlternatives_1.eContents().get(4);
		
		//AlfanumSym returns ecore::EString:
		//  (ID|INT|HEX|EXT_INT) (Separator|ID|INT|HEX|EXT_INT)*; 
		//                      
		//
		//// --TERMINALS
		//// (NOTE: Does not use standard terminals to have full control).
		//
		//// TODO: Possibly use some other char instead of ^ as escape mechanism for keywords??
		public ParserRule getRule() { return rule; }

		//(ID|INT|HEX|EXT_INT) (Separator|ID|INT|HEX|EXT_INT)*
		public Group getGroup() { return cGroup; }

		//ID|INT|HEX|EXT_INT
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_0() { return cIDTerminalRuleCall_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_0_2() { return cHEXTerminalRuleCall_0_2; }

		//EXT_INT
		public RuleCall getEXT_INTTerminalRuleCall_0_3() { return cEXT_INTTerminalRuleCall_0_3; }

		//(Separator|ID|INT|HEX|EXT_INT)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//Separator
		public RuleCall getSeparatorParserRuleCall_1_0() { return cSeparatorParserRuleCall_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_2() { return cINTTerminalRuleCall_1_2; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1_3() { return cHEXTerminalRuleCall_1_3; }

		//EXT_INT
		public RuleCall getEXT_INTTerminalRuleCall_1_4() { return cEXT_INTTerminalRuleCall_1_4; }
	}

	public class REALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "REAL");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cEXT_INTTerminalRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		
		//REAL returns ecore::EString hidden ( ):
		//  INT? "." (EXT_INT|INT);
		public ParserRule getRule() { return rule; }

		//INT? "." (EXT_INT|INT)
		public Group getGroup() { return cGroup; }

		//INT?
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//EXT_INT|INT
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//EXT_INT
		public RuleCall getEXT_INTTerminalRuleCall_2_0() { return cEXT_INTTerminalRuleCall_2_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}
	
	
	public class VisibilityElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Visibility");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPublicEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPublicPublicKeyword_0_0 = (Keyword)cPublicEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPrivateEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPrivatePrivateKeyword_1_0 = (Keyword)cPrivateEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Visibility returns be::Visibility:
		//  public | private;
		public EnumRule getRule() { return rule; }

		//public | private
		public Alternatives getAlternatives() { return cAlternatives; }

		//public
		public EnumLiteralDeclaration getPublicEnumLiteralDeclaration_0() { return cPublicEnumLiteralDeclaration_0; }

		//"public"
		public Keyword getPublicPublicKeyword_0_0() { return cPublicPublicKeyword_0_0; }

		//private
		public EnumLiteralDeclaration getPrivateEnumLiteralDeclaration_1() { return cPrivateEnumLiteralDeclaration_1; }

		//"private"
		public Keyword getPrivatePrivateKeyword_1_0() { return cPrivatePrivateKeyword_1_0; }
	}

	public class ExecutionModeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ExecutionMode");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cParallelEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cParallelParallelKeyword_0_0 = (Keyword)cParallelEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSequentialEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSequentialSequentialKeyword_1_0 = (Keyword)cSequentialEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ExecutionMode returns be::ExecutionMode:
		//  parallel | sequential; 
		//   	           
		//
		//
		//// Version, and VersionRange
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public EnumRule getRule() { return rule; }

		//parallel | sequential 
		//   	           
		//
		//
		//// Version, and VersionRange
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//parallel
		public EnumLiteralDeclaration getParallelEnumLiteralDeclaration_0() { return cParallelEnumLiteralDeclaration_0; }

		//"parallel"
		public Keyword getParallelParallelKeyword_0_0() { return cParallelParallelKeyword_0_0; }

		//sequential
		public EnumLiteralDeclaration getSequentialEnumLiteralDeclaration_1() { return cSequentialEnumLiteralDeclaration_1; }

		//"sequential"
		public Keyword getSequentialSequentialKeyword_1_0() { return cSequentialSequentialKeyword_1_0; }
	}
	
	private BeeModelElements pBeeModel;
	private ImportElements pImport;
	private BuildUnitElements pBuildUnit;
	private ProvidedCapabilityElements pProvidedCapability;
	private RequiredCapabilityElements pRequiredCapability;
	private RequiredCapability_UnfilteredElements pRequiredCapability_Unfiltered;
	private PropertySet_NamedElements pPropertySet_Named;
	private PropertySetElements pPropertySet;
	private PropertyOperationElements pPropertyOperation;
	private ConditionalPropertyOperationElements pConditionalPropertyOperation;
	private PropertyDefinitionOperationElements pPropertyDefinitionOperation;
	private PropertyValDeclarationElements pPropertyValDeclaration;
	private PropertyVarDeclarationElements pPropertyVarDeclaration;
	private PropertySetOperationElements pPropertySetOperation;
	private SynchronizationElements pSynchronization;
	private SynchronizedBuilderElements pSynchronizedBuilder;
	private PathGroupElements pPathGroup;
	private PathVectorElements pPathVector;
	private BasePathVectorElements pBasePathVector;
	private UnbasedPathVectorElements pUnbasedPathVector;
	private CompoundPathVectorElements pCompoundPathVector;
	private PathElements pPath;
	private PrerequisiteElements pPrerequisite;
	private WithClauseElements pWithClause;
	private BuildResultReferenceElements pBuildResultReference;
	private UnitBuildResultReferenceElements pUnitBuildResultReference;
	private CapabilityBuildResultReferenceElements pCapabilityBuildResultReference;
	private CompoundBuildResultReferenceElements pCompoundBuildResultReference;
	private BuilderElements pBuilder;
	private ParameterListElements pParameterList;
	private FirstParameterElements pFirstParameter;
	private ParameterElements pParameter;
	private ClosureParameterElements pClosureParameter;
	private ParameterDeclarationElements pParameterDeclaration;
	private BuilderInputElements pBuilderInput;
	private RepositoryConfigurationElements pRepositoryConfiguration;
	private RepositoryDeclarationElements pRepositoryDeclaration;
	private ResolutionStrategyElements pResolutionStrategy;
	private ResolutionStrategyFirstElements pResolutionStrategyFirst;
	private ResolutionStrategyBestElements pResolutionStrategyBest;
	private ContainerConfigurationElements pContainerConfiguration;
	private URIElements pURI;
	private Concern_NamedElements pConcern_Named;
	private Concern_AnonymousElements pConcern_Anonymous;
	private FunctionElements pFunction;
	private GuardExpressionElements pGuardExpression;
	private AssignmentOperatorElements pAssignmentOperator;
	private RelationalOperatorElements pRelationalOperator;
	private TopLevelExpressionElements pTopLevelExpression;
	private ExpressionElements pExpression;
	private AssignmentExpressionElements pAssignmentExpression;
	private VarDeclarationElements pVarDeclaration;
	private ValDeclarationElements pValDeclaration;
	private TypeRefElements pTypeRef;
	private SimpleTypeRefElements pSimpleTypeRef;
	private ClosureTypeRefElements pClosureTypeRef;
	private TypeParamElements pTypeParam;
	private TypeRefParamElements pTypeRefParam;
	private WildcardRefParamElements pWildcardRefParam;
	private CachedExpressionElements pCachedExpression;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private RelationalExpressionElements pRelationalExpression;
	private InstanceOfExpressionElements pInstanceOfExpression;
	private AdditiveExpressionElements pAdditiveExpression;
	private MultiplicativeExpressionElements pMultiplicativeExpression;
	private SetExpressionElements pSetExpression;
	private UnaryOrInfixExpressionElements pUnaryOrInfixExpression;
	private UnaryExpressionElements pUnaryExpression;
	private PreopExpressionElements pPreopExpression;
	private PostopExpressionElements pPostopExpression;
	private InfixExpressionElements pInfixExpression;
	private CallExpressionElements pCallExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private WildcardExpressionElements pWildcardExpression;
	private ThrowExpressionElements pThrowExpression;
	private TryCatchExpressionElements pTryCatchExpression;
	private CatchBlockElements pCatchBlock;
	private SwitchExpressionElements pSwitchExpression;
	private CaseElements pCase;
	private BlockExpressionElements pBlockExpression;
	private IfExpressionElements pIfExpression;
	private ElseIfExpressionElements pElseIfExpression;
	private PropertyValueElements pPropertyValue;
	private VariableValueElements pVariableValue;
	private KeywordVariablesElements pKeywordVariables;
	private FeatureCallElements pFeatureCall;
	private OperationCallElements pOperationCall;
	private ConstructorCallExpressionElements pConstructorCallExpression;
	private BuildConcernContextElements pBuildConcernContext;
	private UnitConcernContextElements pUnitConcernContext;
	private BuilderConcernContextElements pBuilderConcernContext;
	private UnitOrExpressionElements pUnitOrExpression;
	private UnitAndExpressionElements pUnitAndExpression;
	private UnitNotOrPrimaryExpressionElements pUnitNotOrPrimaryExpression;
	private UnitNotExpressionElements pUnitNotExpression;
	private UnitPrimaryExpressionElements pUnitPrimaryExpression;
	private GroupedUnitPrimaryExpressionElements pGroupedUnitPrimaryExpression;
	private RequiresPredicateElements pRequiresPredicate;
	private ImplementsPredcicateElements pImplementsPredcicate;
	private ProvidesPredicateElements pProvidesPredicate;
	private UnitNamePredicateElements pUnitNamePredicate;
	private BuilderNamePredicateElements pBuilderNamePredicate;
	private InputPredicateElements pInputPredicate;
	private OutputPredicateElements pOutputPredicate;
	private BasePathPredicateElements pBasePathPredicate;
	private PathPredicateElements pPathPredicate;
	private CapabilityPredicateElements pCapabilityPredicate;
	private NamePredicateElements pNamePredicate;
	private BuilderOrExpressionElements pBuilderOrExpression;
	private BuilderAndExpressionElements pBuilderAndExpression;
	private BuilderNotOrPrimaryExpressionElements pBuilderNotOrPrimaryExpression;
	private BuilderNotExpressionElements pBuilderNotExpression;
	private BuilderPrimaryExpressionElements pBuilderPrimaryExpression;
	private GroupedBuilderPrimaryExpressionElements pGroupedBuilderPrimaryExpression;
	private ContextBlockElements pContextBlock;
	private ContextBlock_CreationElements pContextBlock_Creation;
	private LiteralElements pLiteral;
	private LiteralListElements pLiteralList;
	private LiteralMapElements pLiteralMap;
	private LiteralFunctionElements pLiteralFunction;
	private ClosureExpressionElements pClosureExpression;
	private OneOrManyExpressionsElements pOneOrManyExpressions;
	private BlockExpressionWithoutBracketsElements pBlockExpressionWithoutBrackets;
	private MapEntryElements pMapEntry;
	private KeyLiteralElements pKeyLiteral;
	private LiteralTypeElements pLiteralType;
	private ValueLiteralElements pValueLiteral;
	private BooleanLiteralElements pBooleanLiteral;
	private IntegerLiteralElements pIntegerLiteral;
	private UnitLiteralElements pUnitLiteral;
	private StringLiteralElements pStringLiteral;
	private RealLiteralElements pRealLiteral;
	private RegexpLiteralElements pRegexpLiteral;
	private NullLiteralElements pNullLiteral;
	private BooleanValueElements pBooleanValue;
	private RealValueElements pRealValue;
	private IntValueElements pIntValue;
	private ParanthesizedExpressionElements pParanthesizedExpression;
	private VersionLiteralElements pVersionLiteral;
	private VersionRangeLiteralElements pVersionRangeLiteral;
	private QIDREFElements pQIDREF;
	private QIDElements pQID;
	private EscapedQualifiedNameElements pEscapedQualifiedName;
	private InterfaceNameElements pInterfaceName;
	private UnitNameElements pUnitName;
	private BuilderNameElements pBuilderName;
	private CapabilityNameElements pCapabilityName;
	private VisibilityElements unknownRuleVisibility;
	private ExecutionModeElements unknownRuleExecutionMode;
	private SeparatorElements pSeparator;
	private AlfanumSymElements pAlfanumSym;
	private TerminalRule tID;
	private TerminalRule tPID;
	private TerminalRule tREGULAR_EXPR;
	private TerminalRule tSTRING;
	private TerminalRule tDOCUMENTATION;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tHEX;
	private TerminalRule tINT;
	private REALElements pREAL;
	private TerminalRule tEXT_INT;
	private TerminalRule tANY_OTHER;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public BeeLangGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	//BeeModel hidden ( WS , SL_COMMENT , ML_COMMENT ):
	//  imports+=Import* (functions+=Function|concern+=Concern_Named|"properties"
	//  propertySets+=PropertySet_Named)* body=BuildUnit?;
	public BeeModelElements getBeeModelAccess() {
		return (pBeeModel != null) ? pBeeModel : (pBeeModel = new BeeModelElements());
	}
	
	public ParserRule getBeeModelRule() {
		return getBeeModelAccess().getRule();
	}

	//Import returns be::IType:
	//  {be::B3JavaImport} reexport?="reexport"? "import" qualifiedName=QID ("as" name=ID)?
	//  ";"; 
	//
	//        
	//	                 
	//	
	//
	//// Wanted later 
	////Import : (reexport ?='reexport')? 
	////		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
	////	; 
	//
	////JavaImporter 	: qualifiedName=QID ;
	////NativeImporter 	: uriString = STRING ;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//BuildUnit returns build::BuildUnit hidden ( WS , ML_COMMENT , SL_COMMENT ):
	//  {build::BuildUnit} documentation=DOCUMENTATION? executionMode=ExecutionMode? "unit"
	//  name=UnitName? ("version" version=VersionLiteral)? ("implements" implements+=
	//  SimpleTypeRef ("," implements+=SimpleTypeRef)*)? "{" ("default" "properties"
	//  defaultProperties=PropertySet)? ("provides" "{" (unitProvidedCapabilities+=
	//  ProvidedCapability ";")+ "}"|"provides" unitProvidedCapabilities+=
	//  ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=RequiredCapability ";")
	//  + "}"|"requires" requiredCapabilities+=RequiredCapability ";"|"env" "requires" "{" (
	//  metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"env" "requires"
	//  metaRequiredCapabilities+=RequiredCapability ";"|concerns+=Concern_Named|
	//  "sequential" "{" synchronizations+=Synchronization+ "}"|"sequential"
	//  synchronizations+=Synchronization|functions+=Builder|functions+=Function|
	//  "repositories" "{" repositories+=RepositoryConfiguration* "}"|"properties"
	//  propertySets+=PropertySet_Named|"containers" "{" containers+=
	//  ContainerConfiguration* "}")* "}"; 
	//
	//// Wanted later 
	////Import : (reexport ?='reexport')? 
	////		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
	////	; 
	//
	////JavaImporter 	: qualifiedName=QID ;
	////NativeImporter 	: uriString = STRING ;
	//		
	//              
	//	    
	//	    
	//	          
	//		           
	//	
	//			 //-- PROPERTIES
	//			 // goes first, because they may be used in the other clauses. TODO: can probably be relaxed
	//			 // since linking will find them anyway.
	//			 //
	//			            
	//		
	//		 	 //-- PROVIDES
	//			               
	//			          
	//			//-- REQUIRES & META REQUIRES
	//			               
	//			          
	//			                  
	//			            
	//			//--CONCERNS
	//			       
	//			//--SYNCHRONIZE
	//			                  
	//			           
	//			//--BUILDERS & FUNCTIONS
	//			         			
	//			        			
	//			//-- REPOSITORIES
	public BuildUnitElements getBuildUnitAccess() {
		return (pBuildUnit != null) ? pBuildUnit : (pBuildUnit = new BuildUnitElements());
	}
	
	public ParserRule getBuildUnitRule() {
		return getBuildUnitAccess().getRule();
	}

	//ProvidedCapability returns build::VersionedCapability:
	//  {build::VersionedCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
	//  InterfaceName "/" name=CapabilityName ("/" version=VersionLiteral)?; 
	//
	//        
	//	        
	//	     
	//	    
	//	
	//	
	//// Capability required by a unit - always refers to capabilities with at least ns/name
	public ProvidedCapabilityElements getProvidedCapabilityAccess() {
		return (pProvidedCapability != null) ? pProvidedCapability : (pProvidedCapability = new ProvidedCapabilityElements());
	}
	
	public ParserRule getProvidedCapabilityRule() {
		return getProvidedCapabilityAccess().getRule();
	}

	//RequiredCapability returns build::RequiredCapability:
	//  {build::RequiredCapability} ("when" "(" condExpr=Expression ")")? nameSpace=
	//  InterfaceName "/" name=CapabilityName ("/" versionRange=VersionRangeLiteral)?; 
	//	
	//// Capability required by a unit - always refers to capabilities with at least ns/name
	public RequiredCapabilityElements getRequiredCapabilityAccess() {
		return (pRequiredCapability != null) ? pRequiredCapability : (pRequiredCapability = new RequiredCapabilityElements());
	}
	
	public ParserRule getRequiredCapabilityRule() {
		return getRequiredCapabilityAccess().getRule();
	}

	//RequiredCapability_Unfiltered returns build::RequiredCapability:
	//  {build::RequiredCapability} (nameSpace=InterfaceName "/")? name=CapabilityName ("/"
	//  versionRange=VersionRangeLiteral)?; 
	//	
	//         
	//	     
	//	    
	//	
	//	
	//// An optionally named sequence of property statements
	public RequiredCapability_UnfilteredElements getRequiredCapability_UnfilteredAccess() {
		return (pRequiredCapability_Unfiltered != null) ? pRequiredCapability_Unfiltered : (pRequiredCapability_Unfiltered = new RequiredCapability_UnfilteredElements());
	}
	
	public ParserRule getRequiredCapability_UnfilteredRule() {
		return getRequiredCapability_UnfilteredAccess().getRule();
	}

	//PropertySet_Named returns be::BPropertySet:
	//  {be::BPropertySet} name=ID ("extends" extends=[be::BPropertySet|QIDREF])? "{"
	//  operations+=PropertyOperation* "}"; 
	//	
	//// An optionally named sequence of property statements
	//         
	//	                         
	//	
	//
	//// Sequence of possibly filtered property statements
	public PropertySet_NamedElements getPropertySet_NamedAccess() {
		return (pPropertySet_Named != null) ? pPropertySet_Named : (pPropertySet_Named = new PropertySet_NamedElements());
	}
	
	public ParserRule getPropertySet_NamedRule() {
		return getPropertySet_NamedAccess().getRule();
	}

	//PropertySet returns be::BPropertySet:
	//  {be::BPropertySet} ("extends" extends=[be::BPropertySet|QIDREF])? "{" operations+=
	//  PropertyOperation* "}"; 
	//
	//// Sequence of possibly filtered property statements	
	//         
	//	                    
	//	
	//
	//// For model generation, to get supertype correct
	public PropertySetElements getPropertySetAccess() {
		return (pPropertySet != null) ? pPropertySet : (pPropertySet = new PropertySetElements());
	}
	
	public ParserRule getPropertySetRule() {
		return getPropertySetAccess().getRule();
	}

	//PropertyOperation returns be::BPropertyOperation:
	//  ConditionalPropertyOperation|PropertyDefinitionOperation|PropertySetOperation; 
	//
	//// For model generation, to get supertype correct
	public PropertyOperationElements getPropertyOperationAccess() {
		return (pPropertyOperation != null) ? pPropertyOperation : (pPropertyOperation = new PropertyOperationElements());
	}
	
	public ParserRule getPropertyOperationRule() {
		return getPropertyOperationAccess().getRule();
	}

	//ConditionalPropertyOperation returns be::BPropertyOperation:
	//  {be::BConditionalPropertyOperation} "when" "(" condExpr=Expression ")" (body=
	//  PropertyDefinitionOperation|body=PropertySetOperation);
	public ConditionalPropertyOperationElements getConditionalPropertyOperationAccess() {
		return (pConditionalPropertyOperation != null) ? pConditionalPropertyOperation : (pConditionalPropertyOperation = new ConditionalPropertyOperationElements());
	}
	
	public ParserRule getConditionalPropertyOperationRule() {
		return getConditionalPropertyOperationAccess().getRule();
	}

	//PropertyDefinitionOperation returns be::BPropertyOperation:
	//  {be::BPropertyDefinitionOperation} (definition=PropertyValDeclaration|definition=
	//  PropertyVarDeclaration); 
	//        
	//	            
	//	
	//		
	//// property values, must be assigned (but can be assigned null).
	public PropertyDefinitionOperationElements getPropertyDefinitionOperationAccess() {
		return (pPropertyDefinitionOperation != null) ? pPropertyDefinitionOperation : (pPropertyDefinitionOperation = new PropertyDefinitionOperationElements());
	}
	
	public ParserRule getPropertyDefinitionOperationRule() {
		return getPropertyDefinitionOperationAccess().getRule();
	}

	//PropertyValDeclaration returns be::BDefProperty:
	//  {be::BDefProperty} final?="final"? type=TypeRef? name=PID "=" valueExpr=Expression ";"
	//; 
	//		
	//// property values, must be assigned (but can be assigned null).
	//         
	//	                    
	//	
	//	
	//// property variables, value optionally assigned
	public PropertyValDeclarationElements getPropertyValDeclarationAccess() {
		return (pPropertyValDeclaration != null) ? pPropertyValDeclaration : (pPropertyValDeclaration = new PropertyValDeclarationElements());
	}
	
	public ParserRule getPropertyValDeclarationRule() {
		return getPropertyValDeclarationAccess().getRule();
	}

	//PropertyVarDeclaration returns be::BDefProperty:
	//  {be::BDefProperty} final?="final"? mutable?="mutable" type=TypeRef? name=PID ("="
	//  valueExpr=Expression)? ";"; 
	//	
	//// property variables, value optionally assigned
	public PropertyVarDeclarationElements getPropertyVarDeclarationAccess() {
		return (pPropertyVarDeclaration != null) ? pPropertyVarDeclaration : (pPropertyVarDeclaration = new PropertyVarDeclarationElements());
	}
	
	public ParserRule getPropertyVarDeclarationRule() {
		return getPropertyVarDeclarationAccess().getRule();
	}

	//PropertySetOperation returns be::BPropertyOperation:
	//  {be::BPropertySetOperation} propertySet=PropertySet;
	public PropertySetOperationElements getPropertySetOperationAccess() {
		return (pPropertySetOperation != null) ? pPropertySetOperation : (pPropertySetOperation = new PropertySetOperationElements());
	}
	
	public ParserRule getPropertySetOperationRule() {
		return getPropertySetOperationAccess().getRule();
	}

	//Synchronization returns build::Synchronization:
	//  {build::Synchronization} builders+=SynchronizedBuilder ("," builders+=
	//  SynchronizedBuilder)+ ";"; 
	//
	//        
	//	            
	//	
	//
	//// TODO: This is really a builder reference (which could be reused/refactored)
	public SynchronizationElements getSynchronizationAccess() {
		return (pSynchronization != null) ? pSynchronization : (pSynchronization = new SynchronizationElements());
	}
	
	public ParserRule getSynchronizationRule() {
		return getSynchronizationAccess().getRule();
	}

	//SynchronizedBuilder returns build::SynchronizedBuilder:
	//  {build::SynchronizedBuilder} nameSpace=EscapedQualifiedName "/" name=
	//  EscapedQualifiedName ("#" builderName=BuilderName)?|builderName=BuilderName; 
	//
	//// TODO: This is really a builder reference (which could be reused/refactored)
	public SynchronizedBuilderElements getSynchronizedBuilderAccess() {
		return (pSynchronizedBuilder != null) ? pSynchronizedBuilder : (pSynchronizedBuilder = new SynchronizedBuilderElements());
	}
	
	public ParserRule getSynchronizedBuilderRule() {
		return getSynchronizedBuilderAccess().getRule();
	}

	//PathGroup returns build::PathGroup:
	//  {build::PathGroup} pathVectors+=PathVector+ ("annotations" annotations=PropertySet)
	//  ?;
	public PathGroupElements getPathGroupAccess() {
		return (pPathGroup != null) ? pPathGroup : (pPathGroup = new PathGroupElements());
	}
	
	public ParserRule getPathGroupRule() {
		return getPathGroupAccess().getRule();
	}

	//PathVector returns build::PathVector:
	//  BasePathVector|UnbasedPathVector|CompoundPathVector;
	public PathVectorElements getPathVectorAccess() {
		return (pPathVector != null) ? pPathVector : (pPathVector = new PathVectorElements());
	}
	
	public ParserRule getPathVectorRule() {
		return getPathVectorAccess().getRule();
	}

	//BasePathVector returns build::PathVector:
	//  {build::PathVectorElement} ("when" "(" condExpr=Expression ")")? basePath=Path "[" (
	//  paths+=Path ("," paths+=Path)*)? "]" ";";
	public BasePathVectorElements getBasePathVectorAccess() {
		return (pBasePathVector != null) ? pBasePathVector : (pBasePathVector = new BasePathVectorElements());
	}
	
	public ParserRule getBasePathVectorRule() {
		return getBasePathVectorAccess().getRule();
	}

	//UnbasedPathVector returns build::PathVector:
	//  {build::PathVectorElement} ("when" "(" condExpr=Expression ")")? paths+=Path ("," paths
	//  +=Path)* ";";
	public UnbasedPathVectorElements getUnbasedPathVectorAccess() {
		return (pUnbasedPathVector != null) ? pUnbasedPathVector : (pUnbasedPathVector = new UnbasedPathVectorElements());
	}
	
	public ParserRule getUnbasedPathVectorRule() {
		return getUnbasedPathVectorAccess().getRule();
	}

	//CompoundPathVector returns build::PathVector:
	//  {build::CompoundPathVector} "when" "(" condExpr=Expression ")" "{" pathVectors+=
	//  PathVector* "}"; 
	//	
	//        
	//	      
	//	         
	//	
	//
	//// A path can be written without quotes if it consists of safe chars
	public CompoundPathVectorElements getCompoundPathVectorAccess() {
		return (pCompoundPathVector != null) ? pCompoundPathVector : (pCompoundPathVector = new CompoundPathVectorElements());
	}
	
	public ParserRule getCompoundPathVectorRule() {
		return getCompoundPathVectorAccess().getRule();
	}

	//Path returns ecore::EString hidden ( ):
	//  STRING|"/"? QID ("/" QID)* "/"?; 
	//
	//// A path can be written without quotes if it consists of safe chars
	public PathElements getPathAccess() {
		return (pPath != null) ? pPath : (pPath = new PathElements());
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}

	//Prerequisite returns build::Prerequisite:
	//  {build::Prerequisite} ("when" "(" condExpr=Expression ")")? withExpr=WithClause?
	//  buildResult=BuildResultReference ("as" alias=ID)? ";"; 
	//
	//         
	//	        
	//	    
	//	
	//	    
	//	
	//
	//// Validation checks that there is at least one of references, properties or concern.
	public PrerequisiteElements getPrerequisiteAccess() {
		return (pPrerequisite != null) ? pPrerequisite : (pPrerequisite = new PrerequisiteElements());
	}
	
	public ParserRule getPrerequisiteRule() {
		return getPrerequisiteAccess().getRule();
	}

	//WithClause returns be::BWithExpression:
	//  {be::BWithExpression} "with" ("(" referencedAdvice+=[be::BAdvice] (","
	//  referencedAdvice+=[be::BAdvice])* ")")? ("properties" propertySets+=PropertySet|
	//  "concern" concerns+=Concern_Anonymous)*; 
	//
	//// Validation checks that there is at least one of references, properties or concern.
	public WithClauseElements getWithClauseAccess() {
		return (pWithClause != null) ? pWithClause : (pWithClause = new WithClauseElements());
	}
	
	public ParserRule getWithClauseRule() {
		return getWithClauseAccess().getRule();
	}

	//BuildResultReference returns build::BuildResultReference:
	//  UnitBuildResultReference|CapabilityBuildResultReference|
	//  CompoundBuildResultReference;
	public BuildResultReferenceElements getBuildResultReferenceAccess() {
		return (pBuildResultReference != null) ? pBuildResultReference : (pBuildResultReference = new BuildResultReferenceElements());
	}
	
	public ParserRule getBuildResultReferenceRule() {
		return getBuildResultReferenceAccess().getRule();
	}

	//UnitBuildResultReference returns build::BuildResultReference:
	//  {build::BuilderReference} "unit"? "#" builderName=BuilderName ("(" parameters=
	//  ParameterList ")")?;
	public UnitBuildResultReferenceElements getUnitBuildResultReferenceAccess() {
		return (pUnitBuildResultReference != null) ? pUnitBuildResultReference : (pUnitBuildResultReference = new UnitBuildResultReferenceElements());
	}
	
	public ParserRule getUnitBuildResultReferenceRule() {
		return getUnitBuildResultReferenceAccess().getRule();
	}

	//CapabilityBuildResultReference returns build::BuildResultReference:
	//  {build::BuilderReference} requiredCapability=RequiredCapability_Unfiltered ("#"
	//  builderName=BuilderName)? ("(" parameters=ParameterList ")")?;
	public CapabilityBuildResultReferenceElements getCapabilityBuildResultReferenceAccess() {
		return (pCapabilityBuildResultReference != null) ? pCapabilityBuildResultReference : (pCapabilityBuildResultReference = new CapabilityBuildResultReferenceElements());
	}
	
	public ParserRule getCapabilityBuildResultReferenceRule() {
		return getCapabilityBuildResultReferenceAccess().getRule();
	}

	//CompoundBuildResultReference returns build::BuildResultReference:
	//  {build::CompoundBuildResultReference} "{" prerequisites+=Prerequisite* "}";
	public CompoundBuildResultReferenceElements getCompoundBuildResultReferenceAccess() {
		return (pCompoundBuildResultReference != null) ? pCompoundBuildResultReference : (pCompoundBuildResultReference = new CompoundBuildResultReferenceElements());
	}
	
	public ParserRule getCompoundBuildResultReferenceRule() {
		return getCompoundBuildResultReferenceAccess().getRule();
	}

	//Builder returns build::Builder:
	//  {build::Builder} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
	//  ExecutionMode? final?="final"? "builder" name=BuilderName ("(" (parameters+=
	//  ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
	//  parameters+=ParameterDeclaration)?)|(varArgs?="..." parameters+=
	//  ParameterDeclaration) ")")? ("when" guard=GuardExpression)? ("provides"
	//  providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
	//  ProvidedCapability)*)? ("precondition" (":" precondExpr=Expression ";"|precondExpr=
	//  BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|postcondExpr=
	//  BlockExpression))? "{" ("default" "properties" defaultProperties=PropertySet)? input=
	//  BuilderInput? ("output" "{" output=PathGroup "}")? funcExpr=
	//  BlockExpressionWithoutBrackets? "}"; 
	//	
	//        
	//	     
	//	    
	//        
	//  	    
	////	(cached ?= "cached")?
	public BuilderElements getBuilderAccess() {
		return (pBuilder != null) ? pBuilder : (pBuilder = new BuilderElements());
	}
	
	public ParserRule getBuilderRule() {
		return getBuilderAccess().getRule();
	}

	//ParameterList returns be::BParameterList:
	//  {be::BParameterList} parameters+=FirstParameter ("," parameters+=FirstParameter)*;
	public ParameterListElements getParameterListAccess() {
		return (pParameterList != null) ? pParameterList : (pParameterList = new ParameterListElements());
	}
	
	public ParserRule getParameterListRule() {
		return getParameterListAccess().getRule();
	}

	//FirstParameter returns be::BParameter:
	//  ClosureParameter|Parameter;
	public FirstParameterElements getFirstParameterAccess() {
		return (pFirstParameter != null) ? pFirstParameter : (pFirstParameter = new FirstParameterElements());
	}
	
	public ParserRule getFirstParameterRule() {
		return getFirstParameterAccess().getRule();
	}

	//Parameter returns be::BParameter:
	//  {be::BParameter} expr=Expression;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//ClosureParameter returns be::BParameter:
	//  {be::BParameter} expr=ClosureExpression;
	public ClosureParameterElements getClosureParameterAccess() {
		return (pClosureParameter != null) ? pClosureParameter : (pClosureParameter = new ClosureParameterElements());
	}
	
	public ParserRule getClosureParameterRule() {
		return getClosureParameterAccess().getRule();
	}

	//ParameterDeclaration returns be::BParameterDeclaration:
	//  {be::BParameterDeclaration} (type=TypeRef? name=ID);
	public ParameterDeclarationElements getParameterDeclarationAccess() {
		return (pParameterDeclaration != null) ? pParameterDeclaration : (pParameterDeclaration = new ParameterDeclarationElements());
	}
	
	public ParserRule getParameterDeclarationRule() {
		return getParameterDeclarationAccess().getRule();
	}

	//BuilderInput returns build::BuilderInput:
	//  {build::BuilderInput} "input" ("precondition" (":" precondExpr=Expression ";"|
	//  precondExpr=BlockExpression))? ("postcondition" (":" postcondExpr=Expression ";"|
	//  postcondExpr=BlockExpression))? "{" prerequisites+=Prerequisite+ "}";
	public BuilderInputElements getBuilderInputAccess() {
		return (pBuilderInput != null) ? pBuilderInput : (pBuilderInput = new BuilderInputElements());
	}
	
	public ParserRule getBuilderInputRule() {
		return getBuilderInputAccess().getRule();
	}

	//RepositoryConfiguration returns build::RepositoryConfiguration:
	//  RepositoryDeclaration|ResolutionStrategy;
	public RepositoryConfigurationElements getRepositoryConfigurationAccess() {
		return (pRepositoryConfiguration != null) ? pRepositoryConfiguration : (pRepositoryConfiguration = new RepositoryConfigurationElements());
	}
	
	public ParserRule getRepositoryConfigurationRule() {
		return getRepositoryConfigurationAccess().getRule();
	}

	//RepositoryDeclaration returns build::RepositoryDeclaration:
	//  {build::RepositoryDeclaration} documentation=DOCUMENTATION? (location=URI|
	//  "repository" resolverType=TypeRef) contextBlock=ContextBlock_Creation?;
	public RepositoryDeclarationElements getRepositoryDeclarationAccess() {
		return (pRepositoryDeclaration != null) ? pRepositoryDeclaration : (pRepositoryDeclaration = new RepositoryDeclarationElements());
	}
	
	public ParserRule getRepositoryDeclarationRule() {
		return getRepositoryDeclarationAccess().getRule();
	}

	//ResolutionStrategy returns build::ResolutionStrategy:
	//  ResolutionStrategyFirst|ResolutionStrategyBest;
	public ResolutionStrategyElements getResolutionStrategyAccess() {
		return (pResolutionStrategy != null) ? pResolutionStrategy : (pResolutionStrategy = new ResolutionStrategyElements());
	}
	
	public ParserRule getResolutionStrategyRule() {
		return getResolutionStrategyAccess().getRule();
	}

	//ResolutionStrategyFirst returns build::ResolutionStrategyFirst:
	//  {build::ResolutionStrategyFirst} "select-first" "{" repositories+=
	//  RepositoryConfiguration* "}";
	public ResolutionStrategyFirstElements getResolutionStrategyFirstAccess() {
		return (pResolutionStrategyFirst != null) ? pResolutionStrategyFirst : (pResolutionStrategyFirst = new ResolutionStrategyFirstElements());
	}
	
	public ParserRule getResolutionStrategyFirstRule() {
		return getResolutionStrategyFirstAccess().getRule();
	}

	//ResolutionStrategyBest returns build::ResolutionStrategyBest:
	//  {build::ResolutionStrategyBest} "select-best" "{" repositories+=
	//  RepositoryConfiguration* "}";
	public ResolutionStrategyBestElements getResolutionStrategyBestAccess() {
		return (pResolutionStrategyBest != null) ? pResolutionStrategyBest : (pResolutionStrategyBest = new ResolutionStrategyBestElements());
	}
	
	public ParserRule getResolutionStrategyBestRule() {
		return getResolutionStrategyBestAccess().getRule();
	}

	//ContainerConfiguration returns build::ContainerConfiguration:
	//  {build::ContainerConfiguration} documentation=DOCUMENTATION? "container" name=ID
	//  "agent" agentType=TypeRef contextBlock=ContextBlock_Creation?;
	public ContainerConfigurationElements getContainerConfigurationAccess() {
		return (pContainerConfiguration != null) ? pContainerConfiguration : (pContainerConfiguration = new ContainerConfigurationElements());
	}
	
	public ParserRule getContainerConfigurationRule() {
		return getContainerConfigurationAccess().getRule();
	}

	//URI returns build::URI:
	//  STRING;
	public URIElements getURIAccess() {
		return (pURI != null) ? pURI : (pURI = new URIElements());
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}

	//Concern_Named returns be::BConcern:
	//  {be::BConcern} documentation=DOCUMENTATION? "concern" name=ID ("extends"
	//  superConcerns+=[be::BConcern] ("," superConcerns+=[be::BConcern])*)? "{" (
	//  "properties" propertySets+=PropertySet|functions+=Function|contexts+=
	//  BuildConcernContext)* "}";
	public Concern_NamedElements getConcern_NamedAccess() {
		return (pConcern_Named != null) ? pConcern_Named : (pConcern_Named = new Concern_NamedElements());
	}
	
	public ParserRule getConcern_NamedRule() {
		return getConcern_NamedAccess().getRule();
	}

	//Concern_Anonymous returns be::BConcern:
	//  {be::BConcern} ("extends" superConcerns+=[be::BConcern] ("," superConcerns+=[be::
	//  BConcern])*)? "{" ("properties" propertySets+=PropertySet|functions+=Function|
	//  contexts+=BuildConcernContext)* "}";
	public Concern_AnonymousElements getConcern_AnonymousAccess() {
		return (pConcern_Anonymous != null) ? pConcern_Anonymous : (pConcern_Anonymous = new Concern_AnonymousElements());
	}
	
	public ParserRule getConcern_AnonymousRule() {
		return getConcern_AnonymousAccess().getRule();
	}

	//Function returns be::B3Function:
	//  {be::B3Function} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
	//  ExecutionMode? final?="final"? "function" returnType=TypeRef? name=ID ("(" (parameters
	//  +=ParameterDeclaration ("," parameters+=ParameterDeclaration)* ("," varArgs?="..."
	//  parameters+=ParameterDeclaration)?|varArgs?="..." parameters+=
	//  ParameterDeclaration)? ")")? ("when" guard=GuardExpression)? (":" funcExpr=Expression
	//  ";"|funcExpr=BlockExpression); 
	//
	//        
	//	    
	//   	    
	//        	   	
	//   	    
	//   	
	//   	    
	//   	 
	////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
	public FunctionElements getFunctionAccess() {
		return (pFunction != null) ? pFunction : (pFunction = new FunctionElements());
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//GuardExpression returns be::BGuardExpression:
	//  {be::BGuardExpression} (":" guardExpr=Expression ";")|guardExpr=BlockExpression; 
	//	
	//        
	//	                
	//	
	////TypeParamDeclaration 
	////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
	////	;
	//		
	/// * EXPRESSIONS * /
	public GuardExpressionElements getGuardExpressionAccess() {
		return (pGuardExpression != null) ? pGuardExpression : (pGuardExpression = new GuardExpressionElements());
	}
	
	public ParserRule getGuardExpressionRule() {
		return getGuardExpressionAccess().getRule();
	}

	//AssignmentOperator returns ecore::EString:
	//  "="|"+="|"-="|"*="|"/="|"%="; 
	////TypeParamDeclaration 
	////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
	////	;
	//		
	/// * EXPRESSIONS * / 
	// 
	//	              	        
	//// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
	////	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>="
	public AssignmentOperatorElements getAssignmentOperatorAccess() {
		return (pAssignmentOperator != null) ? pAssignmentOperator : (pAssignmentOperator = new AssignmentOperatorElements());
	}
	
	public ParserRule getAssignmentOperatorRule() {
		return getAssignmentOperatorAccess().getRule();
	}

	//RelationalOperator returns ecore::EString:
	//  "~="|"=="|"==="|"!="|"!=="|">="|"<="|">"|"<"; 
	//	
	// 
	//	                  
	//	              
	//	
	//
	//// All expressions, including variable and value definitions. Note: order of rules is significant.
	public RelationalOperatorElements getRelationalOperatorAccess() {
		return (pRelationalOperator != null) ? pRelationalOperator : (pRelationalOperator = new RelationalOperatorElements());
	}
	
	public ParserRule getRelationalOperatorRule() {
		return getRelationalOperatorAccess().getRule();
	}

	//TopLevelExpression returns be::BExpression:
	//  VarDeclaration|ValDeclaration|AssignmentExpression; 
	//
	//// All expressions, including variable and value definitions. Note: order of rules is significant.
	//     
	//	   
	//	  
	//	   
	//	
	//
	//// All expressions except variable and value definitions
	public TopLevelExpressionElements getTopLevelExpressionAccess() {
		return (pTopLevelExpression != null) ? pTopLevelExpression : (pTopLevelExpression = new TopLevelExpressionElements());
	}
	
	public ParserRule getTopLevelExpressionRule() {
		return getTopLevelExpressionAccess().getRule();
	}

	//Expression returns be::BExpression:
	//  AssignmentExpression; 
	//
	//// All expressions except variable and value definitions
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//AssignmentExpression returns be::BExpression:
	//  CachedExpression ({be::BAssignmentExpression.leftExpr=current} functionName=
	//  AssignmentOperator rightExpr=AssignmentExpression)?;
	public AssignmentExpressionElements getAssignmentExpressionAccess() {
		return (pAssignmentExpression != null) ? pAssignmentExpression : (pAssignmentExpression = new AssignmentExpressionElements());
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}

	//VarDeclaration returns be::BExpression:
	//  {be::BDefValue} final?="final"? (("var"|type=TypeRef) name=ID) ("=" valueExpr=
	//  Expression)?;
	public VarDeclarationElements getVarDeclarationAccess() {
		return (pVarDeclaration != null) ? pVarDeclaration : (pVarDeclaration = new VarDeclarationElements());
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}

	//ValDeclaration returns be::BExpression:
	//  {be::BDefValue} final?="final"? immutable?="val" type=TypeRef? name=ID "=" valueExpr=
	//  Expression; 
	//
	//        
	//	     
	//	         
	//	      
	//	
	//
	//// TODO: typereference is simplified to only the name of a java type - for model imports
	//// the model is imported with name == namespace, and types in the model are referenced after
	//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
	//// referenced as mymodel::mytype
	//// There is more work required to link a reference to such a type and it is therefore deferred
	//// until we are up on Xtext 0.8 with better scoping and linking.
	//// For now, this is just proof of concept.
	////
	public ValDeclarationElements getValDeclarationAccess() {
		return (pValDeclaration != null) ? pValDeclaration : (pValDeclaration = new ValDeclarationElements());
	}
	
	public ParserRule getValDeclarationRule() {
		return getValDeclarationAccess().getRule();
	}

	//TypeRef returns be::IType:
	//  ClosureTypeRef|SimpleTypeRef; 
	//
	//// TODO: typereference is simplified to only the name of a java type - for model imports
	//// the model is imported with name == namespace, and types in the model are referenced after
	//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
	//// referenced as mymodel::mytype
	//// There is more work required to link a reference to such a type and it is therefore deferred
	//// until we are up on Xtext 0.8 with better scoping and linking.
	//// For now, this is just proof of concept.
	////
	public TypeRefElements getTypeRefAccess() {
		return (pTypeRef != null) ? pTypeRef : (pTypeRef = new TypeRefElements());
	}
	
	public ParserRule getTypeRefRule() {
		return getTypeRefAccess().getRule();
	}

	//SimpleTypeRef returns be::IType:
	//  {be::B3ParameterizedType} rawType=[be::B3JavaImport] ("<" actualArgumentsList+=[be
	//  ::B3JavaImport] ("," actualArgumentsList+=[be::B3JavaImport])* ">")?;  
	//	
	//         
	//	     
	//		                  
	////		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
	//	 
	//	
	//
	//// ClosureTypeRef declares parameters and return type	
	//// TODO: use TypeRef instead of direct reference to imported class
	public SimpleTypeRefElements getSimpleTypeRefAccess() {
		return (pSimpleTypeRef != null) ? pSimpleTypeRef : (pSimpleTypeRef = new SimpleTypeRefElements());
	}
	
	public ParserRule getSimpleTypeRefRule() {
		return getSimpleTypeRefAccess().getRule();
	}

	//ClosureTypeRef returns be::IType:
	//  {be::B3FunctionType} ("(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[
	//  be::B3JavaImport])* ("," varArgs?="..." parameterTypes+=[be::B3JavaImport])?|
	//  varArgs?="..." parameterTypes+=[be::B3JavaImport])? ")" "=>" returnType=[be::
	//  B3JavaImport]); 
	//	
	//
	//// ClosureTypeRef declares parameters and return type	
	//// TODO: use TypeRef instead of direct reference to imported class
	//         
	//	
	//		                     
	//			                
	//		 	                    
	//		 
	//	              
	//	
	//
	//// TODO: TypeParam's and Wildcard refs currently unused. Support should be added
	////
	public ClosureTypeRefElements getClosureTypeRefAccess() {
		return (pClosureTypeRef != null) ? pClosureTypeRef : (pClosureTypeRef = new ClosureTypeRefElements());
	}
	
	public ParserRule getClosureTypeRefRule() {
		return getClosureTypeRefAccess().getRule();
	}

	//TypeParam returns be::IType:
	//  TypeRefParam|WildcardRefParam; 
	//
	//// TODO: TypeParam's and Wildcard refs currently unused. Support should be added
	////
	public TypeParamElements getTypeParamAccess() {
		return (pTypeParam != null) ? pTypeParam : (pTypeParam = new TypeParamElements());
	}
	
	public ParserRule getTypeParamRule() {
		return getTypeParamAccess().getRule();
	}

	//TypeRefParam returns be::IType:
	//  TypeRef;
	public TypeRefParamElements getTypeRefParamAccess() {
		return (pTypeRefParam != null) ? pTypeRefParam : (pTypeRefParam = new TypeRefParamElements());
	}
	
	public ParserRule getTypeRefParamRule() {
		return getTypeRefParamAccess().getRule();
	}

	//WildcardRefParam returns be::IType:
	//  {be::B3WildcardType} "?" ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=
	//  TypeRef)*|"super" lowerBoundsList+=TypeRef)?;
	public WildcardRefParamElements getWildcardRefParamAccess() {
		return (pWildcardRefParam != null) ? pWildcardRefParam : (pWildcardRefParam = new WildcardRefParamElements());
	}
	
	public ParserRule getWildcardRefParamRule() {
		return getWildcardRefParamAccess().getRule();
	}

	//CachedExpression returns be::BExpression:
	//  {be::BCachedExpression} "cached" expr=OrExpression|OrExpression;
	public CachedExpressionElements getCachedExpressionAccess() {
		return (pCachedExpression != null) ? pCachedExpression : (pCachedExpression = new CachedExpressionElements());
	}
	
	public ParserRule getCachedExpressionRule() {
		return getCachedExpressionAccess().getRule();
	}

	//OrExpression returns be::BExpression:
	//  AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//AndExpression returns be::BExpression:
	//  RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
	//  RelationalExpression)*; 
	//	
	//      
	//	      
	//	
	//
	//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language with a different grammar).
	//// BitwiseExpression returns be::BExpression :
	//// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//RelationalExpression returns be::BExpression:
	//  InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
	//  RelationalOperator rightExpr=InstanceOfExpression)*; 
	//
	//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language with a different grammar).
	//// BitwiseExpression returns be::BExpression :
	//// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//InstanceOfExpression returns be::BExpression:
	//  AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
	//  "instanceof" rightExpr=LiteralType)*; 
	//
	//      
	//	        
	//	
	//
	//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language with a different grammar).
	//// ShiftExpression returns be::BExpression:
	//// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
	public InstanceOfExpressionElements getInstanceOfExpressionAccess() {
		return (pInstanceOfExpression != null) ? pInstanceOfExpression : (pInstanceOfExpression = new InstanceOfExpressionElements());
	}
	
	public ParserRule getInstanceOfExpressionRule() {
		return getInstanceOfExpressionAccess().getRule();
	}

	//AdditiveExpression returns be::BExpression:
	//  MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
	//  ( "+" | "-" ) rightExpr=MultiplicativeExpression)*; 
	//
	//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language with a different grammar).
	//// ShiftExpression returns be::BExpression:
	//// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//MultiplicativeExpression returns be::BExpression:
	//  SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" |
	//  "%" ) rightExpr=SetExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return (pMultiplicativeExpression != null) ? pMultiplicativeExpression : (pMultiplicativeExpression = new MultiplicativeExpressionElements());
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	//SetExpression returns be::BExpression:
	//  UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
	//  ".." rightExpr=UnaryOrInfixExpression)*;
	public SetExpressionElements getSetExpressionAccess() {
		return (pSetExpression != null) ? pSetExpression : (pSetExpression = new SetExpressionElements());
	}
	
	public ParserRule getSetExpressionRule() {
		return getSetExpressionAccess().getRule();
	}

	//UnaryOrInfixExpression returns be::BExpression:
	//  PostopExpression|UnaryExpression|PreopExpression; 
	//
	//    
	//	   
	//	  
	//	  
	//	 
	//	
	//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language with a different grammar).
	//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
	//// UnaryExpression returns be::BExpression:
	////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
	public UnaryOrInfixExpressionElements getUnaryOrInfixExpressionAccess() {
		return (pUnaryOrInfixExpression != null) ? pUnaryOrInfixExpression : (pUnaryOrInfixExpression = new UnaryOrInfixExpressionElements());
	}
	
	public ParserRule getUnaryOrInfixExpressionRule() {
		return getUnaryOrInfixExpressionAccess().getRule();
	}

	//UnaryExpression returns be::BExpression:
	//  {be::BUnaryOpExpression} functionName=( "!" | "-" ) expr=InfixExpression;  
	//	
	//// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language with a different grammar).
	//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
	//// UnaryExpression returns be::BExpression:
	////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//PreopExpression returns be::BExpression:
	//  {be::BUnaryPreOpExpression} functionName=( "++" | "--" ) expr=InfixExpression;
	public PreopExpressionElements getPreopExpressionAccess() {
		return (pPreopExpression != null) ? pPreopExpression : (pPreopExpression = new PreopExpressionElements());
	}
	
	public ParserRule getPreopExpressionRule() {
		return getPreopExpressionAccess().getRule();
	}

	//PostopExpression returns be::BExpression:
	//  InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++"
	//  ))?;
	public PostopExpressionElements getPostopExpressionAccess() {
		return (pPostopExpression != null) ? pPostopExpression : (pPostopExpression = new PostopExpressionElements());
	}
	
	public ParserRule getPostopExpressionRule() {
		return getPostopExpressionAccess().getRule();
	}

	//InfixExpression returns be::BExpression:
	//  CallExpression ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=
	//  ParameterList? ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|
	//  {be::BFeatureExpression.objExpr=current} "." featureName=ID)*;
	public InfixExpressionElements getInfixExpressionAccess() {
		return (pInfixExpression != null) ? pInfixExpression : (pInfixExpression = new InfixExpressionElements());
	}
	
	public ParserRule getInfixExpressionRule() {
		return getInfixExpressionAccess().getRule();
	}

	//CallExpression returns be::BExpression:
	//  PrimaryExpression ({be::BCallExpression.funcExpr=current} "(" parameterList=
	//  ParameterList? ")")*;
	public CallExpressionElements getCallExpressionAccess() {
		return (pCallExpression != null) ? pCallExpression : (pCallExpression = new CallExpressionElements());
	}
	
	public ParserRule getCallExpressionRule() {
		return getCallExpressionAccess().getRule();
	}

	//PrimaryExpression returns be::BExpression:
	//  FeatureCall|ConstructorCallExpression|VariableValue|Literal|PropertyValue|
	//  KeywordVariables|ParanthesizedExpression|IfExpression|BlockExpression|
	//  SwitchExpression|ThrowExpression|TryCatchExpression|WildcardExpression; 
	//		
	//    
	//	  
	//	  
	//	  
	//	   
	//	  
	//	  
	//	  
	//	  
	//	  
	//	  
	//	  
	//	  
	//	  
	////	| WithExpression
	//	 
	//	
	////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
	////WithClauseExpression returns Expression : {WithClauseExpression} 
	////	withclause=WithClause expr = BlockExpression 
	////	;
	////WithContextExpression returns Expresion : {WithContextExpression } 
	////	"with" "context" context = Expression expr = BlockExpression
	////	;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//WildcardExpression returns be::BExpression:
	//  {be::BLiteralAny} "_"; 
	//	
	////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
	////WithClauseExpression returns Expression : {WithClauseExpression} 
	////	withclause=WithClause expr = BlockExpression 
	////	;
	////WithContextExpression returns Expresion : {WithContextExpression } 
	////	"with" "context" context = Expression expr = BlockExpression
	////	;
	public WildcardExpressionElements getWildcardExpressionAccess() {
		return (pWildcardExpression != null) ? pWildcardExpression : (pWildcardExpression = new WildcardExpressionElements());
	}
	
	public ParserRule getWildcardExpressionRule() {
		return getWildcardExpressionAccess().getRule();
	}

	//ThrowExpression returns be::BExpression:
	//  {be::BThrowExpression} "throw" expr=Expression;
	public ThrowExpressionElements getThrowExpressionAccess() {
		return (pThrowExpression != null) ? pThrowExpression : (pThrowExpression = new ThrowExpressionElements());
	}
	
	public ParserRule getThrowExpressionRule() {
		return getThrowExpressionAccess().getRule();
	}

	//TryCatchExpression returns be::BExpression:
	//  {be::BTryExpression} "try" tryExpr=Expression catchBlocks+=CatchBlock* ("finally"
	//  finallyExpr=Expression)? "endtry";
	public TryCatchExpressionElements getTryCatchExpressionAccess() {
		return (pTryCatchExpression != null) ? pTryCatchExpression : (pTryCatchExpression = new TryCatchExpressionElements());
	}
	
	public ParserRule getTryCatchExpressionRule() {
		return getTryCatchExpressionAccess().getRule();
	}

	//CatchBlock returns be::BCatch:
	//  {be::BCatch} "catch" exceptionType=TypeRef varname=ID ":" catchExpr=Expression;
	public CatchBlockElements getCatchBlockAccess() {
		return (pCatchBlock != null) ? pCatchBlock : (pCatchBlock = new CatchBlockElements());
	}
	
	public ParserRule getCatchBlockRule() {
		return getCatchBlockAccess().getRule();
	}

	//SwitchExpression returns be::BExpression:
	//  {be::BSwitchExpression} "switch" switchExpression=Expression? caseList+=Case+
	//  "endswitch";
	public SwitchExpressionElements getSwitchExpressionAccess() {
		return (pSwitchExpression != null) ? pSwitchExpression : (pSwitchExpression = new SwitchExpressionElements());
	}
	
	public ParserRule getSwitchExpressionRule() {
		return getSwitchExpressionAccess().getRule();
	}

	//Case returns be::BCase:
	//  {be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression;
	public CaseElements getCaseAccess() {
		return (pCase != null) ? pCase : (pCase = new CaseElements());
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}

	//BlockExpression returns be::BExpression:
	//  {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}";
	public BlockExpressionElements getBlockExpressionAccess() {
		return (pBlockExpression != null) ? pBlockExpression : (pBlockExpression = new BlockExpressionElements());
	}
	
	public ParserRule getBlockExpressionRule() {
		return getBlockExpressionAccess().getRule();
	}

	//IfExpression returns be::BExpression:
	//  {be::BIfExpression} "if" conditionExpr=Expression "then" thenExpr=Expression (
	//  elseExpr=ElseIfExpression|"else" elseExpr=Expression)? "endif";
	public IfExpressionElements getIfExpressionAccess() {
		return (pIfExpression != null) ? pIfExpression : (pIfExpression = new IfExpressionElements());
	}
	
	public ParserRule getIfExpressionRule() {
		return getIfExpressionAccess().getRule();
	}

	//ElseIfExpression returns be::BExpression:
	//  {be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression (
	//  elseExpr=ElseIfExpression|"else" elseExpr=Expression)?;
	public ElseIfExpressionElements getElseIfExpressionAccess() {
		return (pElseIfExpression != null) ? pElseIfExpression : (pElseIfExpression = new ElseIfExpressionElements());
	}
	
	public ParserRule getElseIfExpressionRule() {
		return getElseIfExpressionAccess().getRule();
	}

	//PropertyValue returns be::BExpression:
	//  {be::BVariableExpression} name=PID;
	public PropertyValueElements getPropertyValueAccess() {
		return (pPropertyValue != null) ? pPropertyValue : (pPropertyValue = new PropertyValueElements());
	}
	
	public ParserRule getPropertyValueRule() {
		return getPropertyValueAccess().getRule();
	}

	//VariableValue returns be::BExpression:
	//  {be::BVariableExpression} name=ID;
	public VariableValueElements getVariableValueAccess() {
		return (pVariableValue != null) ? pVariableValue : (pVariableValue = new VariableValueElements());
	}
	
	public ParserRule getVariableValueRule() {
		return getVariableValueAccess().getRule();
	}

	//KeywordVariables returns be::BExpression:
	//  {be::BVariableExpression} name=( "input" | "output" | "properties" | "unit" );
	public KeywordVariablesElements getKeywordVariablesAccess() {
		return (pKeywordVariables != null) ? pKeywordVariables : (pKeywordVariables = new KeywordVariablesElements());
	}
	
	public ParserRule getKeywordVariablesRule() {
		return getKeywordVariablesAccess().getRule();
	}

	//FeatureCall returns be::BExpression:
	//  OperationCall;
	public FeatureCallElements getFeatureCallAccess() {
		return (pFeatureCall != null) ? pFeatureCall : (pFeatureCall = new FeatureCallElements());
	}
	
	public ParserRule getFeatureCallRule() {
		return getFeatureCallAccess().getRule();
	}

	//OperationCall returns be::BCallExpression:
	//  {be::BCallExpression} name=( ID | PID ) "(" parameterList=ParameterList? ")";
	public OperationCallElements getOperationCallAccess() {
		return (pOperationCall != null) ? pOperationCall : (pOperationCall = new OperationCallElements());
	}
	
	public ParserRule getOperationCallRule() {
		return getOperationCallAccess().getRule();
	}

	//ConstructorCallExpression returns be::BExpression:
	//  {be::BCreateExpression} "new" typeExpr=LiteralType ("(" parameterList=ParameterList?
	//  ")")? ("as" alias=ID)? contextBlock=ContextBlock_Creation?; 
	//
	//         
	//	   
	//	    
	//	   
	//	    
	//	
	//
	//// Used in a concern to describe pointcuts/advice for units and/or builders
	public ConstructorCallExpressionElements getConstructorCallExpressionAccess() {
		return (pConstructorCallExpression != null) ? pConstructorCallExpression : (pConstructorCallExpression = new ConstructorCallExpressionElements());
	}
	
	public ParserRule getConstructorCallExpressionRule() {
		return getConstructorCallExpressionAccess().getRule();
	}

	//BuildConcernContext returns be::BConcernContext:
	//  UnitConcernContext|BuilderConcernContext; 
	//
	//// Used in a concern to describe pointcuts/advice for units and/or builders
	//       
	//	  
	//	  
	//	
	//	
	//// Advice for units consists of Builders, and advice for Builders
	public BuildConcernContextElements getBuildConcernContextAccess() {
		return (pBuildConcernContext != null) ? pBuildConcernContext : (pBuildConcernContext = new BuildConcernContextElements());
	}
	
	public ParserRule getBuildConcernContextRule() {
		return getBuildConcernContextAccess().getRule();
	}

	//UnitConcernContext returns build::UnitConcernContext:
	//  {build::UnitConcernContext} "context" "unit" query=UnitOrExpression "{" (functions+=
	//  Builder|builderContexts+=BuilderConcernContext)* "}"; 
	//	
	//// Advice for units consists of Builders, and advice for Builders
	//        
	//	        
	//	
	//	      
	//	      
	//	
	//	
	//	
	//	
	//// Advice for Builders
	public UnitConcernContextElements getUnitConcernContextAccess() {
		return (pUnitConcernContext != null) ? pUnitConcernContext : (pUnitConcernContext = new UnitConcernContextElements());
	}
	
	public ParserRule getUnitConcernContextRule() {
		return getUnitConcernContextAccess().getRule();
	}

	//BuilderConcernContext returns build::BuilderConcernContext:
	//  {build::BuilderConcernContext} "context" "builder" query=BuilderOrExpression "{" ("+"
	//  "input" inputAdditions+=Prerequisite|"-" inputRemovals+=InputPredicate ";")* ("+"
	//  "output" outputAdditions+=PathVector|"-" "output" outputRemovals+=OutputPredicate
	//  ";")* funcExpr=BlockExpression? "}"; 
	//	
	//// Advice for Builders	
	//        
	//	         
	//	             
	//		          
	//		
	//		          
	//		            
	//		// TODO: annotations
	//		       // replaces the builder's funcExpression TODO: around? etc?
	public BuilderConcernContextElements getBuilderConcernContextAccess() {
		return (pBuilderConcernContext != null) ? pBuilderConcernContext : (pBuilderConcernContext = new BuilderConcernContextElements());
	}
	
	public ParserRule getBuilderConcernContextRule() {
		return getBuilderConcernContextAccess().getRule();
	}

	//UnitOrExpression returns be::BExpression:
	//  UnitAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=
	//  UnitAndExpression)*;
	public UnitOrExpressionElements getUnitOrExpressionAccess() {
		return (pUnitOrExpression != null) ? pUnitOrExpression : (pUnitOrExpression = new UnitOrExpressionElements());
	}
	
	public ParserRule getUnitOrExpressionRule() {
		return getUnitOrExpressionAccess().getRule();
	}

	//UnitAndExpression returns be::BExpression:
	//  UnitNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
	//  UnitNotOrPrimaryExpression)*;
	public UnitAndExpressionElements getUnitAndExpressionAccess() {
		return (pUnitAndExpression != null) ? pUnitAndExpression : (pUnitAndExpression = new UnitAndExpressionElements());
	}
	
	public ParserRule getUnitAndExpressionRule() {
		return getUnitAndExpressionAccess().getRule();
	}

	//UnitNotOrPrimaryExpression returns be::BExpression:
	//  UnitNotExpression|UnitPrimaryExpression;
	public UnitNotOrPrimaryExpressionElements getUnitNotOrPrimaryExpressionAccess() {
		return (pUnitNotOrPrimaryExpression != null) ? pUnitNotOrPrimaryExpression : (pUnitNotOrPrimaryExpression = new UnitNotOrPrimaryExpressionElements());
	}
	
	public ParserRule getUnitNotOrPrimaryExpressionRule() {
		return getUnitNotOrPrimaryExpressionAccess().getRule();
	}

	//UnitNotExpression returns be::BExpression:
	//  {be::BUnaryOpExpression} functionName="!" expr=UnitPrimaryExpression;
	public UnitNotExpressionElements getUnitNotExpressionAccess() {
		return (pUnitNotExpression != null) ? pUnitNotExpression : (pUnitNotExpression = new UnitNotExpressionElements());
	}
	
	public ParserRule getUnitNotExpressionRule() {
		return getUnitNotExpressionAccess().getRule();
	}

	//UnitPrimaryExpression returns be::BExpression:
	//  RequiresPredicate|ImplementsPredcicate|ProvidesPredicate|UnitNamePredicate|
	//  GroupedUnitPrimaryExpression;
	public UnitPrimaryExpressionElements getUnitPrimaryExpressionAccess() {
		return (pUnitPrimaryExpression != null) ? pUnitPrimaryExpression : (pUnitPrimaryExpression = new UnitPrimaryExpressionElements());
	}
	
	public ParserRule getUnitPrimaryExpressionRule() {
		return getUnitPrimaryExpressionAccess().getRule();
	}

	//GroupedUnitPrimaryExpression returns be::BExpression:
	//  "(" UnitOrExpression ")";
	public GroupedUnitPrimaryExpressionElements getGroupedUnitPrimaryExpressionAccess() {
		return (pGroupedUnitPrimaryExpression != null) ? pGroupedUnitPrimaryExpression : (pGroupedUnitPrimaryExpression = new GroupedUnitPrimaryExpressionElements());
	}
	
	public ParserRule getGroupedUnitPrimaryExpressionRule() {
		return getGroupedUnitPrimaryExpressionAccess().getRule();
	}

	//RequiresPredicate returns be::BExpression:
	//  {build::RequiresPredicate} meta?="meta"? "requires" capabilityPredicate=
	//  CapabilityPredicate;
	public RequiresPredicateElements getRequiresPredicateAccess() {
		return (pRequiresPredicate != null) ? pRequiresPredicate : (pRequiresPredicate = new RequiresPredicateElements());
	}
	
	public ParserRule getRequiresPredicateRule() {
		return getRequiresPredicateAccess().getRule();
	}

	//ImplementsPredcicate returns be::BExpression:
	//  {build::ImplementsPredicate} "implements" type=TypeRef;
	public ImplementsPredcicateElements getImplementsPredcicateAccess() {
		return (pImplementsPredcicate != null) ? pImplementsPredcicate : (pImplementsPredcicate = new ImplementsPredcicateElements());
	}
	
	public ParserRule getImplementsPredcicateRule() {
		return getImplementsPredcicateAccess().getRule();
	}

	//ProvidesPredicate returns be::BExpression:
	//  {build::ProvidesPredicate} "provides" capabilityPredicate=CapabilityPredicate;
	public ProvidesPredicateElements getProvidesPredicateAccess() {
		return (pProvidesPredicate != null) ? pProvidesPredicate : (pProvidesPredicate = new ProvidesPredicateElements());
	}
	
	public ParserRule getProvidesPredicateRule() {
		return getProvidesPredicateAccess().getRule();
	}

	//UnitNamePredicate returns build::CapabilityPredicate:
	//  {build::UnitNamePredicate} namePredicate=NamePredicate ("/" versionRange=
	//  VersionRangeLiteral)?;
	public UnitNamePredicateElements getUnitNamePredicateAccess() {
		return (pUnitNamePredicate != null) ? pUnitNamePredicate : (pUnitNamePredicate = new UnitNamePredicateElements());
	}
	
	public ParserRule getUnitNamePredicateRule() {
		return getUnitNamePredicateAccess().getRule();
	}

	//BuilderNamePredicate returns build::BuilderNamePredicate:
	//  {build::BuilderNamePredicate} namePredicate=NamePredicate;
	public BuilderNamePredicateElements getBuilderNamePredicateAccess() {
		return (pBuilderNamePredicate != null) ? pBuilderNamePredicate : (pBuilderNamePredicate = new BuilderNamePredicateElements());
	}
	
	public ParserRule getBuilderNamePredicateRule() {
		return getBuilderNamePredicateAccess().getRule();
	}

	//InputPredicate returns build::InputPredicate:
	//  {build::InputPredicate} "input" (capabilityPredicate=CapabilityPredicate|
	//  capabilityPredicate=UnitNamePredicate|"unit"?) "#" builderPredicate=NamePredicate;
	public InputPredicateElements getInputPredicateAccess() {
		return (pInputPredicate != null) ? pInputPredicate : (pInputPredicate = new InputPredicateElements());
	}
	
	public ParserRule getInputPredicateRule() {
		return getInputPredicateAccess().getRule();
	}

	//OutputPredicate returns build::OutputPredicate:
	//  {build::OutputPredicate} pathVector=BasePathPredicate|pathVector=PathPredicate|
	//  pathPattern=RegexpLiteral;
	public OutputPredicateElements getOutputPredicateAccess() {
		return (pOutputPredicate != null) ? pOutputPredicate : (pOutputPredicate = new OutputPredicateElements());
	}
	
	public ParserRule getOutputPredicateRule() {
		return getOutputPredicateAccess().getRule();
	}

	//BasePathPredicate returns build::PathVectorElement:
	//  {build::PathVectorElement} basePath=Path "[" paths+=Path ("," paths+=Path)* "]";
	public BasePathPredicateElements getBasePathPredicateAccess() {
		return (pBasePathPredicate != null) ? pBasePathPredicate : (pBasePathPredicate = new BasePathPredicateElements());
	}
	
	public ParserRule getBasePathPredicateRule() {
		return getBasePathPredicateAccess().getRule();
	}

	//PathPredicate returns build::PathVectorElement:
	//  {build::PathVectorElement} paths+=Path ("," paths+=Path)*;
	public PathPredicateElements getPathPredicateAccess() {
		return (pPathPredicate != null) ? pPathPredicate : (pPathPredicate = new PathPredicateElements());
	}
	
	public ParserRule getPathPredicateRule() {
		return getPathPredicateAccess().getRule();
	}

	//CapabilityPredicate returns build::CapabilityPredicate:
	//  {build::CapabilityPredicate} nameSpacePredicate=NamePredicate "/" namePredicate=
	//  NamePredicate ("/" versionRange=VersionRangeLiteral)?;
	public CapabilityPredicateElements getCapabilityPredicateAccess() {
		return (pCapabilityPredicate != null) ? pCapabilityPredicate : (pCapabilityPredicate = new CapabilityPredicateElements());
	}
	
	public ParserRule getCapabilityPredicateRule() {
		return getCapabilityPredicateAccess().getRule();
	}

	//NamePredicate returns build::NamePredicate:
	//  {build::NamePredicate} (name=EscapedQualifiedName|namePattern=RegexpLiteral|
	//  namePattern=WildcardExpression);
	public NamePredicateElements getNamePredicateAccess() {
		return (pNamePredicate != null) ? pNamePredicate : (pNamePredicate = new NamePredicateElements());
	}
	
	public ParserRule getNamePredicateRule() {
		return getNamePredicateAccess().getRule();
	}

	//BuilderOrExpression returns be::BExpression:
	//  BuilderAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=
	//  BuilderAndExpression)*;
	public BuilderOrExpressionElements getBuilderOrExpressionAccess() {
		return (pBuilderOrExpression != null) ? pBuilderOrExpression : (pBuilderOrExpression = new BuilderOrExpressionElements());
	}
	
	public ParserRule getBuilderOrExpressionRule() {
		return getBuilderOrExpressionAccess().getRule();
	}

	//BuilderAndExpression returns be::BExpression:
	//  BuilderNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr
	//  =BuilderNotOrPrimaryExpression)*;
	public BuilderAndExpressionElements getBuilderAndExpressionAccess() {
		return (pBuilderAndExpression != null) ? pBuilderAndExpression : (pBuilderAndExpression = new BuilderAndExpressionElements());
	}
	
	public ParserRule getBuilderAndExpressionRule() {
		return getBuilderAndExpressionAccess().getRule();
	}

	//BuilderNotOrPrimaryExpression returns be::BExpression:
	//  BuilderNotExpression|BuilderPrimaryExpression;
	public BuilderNotOrPrimaryExpressionElements getBuilderNotOrPrimaryExpressionAccess() {
		return (pBuilderNotOrPrimaryExpression != null) ? pBuilderNotOrPrimaryExpression : (pBuilderNotOrPrimaryExpression = new BuilderNotOrPrimaryExpressionElements());
	}
	
	public ParserRule getBuilderNotOrPrimaryExpressionRule() {
		return getBuilderNotOrPrimaryExpressionAccess().getRule();
	}

	//BuilderNotExpression returns be::BExpression:
	//  {be::BUnaryOpExpression} functionName="!" expr=BuilderPrimaryExpression;
	public BuilderNotExpressionElements getBuilderNotExpressionAccess() {
		return (pBuilderNotExpression != null) ? pBuilderNotExpression : (pBuilderNotExpression = new BuilderNotExpressionElements());
	}
	
	public ParserRule getBuilderNotExpressionRule() {
		return getBuilderNotExpressionAccess().getRule();
	}

	//BuilderPrimaryExpression returns be::BExpression:
	//  InputPredicate|ProvidesPredicate|BuilderNamePredicate|
	//  GroupedBuilderPrimaryExpression;
	public BuilderPrimaryExpressionElements getBuilderPrimaryExpressionAccess() {
		return (pBuilderPrimaryExpression != null) ? pBuilderPrimaryExpression : (pBuilderPrimaryExpression = new BuilderPrimaryExpressionElements());
	}
	
	public ParserRule getBuilderPrimaryExpressionRule() {
		return getBuilderPrimaryExpressionAccess().getRule();
	}

	//GroupedBuilderPrimaryExpression returns be::BExpression:
	//  "(" BuilderOrExpression ")";
	public GroupedBuilderPrimaryExpressionElements getGroupedBuilderPrimaryExpressionAccess() {
		return (pGroupedBuilderPrimaryExpression != null) ? pGroupedBuilderPrimaryExpression : (pGroupedBuilderPrimaryExpression = new GroupedBuilderPrimaryExpressionElements());
	}
	
	public ParserRule getGroupedBuilderPrimaryExpressionRule() {
		return getGroupedBuilderPrimaryExpressionAccess().getRule();
	}

	//ContextBlock returns be::BExpression:
	//  {be::BChainedExpression} "{" (expressions+=Function|expressions+=
	//  TopLevelExpression ";")* "}"; 
	//
	//
	//         
	//	      
	////		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
	//		     
	////		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
	public ContextBlockElements getContextBlockAccess() {
		return (pContextBlock != null) ? pContextBlock : (pContextBlock = new ContextBlockElements());
	}
	
	public ParserRule getContextBlockRule() {
		return getContextBlockAccess().getRule();
	}

	//ContextBlock_Creation returns be::BExpression:
	//  {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"; 
	//
	//         
	//	       
	//	
	//					
	////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
	////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = PropertySet_Named ;
	////FunctionDefinition returns be::BExpression : {be::BDefFunction} function = Function;
	////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
	public ContextBlock_CreationElements getContextBlock_CreationAccess() {
		return (pContextBlock_Creation != null) ? pContextBlock_Creation : (pContextBlock_Creation = new ContextBlock_CreationElements());
	}
	
	public ParserRule getContextBlock_CreationRule() {
		return getContextBlock_CreationAccess().getRule();
	}

	//Literal returns be::BExpression:
	//  ValueLiteral|RegexpLiteral|LiteralMap|LiteralList|LiteralFunction; 
	//					
	////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
	////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = PropertySet_Named ;
	////FunctionDefinition returns be::BExpression : {be::BDefFunction} function = Function;
	////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//LiteralList returns be::BExpression:
	//  {be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
	//  entries+=Expression)* "]"|{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">"
	//  "]";
	public LiteralListElements getLiteralListAccess() {
		return (pLiteralList != null) ? pLiteralList : (pLiteralList = new LiteralListElements());
	}
	
	public ParserRule getLiteralListRule() {
		return getLiteralListAccess().getRule();
	}

	//LiteralMap returns be::BExpression:
	//  {be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
	//  entries+=MapEntry ("," entries+=MapEntry)* "]"|{be::BLiteralMapExpression} "[" "<"
	//  keyType=TypeRef "," valueType=TypeRef ">" "]"; 
	//	
	//     
	//	                                
	//	                 
	//	
	//
	//// A lambda enclosed in { }
	public LiteralMapElements getLiteralMapAccess() {
		return (pLiteralMap != null) ? pLiteralMap : (pLiteralMap = new LiteralMapElements());
	}
	
	public ParserRule getLiteralMapRule() {
		return getLiteralMapAccess().getRule();
	}

	//LiteralFunction returns be::BExpression:
	//  "{" ClosureExpression "}"; 
	//
	//// A lambda enclosed in { }
	//      
	//	    
	//	
	//
	////LiteralFunction returns be::BExpression : {be::B3Function} 
	////	'{' ('<' returnType=TypeRef '>')?
	////	(
	////	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
	////		(',' varArgs?="..." parameters += ParameterDeclaration)?)
	////	| 	(    varArgs?="..." parameters += ParameterDeclaration)
	////	)? 
	////	'|' funcExpr=OneOrManyExpressions '}'
	////	;
	//
	//// A lambda (without delimiters)
	public LiteralFunctionElements getLiteralFunctionAccess() {
		return (pLiteralFunction != null) ? pLiteralFunction : (pLiteralFunction = new LiteralFunctionElements());
	}
	
	public ParserRule getLiteralFunctionRule() {
		return getLiteralFunctionAccess().getRule();
	}

	//ClosureExpression returns be::BExpression:
	//  {be::B3Function} ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (","
	//  parameters+=ParameterDeclaration)* ("," varArgs?="..." parameters+=
	//  ParameterDeclaration)?|varArgs?="..." parameters+=ParameterDeclaration)? "|"
	//  funcExpr=OneOrManyExpressions; 
	//
	////LiteralFunction returns be::BExpression : {be::B3Function} 
	////	'{' ('<' returnType=TypeRef '>')?
	////	(
	////	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
	////		(',' varArgs?="..." parameters += ParameterDeclaration)?)
	////	| 	(    varArgs?="..." parameters += ParameterDeclaration)
	////	)? 
	////	'|' funcExpr=OneOrManyExpressions '}'
	////	;
	//
	//// A lambda (without delimiters)
	public ClosureExpressionElements getClosureExpressionAccess() {
		return (pClosureExpression != null) ? pClosureExpression : (pClosureExpression = new ClosureExpressionElements());
	}
	
	public ParserRule getClosureExpressionRule() {
		return getClosureExpressionAccess().getRule();
	}

	//OneOrManyExpressions returns be::BExpression:
	//  BlockExpressionWithoutBrackets|Expression;
	public OneOrManyExpressionsElements getOneOrManyExpressionsAccess() {
		return (pOneOrManyExpressions != null) ? pOneOrManyExpressions : (pOneOrManyExpressions = new OneOrManyExpressionsElements());
	}
	
	public ParserRule getOneOrManyExpressionsRule() {
		return getOneOrManyExpressionsAccess().getRule();
	}

	//BlockExpressionWithoutBrackets returns be::BExpression:
	//  {be::BChainedExpression} (expressions+=TopLevelExpression ";")+;
	public BlockExpressionWithoutBracketsElements getBlockExpressionWithoutBracketsAccess() {
		return (pBlockExpressionWithoutBrackets != null) ? pBlockExpressionWithoutBrackets : (pBlockExpressionWithoutBrackets = new BlockExpressionWithoutBracketsElements());
	}
	
	public ParserRule getBlockExpressionWithoutBracketsRule() {
		return getBlockExpressionWithoutBracketsAccess().getRule();
	}

	//MapEntry returns be::BMapEntry:
	//  {be::BMapEntry} key=KeyLiteral ":" value=Expression;
	public MapEntryElements getMapEntryAccess() {
		return (pMapEntry != null) ? pMapEntry : (pMapEntry = new MapEntryElements());
	}
	
	public ParserRule getMapEntryRule() {
		return getMapEntryAccess().getRule();
	}

	//KeyLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=( ID | PID | STRING );
	public KeyLiteralElements getKeyLiteralAccess() {
		return (pKeyLiteral != null) ? pKeyLiteral : (pKeyLiteral = new KeyLiteralElements());
	}
	
	public ParserRule getKeyLiteralRule() {
		return getKeyLiteralAccess().getRule();
	}

	//LiteralType returns be::BExpression:
	//  {be::BLiteralType} type=TypeRef;
	public LiteralTypeElements getLiteralTypeAccess() {
		return (pLiteralType != null) ? pLiteralType : (pLiteralType = new LiteralTypeElements());
	}
	
	public ParserRule getLiteralTypeRule() {
		return getLiteralTypeAccess().getRule();
	}

	//ValueLiteral returns be::BExpression:
	//  BooleanLiteral|RealLiteral|IntegerLiteral|NullLiteral|StringLiteral|UnitLiteral; 
	//
	//     
	//	   
	//	     // SEE ISSUE 297089 - must be placed before IntegerLiteral
	//	    
	//	   
	//	  
	////	| QueryLiteral
	public ValueLiteralElements getValueLiteralAccess() {
		return (pValueLiteral != null) ? pValueLiteral : (pValueLiteral = new ValueLiteralElements());
	}
	
	public ParserRule getValueLiteralRule() {
		return getValueLiteralAccess().getRule();
	}

	//BooleanLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=BooleanValue;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//IntegerLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=IntValue;
	public IntegerLiteralElements getIntegerLiteralAccess() {
		return (pIntegerLiteral != null) ? pIntegerLiteral : (pIntegerLiteral = new IntegerLiteralElements());
	}
	
	public ParserRule getIntegerLiteralRule() {
		return getIntegerLiteralAccess().getRule();
	}

	//UnitLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value="unit";
	public UnitLiteralElements getUnitLiteralAccess() {
		return (pUnitLiteral != null) ? pUnitLiteral : (pUnitLiteral = new UnitLiteralElements());
	}
	
	public ParserRule getUnitLiteralRule() {
		return getUnitLiteralAccess().getRule();
	}

	//StringLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return (pStringLiteral != null) ? pStringLiteral : (pStringLiteral = new StringLiteralElements());
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//RealLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=RealValue;
	public RealLiteralElements getRealLiteralAccess() {
		return (pRealLiteral != null) ? pRealLiteral : (pRealLiteral = new RealLiteralElements());
	}
	
	public ParserRule getRealLiteralRule() {
		return getRealLiteralAccess().getRule();
	}

	//RegexpLiteral returns be::BExpression:
	//  {be::BRegularExpression} pattern=REGULAR_EXPR; 
	//	
	//        
	//	    
	//	
	//
	//// Note: NullLiteral has a java null value as its value
	public RegexpLiteralElements getRegexpLiteralAccess() {
		return (pRegexpLiteral != null) ? pRegexpLiteral : (pRegexpLiteral = new RegexpLiteralElements());
	}
	
	public ParserRule getRegexpLiteralRule() {
		return getRegexpLiteralAccess().getRule();
	}

	//NullLiteral returns be::BExpression:
	//  {be::BLiteralExpression} "null"; 
	//
	//// Note: NullLiteral has a java null value as its value
	//	         
	//	
	//	
	//
	////ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
	////SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
	//
	//// Has conversion rule
	public NullLiteralElements getNullLiteralAccess() {
		return (pNullLiteral != null) ? pNullLiteral : (pNullLiteral = new NullLiteralElements());
	}
	
	public ParserRule getNullLiteralRule() {
		return getNullLiteralAccess().getRule();
	}

	//BooleanValue returns ecore::EBooleanObject:
	//  "true"|"false"; 
	//
	////ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
	////SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
	//
	//// Has conversion rule
	//              
	//
	//// Has conversion rule
	public BooleanValueElements getBooleanValueAccess() {
		return (pBooleanValue != null) ? pBooleanValue : (pBooleanValue = new BooleanValueElements());
	}
	
	public ParserRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}

	//RealValue returns ecore::EDoubleObject:
	//  REAL; 
	//
	//// Has conversion rule
	//        
	//
	//// Has conversion rule that handles decimal, octal, and hexadecimal values with radix
	public RealValueElements getRealValueAccess() {
		return (pRealValue != null) ? pRealValue : (pRealValue = new RealValueElements());
	}
	
	public ParserRule getRealValueRule() {
		return getRealValueAccess().getRule();
	}

	//IntValue returns ecore::EIntegerObject:
	//  INT|HEX; 
	//
	//// Has conversion rule that handles decimal, octal, and hexadecimal values with radix
	public IntValueElements getIntValueAccess() {
		return (pIntValue != null) ? pIntValue : (pIntValue = new IntValueElements());
	}
	
	public ParserRule getIntValueRule() {
		return getIntValueAccess().getRule();
	}

	//ParanthesizedExpression returns be::BExpression:
	//  "(" Expression ")"; 
	//	
	//       
	//	    
	//		
	//
	//// Has conversion rule
	public ParanthesizedExpressionElements getParanthesizedExpressionAccess() {
		return (pParanthesizedExpression != null) ? pParanthesizedExpression : (pParanthesizedExpression = new ParanthesizedExpressionElements());
	}
	
	public ParserRule getParanthesizedExpressionRule() {
		return getParanthesizedExpressionAccess().getRule();
	}

	//VersionLiteral returns build::Version:
	//  STRING|AlfanumSym; 	
	//
	//// Has conversion rule
	//    
	//	    
	//	  
	//	
	//
	//// Has conversion rule
	public VersionLiteralElements getVersionLiteralAccess() {
		return (pVersionLiteral != null) ? pVersionLiteral : (pVersionLiteral = new VersionLiteralElements());
	}
	
	public ParserRule getVersionLiteralRule() {
		return getVersionLiteralAccess().getRule();
	}

	//VersionRangeLiteral returns build::VersionRange:
	//  ("["|"(") (STRING|AlfanumSym) ("," (STRING|AlfanumSym))? ("]"|")")|(STRING|
	//  AlfanumSym); 
	//
	//// Has conversion rule
	//    
	//	                      
	//	      
	//	
	//
	//// Reference to qualified named item, possibly in unit, this or super, or
	//// this.super, or unit.super
	//// TODO: super, unit, this - not yet handled - subject to change?
	public VersionRangeLiteralElements getVersionRangeLiteralAccess() {
		return (pVersionRangeLiteral != null) ? pVersionRangeLiteral : (pVersionRangeLiteral = new VersionRangeLiteralElements());
	}
	
	public ParserRule getVersionRangeLiteralRule() {
		return getVersionRangeLiteralAccess().getRule();
	}

	//QIDREF returns ecore::EString:
	//  ("super"|("unit"|"this") ("." "super")?) ("." QID)?|QID; 
	//
	//// Reference to qualified named item, possibly in unit, this or super, or
	//// this.super, or unit.super
	//// TODO: super, unit, this - not yet handled - subject to change?
	//                        
	//
	//// Qualified name
	public QIDREFElements getQIDREFAccess() {
		return (pQIDREF != null) ? pQIDREF : (pQIDREF = new QIDREFElements());
	}
	
	public ParserRule getQIDREFRule() {
		return getQIDREFAccess().getRule();
	}

	//QID returns ecore::EString hidden ( ):
	//  ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)*; 
	//
	//// Qualified name
	//               
	//
	//// Allows a qualified name, or a string to be used as a name
	public QIDElements getQIDAccess() {
		return (pQID != null) ? pQID : (pQID = new QIDElements());
	}
	
	public ParserRule getQIDRule() {
		return getQIDAccess().getRule();
	}

	//EscapedQualifiedName returns ecore::EString:
	//  STRING|QID;  
	//
	//// Allows a qualified name, or a string to be used as a name
	public EscapedQualifiedNameElements getEscapedQualifiedNameAccess() {
		return (pEscapedQualifiedName != null) ? pEscapedQualifiedName : (pEscapedQualifiedName = new EscapedQualifiedNameElements());
	}
	
	public ParserRule getEscapedQualifiedNameRule() {
		return getEscapedQualifiedNameAccess().getRule();
	}

	//InterfaceName returns ecore::EString:
	//  QID; 
	//	     
	//
	//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
	public InterfaceNameElements getInterfaceNameAccess() {
		return (pInterfaceName != null) ? pInterfaceName : (pInterfaceName = new InterfaceNameElements());
	}
	
	public ParserRule getInterfaceNameRule() {
		return getInterfaceNameAccess().getRule();
	}

	//UnitName returns ecore::EString:
	//  EscapedQualifiedName; 
	//
	//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
	public UnitNameElements getUnitNameAccess() {
		return (pUnitName != null) ? pUnitName : (pUnitName = new UnitNameElements());
	}
	
	public ParserRule getUnitNameRule() {
		return getUnitNameAccess().getRule();
	}

	//BuilderName returns ecore::EString:
	//  EscapedQualifiedName;
	public BuilderNameElements getBuilderNameAccess() {
		return (pBuilderName != null) ? pBuilderName : (pBuilderName = new BuilderNameElements());
	}
	
	public ParserRule getBuilderNameRule() {
		return getBuilderNameAccess().getRule();
	}

	//CapabilityName returns ecore::EString:
	//  EscapedQualifiedName;
	public CapabilityNameElements getCapabilityNameAccess() {
		return (pCapabilityName != null) ? pCapabilityName : (pCapabilityName = new CapabilityNameElements());
	}
	
	public ParserRule getCapabilityNameRule() {
		return getCapabilityNameAccess().getRule();
	}

	//enum Visibility returns be::Visibility:
	//  public | private;
	public VisibilityElements getVisibilityAccess() {
		return (unknownRuleVisibility != null) ? unknownRuleVisibility : (unknownRuleVisibility = new VisibilityElements());
	}
	
	public EnumRule getVisibilityRule() {
		return getVisibilityAccess().getRule();
	}

	//enum ExecutionMode returns be::ExecutionMode:
	//  parallel | sequential; 
	//   	           
	//
	//
	//// Version, and VersionRange
	//// TODO: uncertain if the set of allowed chars is definitive.
	////
	public ExecutionModeElements getExecutionModeAccess() {
		return (unknownRuleExecutionMode != null) ? unknownRuleExecutionMode : (unknownRuleExecutionMode = new ExecutionModeElements());
	}
	
	public EnumRule getExecutionModeRule() {
		return getExecutionModeAccess().getRule();
	}

	//Separator returns ecore::EString:
	//  "."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?"; 
	//
	//
	//// Version, and VersionRange
	//// TODO: uncertain if the set of allowed chars is definitive.
	////
	public SeparatorElements getSeparatorAccess() {
		return (pSeparator != null) ? pSeparator : (pSeparator = new SeparatorElements());
	}
	
	public ParserRule getSeparatorRule() {
		return getSeparatorAccess().getRule();
	}

	//AlfanumSym returns ecore::EString:
	//  (ID|INT|HEX|EXT_INT) (Separator|ID|INT|HEX|EXT_INT)*; 
	//                      
	//
	//// --TERMINALS
	//// (NOTE: Does not use standard terminals to have full control).
	//
	//// TODO: Possibly use some other char instead of ^ as escape mechanism for keywords??
	public AlfanumSymElements getAlfanumSymAccess() {
		return (pAlfanumSym != null) ? pAlfanumSym : (pAlfanumSym = new AlfanumSymElements());
	}
	
	public ParserRule getAlfanumSymRule() {
		return getAlfanumSymAccess().getRule();
	}

	//terminal ID:
	//  "^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "0".."9" | "_")*; 
	//
	//// --TERMINALS
	//// (NOTE: Does not use standard terminals to have full control).
	//
	//// TODO: Possibly use some other char instead of ^ as escape mechanism for keywords??
	//          
	//
	//// Property Names start with $ and are qualified. Must be handled by lexer as
	//// a.b.c is otherwise ambigous in expressions.
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal PID:
	//  "$" ID ("." ID)*; 
	//
	//// Property Names start with $ and are qualified. Must be handled by lexer as
	//// a.b.c is otherwise ambigous in expressions.
	//              
	//
	//// Java regexp - allows \ before any character == same as unescaped character if character is not an operator
	public TerminalRule getPIDRule() {
		return (tPID != null) ? tPID : (tPID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PID"));
	} 

	//terminal REGULAR_EXPR returns be::RegexpPattern:
	//  "~/" ("\\" !("\t" | "\r" | "\n") | !("\\" | "/" | " " | "\t" | "\r" | "\n"))* "/" ("u" | "m" | "i" | "c" |
	//  "d")*; 
	//
	//// Java regexp - allows \ before any character == same as unescaped character if character is not an operator
	//      
	//	        
	//			      
	//			
	//
	//// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
	//// A string converter may need to handle the u, x, and octal escapes.
	//// Regular java string handles XXXX , and gives syntax error if
	//// format is not ok, the other two remains, and possibly the null.
	//// TODO: check STRING grammar
	public TerminalRule getREGULAR_EXPRRule() {
		return (tREGULAR_EXPR != null) ? tREGULAR_EXPR : (tREGULAR_EXPR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REGULAR_EXPR"));
	} 

	//terminal STRING:
	//  "\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "x" | "0" | "\"" | "\'" | "\\") | !("\\" | "\"" | "\r" | "\n")
	//  )* "\"" | "\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "x" | "0" | "\"" | "\'" | "\\") | !("\\" | "\'" |
	//  "\r" | "\n"))* "\'"; 
	//
	//// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
	//// A string converter may need to handle the u, x, and octal escapes.
	//// Regular java string handles XXXX , and gives syntax error if
	//// format is not ok, the other two remains, and possibly the null.
	//// TODO: check STRING grammar
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal DOCUMENTATION:
	//  "/ **"->"* /";
	public TerminalRule getDOCUMENTATIONRule() {
		return (tDOCUMENTATION != null) ? tDOCUMENTATION : (tDOCUMENTATION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOCUMENTATION"));
	} 

	//terminal ML_COMMENT:
	//  "/ *" !"*"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//terminal SL_COMMENT:
	//  "//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//  (" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal HEX:
	//  "0" ("x" | "X") ("0".."9" | "a".."f" | "A".."F")+;
	public TerminalRule getHEXRule() {
		return (tHEX != null) ? tHEX : (tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX"));
	} 

	//terminal INT:
	//  "0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//REAL returns ecore::EString hidden ( ):
	//  INT? "." (EXT_INT|INT);
	public REALElements getREALAccess() {
		return (pREAL != null) ? pREAL : (pREAL = new REALElements());
	}
	
	public ParserRule getREALRule() {
		return getREALAccess().getRule();
	}

	//terminal EXT_INT:
	//  INT ("e" | "E") ("-" | "+") INT;
	public TerminalRule getEXT_INTRule() {
		return (tEXT_INT != null) ? tEXT_INT : (tEXT_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EXT_INT"));
	} 

	//terminal ANY_OTHER:
	//  .;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 
}
