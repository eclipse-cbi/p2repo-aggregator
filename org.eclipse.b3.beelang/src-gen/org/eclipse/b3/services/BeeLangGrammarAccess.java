/*
* generated by Xtext
*/

package org.eclipse.b3.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class BeeLangGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class BeeModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BeeModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cFunctionsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cFunctionsFunctionParserRuleCall_1_0_0 = (RuleCall)cFunctionsAssignment_1_0.eContents().get(0);
		private final Assignment cConcernAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cConcernConcernParserRuleCall_1_1_0 = (RuleCall)cConcernAssignment_1_1.eContents().get(0);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyUnitParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		
		//BeeModel hidden ( WS , SL_COMMENT , ML_COMMENT ):
		//  imports+=Import* (functions+=Function|concern+=Concern)* body=Unit?;
		public ParserRule getRule() { return rule; }

		//imports+=Import* (functions+=Function|concern+=Concern)* body=Unit?
		public Group getGroup() { return cGroup; }

		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }

		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }

		//(functions+=Function|concern+=Concern)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//functions+=Function
		public Assignment getFunctionsAssignment_1_0() { return cFunctionsAssignment_1_0; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_1_0_0() { return cFunctionsFunctionParserRuleCall_1_0_0; }

		//concern+=Concern
		public Assignment getConcernAssignment_1_1() { return cConcernAssignment_1_1; }

		//Concern
		public RuleCall getConcernConcernParserRuleCall_1_1_0() { return cConcernConcernParserRuleCall_1_1_0; }

		//body=Unit?
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//Unit
		public RuleCall getBodyUnitParserRuleCall_2_0() { return cBodyUnitParserRuleCall_2_0; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3JavaImportAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cReexportAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cReexportReexportKeyword_1_0 = (Keyword)cReexportAssignment_1.eContents().get(0);
		private final Keyword cImportKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cQualifiedNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cQualifiedNameQIDParserRuleCall_3_0 = (RuleCall)cQualifiedNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cAsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cNameAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_4_1_0 = (RuleCall)cNameAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Import returns be::IType:
		//  {be::B3JavaImport} reexport?="reexport"? "import" qualifiedName=QID ("as" name=ID)?
		//  ";"; 
		//
		//                        
		//
		//// Wanted later 
		////Import : (reexport ?='reexport')? 
		////		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
		////	; 
		//
		////JavaImporter 	: qualifiedName=QID ;
		////NativeImporter 	: uriString = STRING ;
		public ParserRule getRule() { return rule; }

		//{be::B3JavaImport} reexport?="reexport"? "import" qualifiedName=QID ("as" name=ID)?
		//";"
		public Group getGroup() { return cGroup; }

		//{be::B3JavaImport}
		public Action getB3JavaImportAction_0() { return cB3JavaImportAction_0; }

		//reexport?="reexport"?
		public Assignment getReexportAssignment_1() { return cReexportAssignment_1; }

		//"reexport"
		public Keyword getReexportReexportKeyword_1_0() { return cReexportReexportKeyword_1_0; }

		//"import"
		public Keyword getImportKeyword_2() { return cImportKeyword_2; }

		//qualifiedName=QID
		public Assignment getQualifiedNameAssignment_3() { return cQualifiedNameAssignment_3; }

		//QID
		public RuleCall getQualifiedNameQIDParserRuleCall_3_0() { return cQualifiedNameQIDParserRuleCall_3_0; }

		//("as" name=ID)?
		public Group getGroup_4() { return cGroup_4; }

		//"as"
		public Keyword getAsKeyword_4_0() { return cAsKeyword_4_0; }

		//name=ID
		public Assignment getNameAssignment_4_1() { return cNameAssignment_4_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_4_1_0() { return cNameIDTerminalRuleCall_4_1_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class UnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuildUnitAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Assignment cExecutionModeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExecutionModeExecutionModeEnumRuleCall_2_0 = (RuleCall)cExecutionModeAssignment_2.eContents().get(0);
		private final Keyword cUnitKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameUnitNameParserRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cVersionKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cVersionAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cVersionVersionParserRuleCall_5_1_0 = (RuleCall)cVersionAssignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cImplementsKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cImplementsAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cImplementsInterfaceNameParserRuleCall_6_1_0 = (RuleCall)cImplementsAssignment_6_1.eContents().get(0);
		private final Group cGroup_6_2 = (Group)cGroup_6.eContents().get(2);
		private final Keyword cCommaKeyword_6_2_0 = (Keyword)cGroup_6_2.eContents().get(0);
		private final Assignment cImplementsAssignment_6_2_1 = (Assignment)cGroup_6_2.eContents().get(1);
		private final RuleCall cImplementsInterfaceNameParserRuleCall_6_2_1_0 = (RuleCall)cImplementsAssignment_6_2_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cDefaultKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Keyword cPropertiesKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Assignment cDefaultPropertiesAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cDefaultPropertiesPropertySetParserRuleCall_8_2_0 = (RuleCall)cDefaultPropertiesAssignment_8_2.eContents().get(0);
		private final Alternatives cAlternatives_9 = (Alternatives)cGroup.eContents().get(9);
		private final Group cGroup_9_0 = (Group)cAlternatives_9.eContents().get(0);
		private final Keyword cProvidesKeyword_9_0_0 = (Keyword)cGroup_9_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_0_1 = (Keyword)cGroup_9_0.eContents().get(1);
		private final Group cGroup_9_0_2 = (Group)cGroup_9_0.eContents().get(2);
		private final Assignment cProvidedCapabilitiesAssignment_9_0_2_0 = (Assignment)cGroup_9_0_2.eContents().get(0);
		private final RuleCall cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_0_2_0_0 = (RuleCall)cProvidedCapabilitiesAssignment_9_0_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_0_2_1 = (Keyword)cGroup_9_0_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_9_0_3 = (Keyword)cGroup_9_0.eContents().get(3);
		private final Group cGroup_9_1 = (Group)cAlternatives_9.eContents().get(1);
		private final Keyword cProvidesKeyword_9_1_0 = (Keyword)cGroup_9_1.eContents().get(0);
		private final Assignment cProvidedCapabilitiesAssignment_9_1_1 = (Assignment)cGroup_9_1.eContents().get(1);
		private final RuleCall cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_1_0 = (RuleCall)cProvidedCapabilitiesAssignment_9_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_1_2 = (Keyword)cGroup_9_1.eContents().get(2);
		private final Group cGroup_9_2 = (Group)cAlternatives_9.eContents().get(2);
		private final Keyword cRequiresKeyword_9_2_0 = (Keyword)cGroup_9_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_2_1 = (Keyword)cGroup_9_2.eContents().get(1);
		private final Group cGroup_9_2_2 = (Group)cGroup_9_2.eContents().get(2);
		private final Assignment cRequiredCapabilitiesAssignment_9_2_2_0 = (Assignment)cGroup_9_2_2.eContents().get(0);
		private final RuleCall cRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_2_2_0_0 = (RuleCall)cRequiredCapabilitiesAssignment_9_2_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_2_2_1 = (Keyword)cGroup_9_2_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_9_2_3 = (Keyword)cGroup_9_2.eContents().get(3);
		private final Group cGroup_9_3 = (Group)cAlternatives_9.eContents().get(3);
		private final Keyword cRequiresKeyword_9_3_0 = (Keyword)cGroup_9_3.eContents().get(0);
		private final Assignment cRequiredCapabilitiesAssignment_9_3_1 = (Assignment)cGroup_9_3.eContents().get(1);
		private final RuleCall cRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_3_1_0 = (RuleCall)cRequiredCapabilitiesAssignment_9_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_3_2 = (Keyword)cGroup_9_3.eContents().get(2);
		private final Group cGroup_9_4 = (Group)cAlternatives_9.eContents().get(4);
		private final Keyword cEnvKeyword_9_4_0 = (Keyword)cGroup_9_4.eContents().get(0);
		private final Keyword cRequiresKeyword_9_4_1 = (Keyword)cGroup_9_4.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_9_4_2 = (Keyword)cGroup_9_4.eContents().get(2);
		private final Group cGroup_9_4_3 = (Group)cGroup_9_4.eContents().get(3);
		private final Assignment cMetaRequiredCapabilitiesAssignment_9_4_3_0 = (Assignment)cGroup_9_4_3.eContents().get(0);
		private final RuleCall cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_4_3_0_0 = (RuleCall)cMetaRequiredCapabilitiesAssignment_9_4_3_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_4_3_1 = (Keyword)cGroup_9_4_3.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_9_4_4 = (Keyword)cGroup_9_4.eContents().get(4);
		private final Group cGroup_9_5 = (Group)cAlternatives_9.eContents().get(5);
		private final Keyword cEnvKeyword_9_5_0 = (Keyword)cGroup_9_5.eContents().get(0);
		private final Keyword cRequiresKeyword_9_5_1 = (Keyword)cGroup_9_5.eContents().get(1);
		private final Assignment cMetaRequiredCapabilitiesAssignment_9_5_2 = (Assignment)cGroup_9_5.eContents().get(2);
		private final RuleCall cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_5_2_0 = (RuleCall)cMetaRequiredCapabilitiesAssignment_9_5_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_5_3 = (Keyword)cGroup_9_5.eContents().get(3);
		private final Assignment cConcernsAssignment_9_6 = (Assignment)cAlternatives_9.eContents().get(6);
		private final RuleCall cConcernsConcernParserRuleCall_9_6_0 = (RuleCall)cConcernsAssignment_9_6.eContents().get(0);
		private final Group cGroup_9_7 = (Group)cAlternatives_9.eContents().get(7);
		private final Keyword cSequentialKeyword_9_7_0 = (Keyword)cGroup_9_7.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_7_1 = (Keyword)cGroup_9_7.eContents().get(1);
		private final Assignment cSynchronizationsAssignment_9_7_2 = (Assignment)cGroup_9_7.eContents().get(2);
		private final RuleCall cSynchronizationsSynchronizationParserRuleCall_9_7_2_0 = (RuleCall)cSynchronizationsAssignment_9_7_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9_7_3 = (Keyword)cGroup_9_7.eContents().get(3);
		private final Group cGroup_9_8 = (Group)cAlternatives_9.eContents().get(8);
		private final Keyword cSequentialKeyword_9_8_0 = (Keyword)cGroup_9_8.eContents().get(0);
		private final Assignment cSynchronizationsAssignment_9_8_1 = (Assignment)cGroup_9_8.eContents().get(1);
		private final RuleCall cSynchronizationsSynchronizationParserRuleCall_9_8_1_0 = (RuleCall)cSynchronizationsAssignment_9_8_1.eContents().get(0);
		private final Assignment cBuildersAssignment_9_9 = (Assignment)cAlternatives_9.eContents().get(9);
		private final RuleCall cBuildersBuilderParserRuleCall_9_9_0 = (RuleCall)cBuildersAssignment_9_9.eContents().get(0);
		private final Assignment cFunctionsAssignment_9_10 = (Assignment)cAlternatives_9.eContents().get(10);
		private final RuleCall cFunctionsFunctionParserRuleCall_9_10_0 = (RuleCall)cFunctionsAssignment_9_10.eContents().get(0);
		private final Group cGroup_9_11 = (Group)cAlternatives_9.eContents().get(11);
		private final Keyword cRepositoriesKeyword_9_11_0 = (Keyword)cGroup_9_11.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_11_1 = (Keyword)cGroup_9_11.eContents().get(1);
		private final Assignment cRepositoryConfigurationsAssignment_9_11_2 = (Assignment)cGroup_9_11.eContents().get(2);
		private final RuleCall cRepositoryConfigurationsRepositoryConfigurationParserRuleCall_9_11_2_0 = (RuleCall)cRepositoryConfigurationsAssignment_9_11_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9_11_3 = (Keyword)cGroup_9_11.eContents().get(3);
		private final Group cGroup_9_12 = (Group)cAlternatives_9.eContents().get(12);
		private final Keyword cPropertiesKeyword_9_12_0 = (Keyword)cGroup_9_12.eContents().get(0);
		private final Assignment cPropertySetsAssignment_9_12_1 = (Assignment)cGroup_9_12.eContents().get(1);
		private final RuleCall cPropertySetsNamedPropertySetParserRuleCall_9_12_1_0 = (RuleCall)cPropertySetsAssignment_9_12_1.eContents().get(0);
		private final Group cGroup_9_13 = (Group)cAlternatives_9.eContents().get(13);
		private final Keyword cContainersKeyword_9_13_0 = (Keyword)cGroup_9_13.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_9_13_1 = (Keyword)cGroup_9_13.eContents().get(1);
		private final Assignment cContainersAssignment_9_13_2 = (Assignment)cGroup_9_13.eContents().get(2);
		private final RuleCall cContainersContainerConfigurationParserRuleCall_9_13_2_0 = (RuleCall)cContainersAssignment_9_13_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9_13_3 = (Keyword)cGroup_9_13.eContents().get(3);
		private final Keyword cRightCurlyBracketKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//Unit returns BuildUnit hidden ( WS , ML_COMMENT , SL_COMMENT ):
		//  {BuildUnit} documentation=DOCUMENTATION? executionMode=ExecutionMode? "unit" name=
		//  UnitName? ("version" version=Version)? ("implements" implements+=InterfaceName (","
		//  implements+=InterfaceName)*)? "{" ("default" "properties" defaultProperties=
		//  PropertySet)? ("provides" "{" (providedCapabilities+=ProvidedCapability ";")+ "}"|
		//  "provides" providedCapabilities+=ProvidedCapability ";"|"requires" "{" (
		//  requiredCapabilities+=RequiredCapability ";")+ "}"|"requires" requiredCapabilities
		//  +=RequiredCapability ";"|"env" "requires" "{" (metaRequiredCapabilities+=
		//  RequiredCapability ";")+ "}"|"env" "requires" metaRequiredCapabilities+=
		//  RequiredCapability ";"|concerns+=Concern|"sequential" "{" synchronizations+=
		//  Synchronization+ "}"|"sequential" synchronizations+=Synchronization|builders+=
		//  Builder|functions+=Function|"repositories" "{" repositoryConfigurations+=
		//  RepositoryConfiguration* "}"|"properties" propertySets+=NamedPropertySet|
		//  "containers" "{" containers+=ContainerConfiguration* "}")* "}"; 
		//
		//// Wanted later 
		////Import : (reexport ?='reexport')? 
		////		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
		////	; 
		//
		////JavaImporter 	: qualifiedName=QID ;
		////NativeImporter 	: uriString = STRING ;
		//		
		//              
		//	    
		//	    
		//	          
		//		           
		//	
		//			 //-- PROPERTIES
		//			 // goes first, because they may be used in the other clauses. TODO: can probably be relaxed
		//			 // since linking will find them anyway.
		//			 //
		//			            
		//		
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--CONCERNS
		//			     
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--BUILD METHODS & FUNCTIONS
		//			         			
		//			        			
		//			//-- REPOSITORIES
		public ParserRule getRule() { return rule; }

		//{BuildUnit} documentation=DOCUMENTATION? executionMode=ExecutionMode? "unit" name=
		//UnitName? ("version" version=Version)? ("implements" implements+=InterfaceName (","
		//implements+=InterfaceName)*)? "{" ("default" "properties" defaultProperties=
		//PropertySet)? ("provides" "{" (providedCapabilities+=ProvidedCapability ";")+ "}"|
		//"provides" providedCapabilities+=ProvidedCapability ";"|"requires" "{" (
		//requiredCapabilities+=RequiredCapability ";")+ "}"|"requires" requiredCapabilities
		//+=RequiredCapability ";"|"env" "requires" "{" (metaRequiredCapabilities+=
		//RequiredCapability ";")+ "}"|"env" "requires" metaRequiredCapabilities+=
		//RequiredCapability ";"|concerns+=Concern|"sequential" "{" synchronizations+=
		//Synchronization+ "}"|"sequential" synchronizations+=Synchronization|builders+=
		//Builder|functions+=Function|"repositories" "{" repositoryConfigurations+=
		//RepositoryConfiguration* "}"|"properties" propertySets+=NamedPropertySet|
		//"containers" "{" containers+=ContainerConfiguration* "}")* "}"   
		//	    
		//	    
		//	          
		//		           
		//	
		//			 //-- PROPERTIES
		//			 // goes first, because they may be used in the other clauses. TODO: can probably be relaxed
		//			 // since linking will find them anyway.
		//			 //
		//			            
		//		
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--CONCERNS
		//			     
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--BUILD METHODS & FUNCTIONS
		//			         			
		//			        			
		//			//-- REPOSITORIES
		public Group getGroup() { return cGroup; }

		//{BuildUnit}
		public Action getBuildUnitAction_0() { return cBuildUnitAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//executionMode=ExecutionMode?
		public Assignment getExecutionModeAssignment_2() { return cExecutionModeAssignment_2; }

		//ExecutionMode
		public RuleCall getExecutionModeExecutionModeEnumRuleCall_2_0() { return cExecutionModeExecutionModeEnumRuleCall_2_0; }

		//"unit"
		public Keyword getUnitKeyword_3() { return cUnitKeyword_3; }

		//name=UnitName?
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }

		//UnitName
		public RuleCall getNameUnitNameParserRuleCall_4_0() { return cNameUnitNameParserRuleCall_4_0; }

		//("version" version=Version)?
		public Group getGroup_5() { return cGroup_5; }

		//"version"
		public Keyword getVersionKeyword_5_0() { return cVersionKeyword_5_0; }

		//version=Version
		public Assignment getVersionAssignment_5_1() { return cVersionAssignment_5_1; }

		//Version
		public RuleCall getVersionVersionParserRuleCall_5_1_0() { return cVersionVersionParserRuleCall_5_1_0; }

		//("implements" implements+=InterfaceName ("," implements+=InterfaceName)*)?
		public Group getGroup_6() { return cGroup_6; }

		//"implements"
		public Keyword getImplementsKeyword_6_0() { return cImplementsKeyword_6_0; }

		//implements+=InterfaceName
		public Assignment getImplementsAssignment_6_1() { return cImplementsAssignment_6_1; }

		//InterfaceName
		public RuleCall getImplementsInterfaceNameParserRuleCall_6_1_0() { return cImplementsInterfaceNameParserRuleCall_6_1_0; }

		//("," implements+=InterfaceName)*
		public Group getGroup_6_2() { return cGroup_6_2; }

		//","
		public Keyword getCommaKeyword_6_2_0() { return cCommaKeyword_6_2_0; }

		//implements+=InterfaceName
		public Assignment getImplementsAssignment_6_2_1() { return cImplementsAssignment_6_2_1; }

		//InterfaceName
		public RuleCall getImplementsInterfaceNameParserRuleCall_6_2_1_0() { return cImplementsInterfaceNameParserRuleCall_6_2_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_7() { return cLeftCurlyBracketKeyword_7; }

		//("default" "properties" defaultProperties=PropertySet)?
		public Group getGroup_8() { return cGroup_8; }

		//"default"
		public Keyword getDefaultKeyword_8_0() { return cDefaultKeyword_8_0; }

		//"properties"
		public Keyword getPropertiesKeyword_8_1() { return cPropertiesKeyword_8_1; }

		//defaultProperties=PropertySet
		public Assignment getDefaultPropertiesAssignment_8_2() { return cDefaultPropertiesAssignment_8_2; }

		//PropertySet
		public RuleCall getDefaultPropertiesPropertySetParserRuleCall_8_2_0() { return cDefaultPropertiesPropertySetParserRuleCall_8_2_0; }

		//("provides" "{" (providedCapabilities+=ProvidedCapability ";")+ "}"|"provides"
		//providedCapabilities+=ProvidedCapability ";"|"requires" "{" (requiredCapabilities+=
		//RequiredCapability ";")+ "}"|"requires" requiredCapabilities+=RequiredCapability ";"
		//|"env" "requires" "{" (metaRequiredCapabilities+=RequiredCapability ";")+ "}"|"env"
		//"requires" metaRequiredCapabilities+=RequiredCapability ";"|concerns+=Concern|
		//"sequential" "{" synchronizations+=Synchronization+ "}"|"sequential"
		//synchronizations+=Synchronization|builders+=Builder|functions+=Function|
		//"repositories" "{" repositoryConfigurations+=RepositoryConfiguration* "}"|
		//"properties" propertySets+=NamedPropertySet|"containers" "{" containers+=
		//ContainerConfiguration* "}")* 
		//		 	 //-- PROVIDES
		//			               
		//			          
		//			//-- REQUIRES & META REQUIRES
		//			               
		//			          
		//			                  
		//			            
		//			//--CONCERNS
		//			     
		//			//--SYNCHRONIZE
		//			                  
		//			           
		//			//--BUILD METHODS & FUNCTIONS
		//			         			
		//			        			
		//			//-- REPOSITORIES
		public Alternatives getAlternatives_9() { return cAlternatives_9; }

		//"provides" "{" (providedCapabilities+=ProvidedCapability ";")+ "}"
		public Group getGroup_9_0() { return cGroup_9_0; }

		//"provides"
		public Keyword getProvidesKeyword_9_0_0() { return cProvidesKeyword_9_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_0_1() { return cLeftCurlyBracketKeyword_9_0_1; }

		//(providedCapabilities+=ProvidedCapability ";")+
		public Group getGroup_9_0_2() { return cGroup_9_0_2; }

		//providedCapabilities+=ProvidedCapability
		public Assignment getProvidedCapabilitiesAssignment_9_0_2_0() { return cProvidedCapabilitiesAssignment_9_0_2_0; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_0_2_0_0() { return cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_0_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_9_0_2_1() { return cSemicolonKeyword_9_0_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_0_3() { return cRightCurlyBracketKeyword_9_0_3; }

		//"provides" providedCapabilities+=ProvidedCapability ";"
		public Group getGroup_9_1() { return cGroup_9_1; }

		//"provides"
		public Keyword getProvidesKeyword_9_1_0() { return cProvidesKeyword_9_1_0; }

		//providedCapabilities+=ProvidedCapability
		public Assignment getProvidedCapabilitiesAssignment_9_1_1() { return cProvidedCapabilitiesAssignment_9_1_1; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_1_0() { return cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_9_1_2() { return cSemicolonKeyword_9_1_2; }

		//"requires" "{" (requiredCapabilities+=RequiredCapability ";")+ "}"
		public Group getGroup_9_2() { return cGroup_9_2; }

		//"requires"
		public Keyword getRequiresKeyword_9_2_0() { return cRequiresKeyword_9_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_2_1() { return cLeftCurlyBracketKeyword_9_2_1; }

		//(requiredCapabilities+=RequiredCapability ";")+
		public Group getGroup_9_2_2() { return cGroup_9_2_2; }

		//requiredCapabilities+=RequiredCapability
		public Assignment getRequiredCapabilitiesAssignment_9_2_2_0() { return cRequiredCapabilitiesAssignment_9_2_2_0; }

		//RequiredCapability
		public RuleCall getRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_2_2_0_0() { return cRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_2_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_9_2_2_1() { return cSemicolonKeyword_9_2_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_2_3() { return cRightCurlyBracketKeyword_9_2_3; }

		//"requires" requiredCapabilities+=RequiredCapability ";"
		public Group getGroup_9_3() { return cGroup_9_3; }

		//"requires"
		public Keyword getRequiresKeyword_9_3_0() { return cRequiresKeyword_9_3_0; }

		//requiredCapabilities+=RequiredCapability
		public Assignment getRequiredCapabilitiesAssignment_9_3_1() { return cRequiredCapabilitiesAssignment_9_3_1; }

		//RequiredCapability
		public RuleCall getRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_3_1_0() { return cRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_9_3_2() { return cSemicolonKeyword_9_3_2; }

		//"env" "requires" "{" (metaRequiredCapabilities+=RequiredCapability ";")+ "}"
		public Group getGroup_9_4() { return cGroup_9_4; }

		//"env"
		public Keyword getEnvKeyword_9_4_0() { return cEnvKeyword_9_4_0; }

		//"requires"
		public Keyword getRequiresKeyword_9_4_1() { return cRequiresKeyword_9_4_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_4_2() { return cLeftCurlyBracketKeyword_9_4_2; }

		//(metaRequiredCapabilities+=RequiredCapability ";")+
		public Group getGroup_9_4_3() { return cGroup_9_4_3; }

		//metaRequiredCapabilities+=RequiredCapability
		public Assignment getMetaRequiredCapabilitiesAssignment_9_4_3_0() { return cMetaRequiredCapabilitiesAssignment_9_4_3_0; }

		//RequiredCapability
		public RuleCall getMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_4_3_0_0() { return cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_4_3_0_0; }

		//";"
		public Keyword getSemicolonKeyword_9_4_3_1() { return cSemicolonKeyword_9_4_3_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_4_4() { return cRightCurlyBracketKeyword_9_4_4; }

		//"env" "requires" metaRequiredCapabilities+=RequiredCapability ";"
		public Group getGroup_9_5() { return cGroup_9_5; }

		//"env"
		public Keyword getEnvKeyword_9_5_0() { return cEnvKeyword_9_5_0; }

		//"requires"
		public Keyword getRequiresKeyword_9_5_1() { return cRequiresKeyword_9_5_1; }

		//metaRequiredCapabilities+=RequiredCapability
		public Assignment getMetaRequiredCapabilitiesAssignment_9_5_2() { return cMetaRequiredCapabilitiesAssignment_9_5_2; }

		//RequiredCapability
		public RuleCall getMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_5_2_0() { return cMetaRequiredCapabilitiesRequiredCapabilityParserRuleCall_9_5_2_0; }

		//";"
		public Keyword getSemicolonKeyword_9_5_3() { return cSemicolonKeyword_9_5_3; }

		//concerns+=Concern
		public Assignment getConcernsAssignment_9_6() { return cConcernsAssignment_9_6; }

		//Concern
		public RuleCall getConcernsConcernParserRuleCall_9_6_0() { return cConcernsConcernParserRuleCall_9_6_0; }

		//"sequential" "{" synchronizations+=Synchronization+ "}"
		public Group getGroup_9_7() { return cGroup_9_7; }

		//"sequential"
		public Keyword getSequentialKeyword_9_7_0() { return cSequentialKeyword_9_7_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_7_1() { return cLeftCurlyBracketKeyword_9_7_1; }

		//synchronizations+=Synchronization+
		public Assignment getSynchronizationsAssignment_9_7_2() { return cSynchronizationsAssignment_9_7_2; }

		//Synchronization
		public RuleCall getSynchronizationsSynchronizationParserRuleCall_9_7_2_0() { return cSynchronizationsSynchronizationParserRuleCall_9_7_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_7_3() { return cRightCurlyBracketKeyword_9_7_3; }

		//"sequential" synchronizations+=Synchronization
		public Group getGroup_9_8() { return cGroup_9_8; }

		//"sequential"
		public Keyword getSequentialKeyword_9_8_0() { return cSequentialKeyword_9_8_0; }

		//synchronizations+=Synchronization
		public Assignment getSynchronizationsAssignment_9_8_1() { return cSynchronizationsAssignment_9_8_1; }

		//Synchronization
		public RuleCall getSynchronizationsSynchronizationParserRuleCall_9_8_1_0() { return cSynchronizationsSynchronizationParserRuleCall_9_8_1_0; }

		//builders+=Builder
		public Assignment getBuildersAssignment_9_9() { return cBuildersAssignment_9_9; }

		//Builder
		public RuleCall getBuildersBuilderParserRuleCall_9_9_0() { return cBuildersBuilderParserRuleCall_9_9_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_9_10() { return cFunctionsAssignment_9_10; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_9_10_0() { return cFunctionsFunctionParserRuleCall_9_10_0; }

		//"repositories" "{" repositoryConfigurations+=RepositoryConfiguration* "}"
		public Group getGroup_9_11() { return cGroup_9_11; }

		//"repositories"
		public Keyword getRepositoriesKeyword_9_11_0() { return cRepositoriesKeyword_9_11_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_11_1() { return cLeftCurlyBracketKeyword_9_11_1; }

		//repositoryConfigurations+=RepositoryConfiguration*
		public Assignment getRepositoryConfigurationsAssignment_9_11_2() { return cRepositoryConfigurationsAssignment_9_11_2; }

		//RepositoryConfiguration
		public RuleCall getRepositoryConfigurationsRepositoryConfigurationParserRuleCall_9_11_2_0() { return cRepositoryConfigurationsRepositoryConfigurationParserRuleCall_9_11_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_11_3() { return cRightCurlyBracketKeyword_9_11_3; }

		//"properties" propertySets+=NamedPropertySet
		public Group getGroup_9_12() { return cGroup_9_12; }

		//"properties"
		public Keyword getPropertiesKeyword_9_12_0() { return cPropertiesKeyword_9_12_0; }

		//propertySets+=NamedPropertySet
		public Assignment getPropertySetsAssignment_9_12_1() { return cPropertySetsAssignment_9_12_1; }

		//NamedPropertySet
		public RuleCall getPropertySetsNamedPropertySetParserRuleCall_9_12_1_0() { return cPropertySetsNamedPropertySetParserRuleCall_9_12_1_0; }

		//"containers" "{" containers+=ContainerConfiguration* "}"
		public Group getGroup_9_13() { return cGroup_9_13; }

		//"containers"
		public Keyword getContainersKeyword_9_13_0() { return cContainersKeyword_9_13_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_9_13_1() { return cLeftCurlyBracketKeyword_9_13_1; }

		//containers+=ContainerConfiguration*
		public Assignment getContainersAssignment_9_13_2() { return cContainersAssignment_9_13_2; }

		//ContainerConfiguration
		public RuleCall getContainersContainerConfigurationParserRuleCall_9_13_2_0() { return cContainersContainerConfigurationParserRuleCall_9_13_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_9_13_3() { return cRightCurlyBracketKeyword_9_13_3; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_10() { return cRightCurlyBracketKeyword_10; }
	}

	public class ProvidedCapabilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProvidedCapability");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCapabilityAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCapabilityFilteredCapabilityParserRuleCall_0_0 = (RuleCall)cCapabilityAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVersionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVersionVersionParserRuleCall_1_1_0 = (RuleCall)cVersionAssignment_1_1.eContents().get(0);
		
		//ProvidedCapability:
		//  capability=FilteredCapability ("/" version=Version)?;
		public ParserRule getRule() { return rule; }

		//capability=FilteredCapability ("/" version=Version)?
		public Group getGroup() { return cGroup; }

		//capability=FilteredCapability
		public Assignment getCapabilityAssignment_0() { return cCapabilityAssignment_0; }

		//FilteredCapability
		public RuleCall getCapabilityFilteredCapabilityParserRuleCall_0_0() { return cCapabilityFilteredCapabilityParserRuleCall_0_0; }

		//("/" version=Version)?
		public Group getGroup_1() { return cGroup_1; }

		//"/"
		public Keyword getSolidusKeyword_1_0() { return cSolidusKeyword_1_0; }

		//version=Version
		public Assignment getVersionAssignment_1_1() { return cVersionAssignment_1_1; }

		//Version
		public RuleCall getVersionVersionParserRuleCall_1_1_0() { return cVersionVersionParserRuleCall_1_1_0; }
	}

	public class RequiredCapabilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RequiredCapability");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCapabilityAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCapabilityFilteredCapabilityParserRuleCall_0_0 = (RuleCall)cCapabilityAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRangeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRangeVersionRangeParserRuleCall_1_1_0 = (RuleCall)cRangeAssignment_1_1.eContents().get(0);
		
		//RequiredCapability:
		//  capability=FilteredCapability ("/" range=VersionRange)?;
		public ParserRule getRule() { return rule; }

		//capability=FilteredCapability ("/" range=VersionRange)?
		public Group getGroup() { return cGroup; }

		//capability=FilteredCapability
		public Assignment getCapabilityAssignment_0() { return cCapabilityAssignment_0; }

		//FilteredCapability
		public RuleCall getCapabilityFilteredCapabilityParserRuleCall_0_0() { return cCapabilityFilteredCapabilityParserRuleCall_0_0; }

		//("/" range=VersionRange)?
		public Group getGroup_1() { return cGroup_1; }

		//"/"
		public Keyword getSolidusKeyword_1_0() { return cSolidusKeyword_1_0; }

		//range=VersionRange
		public Assignment getRangeAssignment_1_1() { return cRangeAssignment_1_1; }

		//VersionRange
		public RuleCall getRangeVersionRangeParserRuleCall_1_1_0() { return cRangeVersionRangeParserRuleCall_1_1_0; }
	}

	public class FilteredCapabilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FilteredCapability");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cFilterAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_0_1_0 = (RuleCall)cFilterAssignment_0_1.eContents().get(0);
		private final Assignment cCapabilityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCapabilityCapabilityParserRuleCall_1_0 = (RuleCall)cCapabilityAssignment_1.eContents().get(0);
		
		//FilteredCapability:
		//  ("when" filter=Filter)? capability=Capability;
		public ParserRule getRule() { return rule; }

		//("when" filter=Filter)? capability=Capability
		public Group getGroup() { return cGroup; }

		//("when" filter=Filter)?
		public Group getGroup_0() { return cGroup_0; }

		//"when"
		public Keyword getWhenKeyword_0_0() { return cWhenKeyword_0_0; }

		//filter=Filter
		public Assignment getFilterAssignment_0_1() { return cFilterAssignment_0_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_0_1_0() { return cFilterFilterParserRuleCall_0_1_0; }

		//capability=Capability
		public Assignment getCapabilityAssignment_1() { return cCapabilityAssignment_1; }

		//Capability
		public RuleCall getCapabilityCapabilityParserRuleCall_1_0() { return cCapabilityCapabilityParserRuleCall_1_0; }
	}

	public class CapabilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Capability");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInterfaceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cInterfaceInterfaceNameParserRuleCall_0_0 = (RuleCall)cInterfaceAssignment_0.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnitNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//Capability:
		//  interface=InterfaceName "/" name=UnitName; 
		//          
		//
		//// An optionally named sequence of property statements
		public ParserRule getRule() { return rule; }

		//interface=InterfaceName "/" name=UnitName
		public Group getGroup() { return cGroup; }

		//interface=InterfaceName
		public Assignment getInterfaceAssignment_0() { return cInterfaceAssignment_0; }

		//InterfaceName
		public RuleCall getInterfaceInterfaceNameParserRuleCall_0_0() { return cInterfaceInterfaceNameParserRuleCall_0_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//name=UnitName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnitName
		public RuleCall getNameUnitNameParserRuleCall_2_0() { return cNameUnitNameParserRuleCall_2_0; }
	}

	public class NamedPropertySetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamedPropertySet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyPropertySetParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//NamedPropertySet:
		//  name=ID body=PropertySet; 
		//
		//// An optionally named sequence of property statements
		//    
		//	             
		//	
		//
		//// Sequence of possibly filtered property statements
		public ParserRule getRule() { return rule; }

		//name=ID body=PropertySet
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//body=PropertySet
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//PropertySet
		public RuleCall getBodyPropertySetParserRuleCall_1_0() { return cBodyPropertySetParserRuleCall_1_0; }
	}

	public class PropertySetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertySet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPropertySetAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cExtendsKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExtendsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExtendsQIDREFParserRuleCall_1_1_0 = (RuleCall)cExtendsAssignment_1_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOperationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOperationsPropertyOperationParserRuleCall_3_0 = (RuleCall)cOperationsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PropertySet:
		//  {PropertySet} ("extends" extends=QIDREF)? "{" operations+=PropertyOperation* "}"; 
		//
		//// Sequence of possibly filtered property statements	
		//    
		//	                 
		////	:  ("extends" extends=[NamedPropertySet | QIDREF])? '{' (operations += PropertyOperation)* '}'
		//	 
		//
		//// For model generation, to get supertype correct
		public ParserRule getRule() { return rule; }

		//{PropertySet} ("extends" extends=QIDREF)? "{" operations+=PropertyOperation* "}"         
		//        
		////	:  ("extends" extends=[NamedPropertySet | QIDREF])? '{' (operations += PropertyOperation)* '}'
		public Group getGroup() { return cGroup; }

		//{PropertySet}
		public Action getPropertySetAction_0() { return cPropertySetAction_0; }

		//("extends" extends=QIDREF)?
		public Group getGroup_1() { return cGroup_1; }

		//"extends"
		public Keyword getExtendsKeyword_1_0() { return cExtendsKeyword_1_0; }

		//extends=QIDREF
		public Assignment getExtendsAssignment_1_1() { return cExtendsAssignment_1_1; }

		//QIDREF
		public RuleCall getExtendsQIDREFParserRuleCall_1_1_0() { return cExtendsQIDREFParserRuleCall_1_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//operations+=PropertyOperation*
		public Assignment getOperationsAssignment_3() { return cOperationsAssignment_3; }

		//PropertyOperation
		public RuleCall getOperationsPropertyOperationParserRuleCall_3_0() { return cOperationsPropertyOperationParserRuleCall_3_0; }

		//"}"   
		////	:  ("extends" extends=[NamedPropertySet | QIDREF])? '{' (operations += PropertyOperation)* '}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class PropertyOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFilteredPropertyOperationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSetPropertyOperationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUnsetPropertyOperationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPropertySetParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PropertyOperation:
		//  FilteredPropertyOperation|SetPropertyOperation|UnsetPropertyOperation|
		//  PropertySet; 
		//
		//// For model generation, to get supertype correct
		public ParserRule getRule() { return rule; }

		//FilteredPropertyOperation|SetPropertyOperation|UnsetPropertyOperation|
		//PropertySet 
		//
		//// For model generation, to get supertype correct
		public Alternatives getAlternatives() { return cAlternatives; }

		//FilteredPropertyOperation
		public RuleCall getFilteredPropertyOperationParserRuleCall_0() { return cFilteredPropertyOperationParserRuleCall_0; }

		//SetPropertyOperation
		public RuleCall getSetPropertyOperationParserRuleCall_1() { return cSetPropertyOperationParserRuleCall_1; }

		//UnsetPropertyOperation
		public RuleCall getUnsetPropertyOperationParserRuleCall_2() { return cUnsetPropertyOperationParserRuleCall_2; }

		//PropertySet
		public RuleCall getPropertySetParserRuleCall_3() { return cPropertySetParserRuleCall_3; }
	}

	public class FilteredPropertyOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FilteredPropertyOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFilterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_1_0 = (RuleCall)cFilterAssignment_1.eContents().get(0);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cBodyAlternatives_2_0 = (Alternatives)cBodyAssignment_2.eContents().get(0);
		private final RuleCall cBodySetPropertyOperationParserRuleCall_2_0_0 = (RuleCall)cBodyAlternatives_2_0.eContents().get(0);
		private final RuleCall cBodyUnsetPropertyOperationParserRuleCall_2_0_1 = (RuleCall)cBodyAlternatives_2_0.eContents().get(1);
		private final RuleCall cBodyPropertySetParserRuleCall_2_0_2 = (RuleCall)cBodyAlternatives_2_0.eContents().get(2);
		
		//FilteredPropertyOperation:
		//  "when" filter=Filter body=( SetPropertyOperation | UnsetPropertyOperation | PropertySet
		//  ); 
		//
		//    
		//	    
		//		         
		//	
		//// be::BDefProperty   immutable ?= "val"
		//// property values, must be assigned (but can be assigned null).
		public ParserRule getRule() { return rule; }

		//"when" filter=Filter body=( SetPropertyOperation | UnsetPropertyOperation | PropertySet
		//)
		public Group getGroup() { return cGroup; }

		//"when"
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		//filter=Filter
		public Assignment getFilterAssignment_1() { return cFilterAssignment_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_1_0() { return cFilterFilterParserRuleCall_1_0; }

		//body=( SetPropertyOperation | UnsetPropertyOperation | PropertySet )
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//SetPropertyOperation|UnsetPropertyOperation|PropertySet
		public Alternatives getBodyAlternatives_2_0() { return cBodyAlternatives_2_0; }

		//SetPropertyOperation
		public RuleCall getBodySetPropertyOperationParserRuleCall_2_0_0() { return cBodySetPropertyOperationParserRuleCall_2_0_0; }

		//UnsetPropertyOperation
		public RuleCall getBodyUnsetPropertyOperationParserRuleCall_2_0_1() { return cBodyUnsetPropertyOperationParserRuleCall_2_0_1; }

		//PropertySet
		public RuleCall getBodyPropertySetParserRuleCall_2_0_2() { return cBodyPropertySetParserRuleCall_2_0_2; }
	}

	public class PropertyValDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyValDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefPropertyAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFinalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFinalFinalKeyword_1_0 = (Keyword)cFinalAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Keyword cPropertyKeyword_2_0_0 = (Keyword)cAlternatives_2_0.eContents().get(0);
		private final Assignment cTypeAssignment_2_0_1 = (Assignment)cAlternatives_2_0.eContents().get(1);
		private final RuleCall cTypeTypeRefParserRuleCall_2_0_1_0 = (RuleCall)cTypeAssignment_2_0_1.eContents().get(0);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNamePIDTerminalRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValueExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueExprExpressionParserRuleCall_4_0 = (RuleCall)cValueExprAssignment_4.eContents().get(0);
		
		//PropertyValDeclaration returns be::BExpression:
		//  {be::BDefProperty} final?="final"? (("property"|type=TypeRef) name=PID) "=" valueExpr
		//  =Expression; 
		//// be::BDefProperty   immutable ?= "val"
		//// property values, must be assigned (but can be assigned null).
		public ParserRule getRule() { return rule; }

		//{be::BDefProperty} final?="final"? (("property"|type=TypeRef) name=PID) "=" valueExpr
		//=Expression
		public Group getGroup() { return cGroup; }

		//{be::BDefProperty}
		public Action getBDefPropertyAction_0() { return cBDefPropertyAction_0; }

		//final?="final"?
		public Assignment getFinalAssignment_1() { return cFinalAssignment_1; }

		//"final"
		public Keyword getFinalFinalKeyword_1_0() { return cFinalFinalKeyword_1_0; }

		//("property"|type=TypeRef) name=PID
		public Group getGroup_2() { return cGroup_2; }

		//"property"|type=TypeRef
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }

		//"property"
		public Keyword getPropertyKeyword_2_0_0() { return cPropertyKeyword_2_0_0; }

		//type=TypeRef
		public Assignment getTypeAssignment_2_0_1() { return cTypeAssignment_2_0_1; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_2_0_1_0() { return cTypeTypeRefParserRuleCall_2_0_1_0; }

		//name=PID
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_2_1_0() { return cNamePIDTerminalRuleCall_2_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_4() { return cValueExprAssignment_4; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_4_0() { return cValueExprExpressionParserRuleCall_4_0; }
	}

	public class PropertyVarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyVarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefPropertyAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFinalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFinalFinalKeyword_1_0 = (Keyword)cFinalAssignment_1.eContents().get(0);
		private final Assignment cMutableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cMutableMutableKeyword_2_0 = (Keyword)cMutableAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_3_0 = (Alternatives)cGroup_3.eContents().get(0);
		private final Keyword cPropertyKeyword_3_0_0 = (Keyword)cAlternatives_3_0.eContents().get(0);
		private final Assignment cTypeAssignment_3_0_1 = (Assignment)cAlternatives_3_0.eContents().get(1);
		private final RuleCall cTypeTypeRefParserRuleCall_3_0_1_0 = (RuleCall)cTypeAssignment_3_0_1.eContents().get(0);
		private final Assignment cNameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cNamePIDTerminalRuleCall_3_1_0 = (RuleCall)cNameAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cEqualsSignKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cValueExprAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cValueExprExpressionParserRuleCall_4_1_0 = (RuleCall)cValueExprAssignment_4_1.eContents().get(0);
		
		//PropertyVarDeclaration returns be::BExpression:
		//  {be::BDefProperty} final?="final"? mutable?="mutable" (("property"|type=TypeRef)
		//  name=PID) ("=" valueExpr=Expression)?;
		public ParserRule getRule() { return rule; }

		//{be::BDefProperty} final?="final"? mutable?="mutable" (("property"|type=TypeRef)
		//name=PID) ("=" valueExpr=Expression)?
		public Group getGroup() { return cGroup; }

		//{be::BDefProperty}
		public Action getBDefPropertyAction_0() { return cBDefPropertyAction_0; }

		//final?="final"?
		public Assignment getFinalAssignment_1() { return cFinalAssignment_1; }

		//"final"
		public Keyword getFinalFinalKeyword_1_0() { return cFinalFinalKeyword_1_0; }

		//mutable?="mutable"
		public Assignment getMutableAssignment_2() { return cMutableAssignment_2; }

		//"mutable"
		public Keyword getMutableMutableKeyword_2_0() { return cMutableMutableKeyword_2_0; }

		//("property"|type=TypeRef) name=PID
		public Group getGroup_3() { return cGroup_3; }

		//"property"|type=TypeRef
		public Alternatives getAlternatives_3_0() { return cAlternatives_3_0; }

		//"property"
		public Keyword getPropertyKeyword_3_0_0() { return cPropertyKeyword_3_0_0; }

		//type=TypeRef
		public Assignment getTypeAssignment_3_0_1() { return cTypeAssignment_3_0_1; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_3_0_1_0() { return cTypeTypeRefParserRuleCall_3_0_1_0; }

		//name=PID
		public Assignment getNameAssignment_3_1() { return cNameAssignment_3_1; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_3_1_0() { return cNamePIDTerminalRuleCall_3_1_0; }

		//("=" valueExpr=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"="
		public Keyword getEqualsSignKeyword_4_0() { return cEqualsSignKeyword_4_0; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_4_1() { return cValueExprAssignment_4_1; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_4_1_0() { return cValueExprExpressionParserRuleCall_4_1_0; }
	}

	public class SetPropertyOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetPropertyOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFinalAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cFinalFinalKeyword_0_0 = (Keyword)cFinalAssignment_0.eContents().get(0);
		private final Assignment cKeyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKeyPropertyNameParserRuleCall_1_0 = (RuleCall)cKeyAssignment_1.eContents().get(0);
		private final Assignment cOpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOpAssignmentOperatorParserRuleCall_2_0 = (RuleCall)cOpAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SetPropertyOperation:
		//  final?="final"? key=PropertyName op=AssignmentOperator value=Expression ";";
		public ParserRule getRule() { return rule; }

		//final?="final"? key=PropertyName op=AssignmentOperator value=Expression ";"
		public Group getGroup() { return cGroup; }

		//final?="final"?
		public Assignment getFinalAssignment_0() { return cFinalAssignment_0; }

		//"final"
		public Keyword getFinalFinalKeyword_0_0() { return cFinalFinalKeyword_0_0; }

		//key=PropertyName
		public Assignment getKeyAssignment_1() { return cKeyAssignment_1; }

		//PropertyName
		public RuleCall getKeyPropertyNameParserRuleCall_1_0() { return cKeyPropertyNameParserRuleCall_1_0; }

		//op=AssignmentOperator
		public Assignment getOpAssignment_2() { return cOpAssignment_2; }

		//AssignmentOperator
		public RuleCall getOpAssignmentOperatorParserRuleCall_2_0() { return cOpAssignmentOperatorParserRuleCall_2_0; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class UnsetPropertyOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnsetPropertyOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnsetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cKeyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKeyPropertyNameParserRuleCall_1_0 = (RuleCall)cKeyAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//UnsetPropertyOperation:
		//  "unset" key=PropertyName ";";
		public ParserRule getRule() { return rule; }

		//"unset" key=PropertyName ";"
		public Group getGroup() { return cGroup; }

		//"unset"
		public Keyword getUnsetKeyword_0() { return cUnsetKeyword_0; }

		//key=PropertyName
		public Assignment getKeyAssignment_1() { return cKeyAssignment_1; }

		//PropertyName
		public RuleCall getKeyPropertyNameParserRuleCall_1_0() { return cKeyPropertyNameParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class SynchronizationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Synchronization");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPartrefsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPartrefsSynchronizedPartParserRuleCall_0_0 = (RuleCall)cPartrefsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cPartrefsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPartrefsSynchronizedPartParserRuleCall_1_1_0 = (RuleCall)cPartrefsAssignment_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Synchronization:
		//  partrefs+=SynchronizedPart ("," partrefs+=SynchronizedPart)+ ";"; 
		//
		// 
		//	                // TODO: verify at least 2 partrefs
		public ParserRule getRule() { return rule; }

		//partrefs+=SynchronizedPart ("," partrefs+=SynchronizedPart)+ ";"                 // TODO: verify at least 2 partrefs
		public Group getGroup() { return cGroup; }

		//partrefs+=SynchronizedPart
		public Assignment getPartrefsAssignment_0() { return cPartrefsAssignment_0; }

		//SynchronizedPart
		public RuleCall getPartrefsSynchronizedPartParserRuleCall_0_0() { return cPartrefsSynchronizedPartParserRuleCall_0_0; }

		//("," partrefs+=SynchronizedPart)+
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//partrefs+=SynchronizedPart
		public Assignment getPartrefsAssignment_1_1() { return cPartrefsAssignment_1_1; }

		//SynchronizedPart
		public RuleCall getPartrefsSynchronizedPartParserRuleCall_1_1_0() { return cPartrefsSynchronizedPartParserRuleCall_1_1_0; }

		//";"     // TODO: verify at least 2 partrefs
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class SynchronizedPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SynchronizedPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cCompoundNameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cNumberSignKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final RuleCall cPartNameParserRuleCall_0_1_1 = (RuleCall)cGroup_0_1.eContents().get(1);
		private final RuleCall cPartNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SynchronizedPart returns ecore::EString:
		//  CompoundName ("#" PartName)?|PartName;
		public ParserRule getRule() { return rule; }

		//CompoundName ("#" PartName)?|PartName
		public Alternatives getAlternatives() { return cAlternatives; }

		//CompoundName ("#" PartName)?
		public Group getGroup_0() { return cGroup_0; }

		//CompoundName
		public RuleCall getCompoundNameParserRuleCall_0_0() { return cCompoundNameParserRuleCall_0_0; }

		//("#" PartName)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"#"
		public Keyword getNumberSignKeyword_0_1_0() { return cNumberSignKeyword_0_1_0; }

		//PartName
		public RuleCall getPartNameParserRuleCall_0_1_1() { return cPartNameParserRuleCall_0_1_1; }

		//PartName
		public RuleCall getPartNameParserRuleCall_1() { return cPartNameParserRuleCall_1; }
	}

	public class PathGroupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathGroup");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPathsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPathsPathVectorElementParserRuleCall_0_0 = (RuleCall)cPathsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cAnnotationsKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cAnnotationsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAnnotationsPropertySetParserRuleCall_1_1_0 = (RuleCall)cAnnotationsAssignment_1_1.eContents().get(0);
		
		//PathGroup:
		//  paths+=PathVectorElement+ ("annotations" annotations=PropertySet)?;
		public ParserRule getRule() { return rule; }

		//paths+=PathVectorElement+ ("annotations" annotations=PropertySet)?
		public Group getGroup() { return cGroup; }

		//paths+=PathVectorElement+
		public Assignment getPathsAssignment_0() { return cPathsAssignment_0; }

		//PathVectorElement
		public RuleCall getPathsPathVectorElementParserRuleCall_0_0() { return cPathsPathVectorElementParserRuleCall_0_0; }

		//("annotations" annotations=PropertySet)?
		public Group getGroup_1() { return cGroup_1; }

		//"annotations"
		public Keyword getAnnotationsKeyword_1_0() { return cAnnotationsKeyword_1_0; }

		//annotations=PropertySet
		public Assignment getAnnotationsAssignment_1_1() { return cAnnotationsAssignment_1_1; }

		//PropertySet
		public RuleCall getAnnotationsPropertySetParserRuleCall_1_1_0() { return cAnnotationsPropertySetParserRuleCall_1_1_0; }
	}

	public class PathVectorElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathVectorElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFilteredPathVectorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBasePathVectorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUnbasedPathVectorParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PathVectorElement:
		//  FilteredPathVector|BasePathVector|UnbasedPathVector;
		public ParserRule getRule() { return rule; }

		//FilteredPathVector|BasePathVector|UnbasedPathVector
		public Alternatives getAlternatives() { return cAlternatives; }

		//FilteredPathVector
		public RuleCall getFilteredPathVectorParserRuleCall_0() { return cFilteredPathVectorParserRuleCall_0; }

		//BasePathVector
		public RuleCall getBasePathVectorParserRuleCall_1() { return cBasePathVectorParserRuleCall_1; }

		//UnbasedPathVector
		public RuleCall getUnbasedPathVectorParserRuleCall_2() { return cUnbasedPathVectorParserRuleCall_2; }
	}

	public class FilteredPathVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FilteredPathVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFilterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_1_0 = (RuleCall)cFilterAssignment_1.eContents().get(0);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cBodyAlternatives_2_0 = (Alternatives)cBodyAssignment_2.eContents().get(0);
		private final RuleCall cBodyBasePathVectorParserRuleCall_2_0_0 = (RuleCall)cBodyAlternatives_2_0.eContents().get(0);
		private final RuleCall cBodyUnbasedPathVectorParserRuleCall_2_0_1 = (RuleCall)cBodyAlternatives_2_0.eContents().get(1);
		private final RuleCall cBodyCompoundPathVectorParserRuleCall_2_0_2 = (RuleCall)cBodyAlternatives_2_0.eContents().get(2);
		
		//FilteredPathVector:
		//  "when" filter=Filter body=( BasePathVector | UnbasedPathVector | CompoundPathVector );
		public ParserRule getRule() { return rule; }

		//"when" filter=Filter body=( BasePathVector | UnbasedPathVector | CompoundPathVector )
		public Group getGroup() { return cGroup; }

		//"when"
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		//filter=Filter
		public Assignment getFilterAssignment_1() { return cFilterAssignment_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_1_0() { return cFilterFilterParserRuleCall_1_0; }

		//body=( BasePathVector | UnbasedPathVector | CompoundPathVector )
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//BasePathVector|UnbasedPathVector|CompoundPathVector
		public Alternatives getBodyAlternatives_2_0() { return cBodyAlternatives_2_0; }

		//BasePathVector
		public RuleCall getBodyBasePathVectorParserRuleCall_2_0_0() { return cBodyBasePathVectorParserRuleCall_2_0_0; }

		//UnbasedPathVector
		public RuleCall getBodyUnbasedPathVectorParserRuleCall_2_0_1() { return cBodyUnbasedPathVectorParserRuleCall_2_0_1; }

		//CompoundPathVector
		public RuleCall getBodyCompoundPathVectorParserRuleCall_2_0_2() { return cBodyCompoundPathVectorParserRuleCall_2_0_2; }
	}

	public class BasePathVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasePathVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cBasePathAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cBasePathPathParserRuleCall_0_0 = (RuleCall)cBasePathAssignment_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cPathsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cPathsPathParserRuleCall_2_0_0 = (RuleCall)cPathsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cPathsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cPathsPathParserRuleCall_2_1_1_0 = (RuleCall)cPathsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BasePathVector returns PathVector:
		//  basePath=Path "[" (paths+=Path ("," paths+=Path)*)? "]" ";";
		public ParserRule getRule() { return rule; }

		//basePath=Path "[" (paths+=Path ("," paths+=Path)*)? "]" ";"
		public Group getGroup() { return cGroup; }

		//basePath=Path
		public Assignment getBasePathAssignment_0() { return cBasePathAssignment_0; }

		//Path
		public RuleCall getBasePathPathParserRuleCall_0_0() { return cBasePathPathParserRuleCall_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//(paths+=Path ("," paths+=Path)*)?
		public Group getGroup_2() { return cGroup_2; }

		//paths+=Path
		public Assignment getPathsAssignment_2_0() { return cPathsAssignment_2_0; }

		//Path
		public RuleCall getPathsPathParserRuleCall_2_0_0() { return cPathsPathParserRuleCall_2_0_0; }

		//("," paths+=Path)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//paths+=Path
		public Assignment getPathsAssignment_2_1_1() { return cPathsAssignment_2_1_1; }

		//Path
		public RuleCall getPathsPathParserRuleCall_2_1_1_0() { return cPathsPathParserRuleCall_2_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class UnbasedPathVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnbasedPathVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPathsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPathsPathParserRuleCall_0_0 = (RuleCall)cPathsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cPathsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPathsPathParserRuleCall_1_1_0 = (RuleCall)cPathsAssignment_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//UnbasedPathVector returns PathVector:
		//  paths+=Path ("," paths+=Path)* ";";
		public ParserRule getRule() { return rule; }

		//paths+=Path ("," paths+=Path)* ";"
		public Group getGroup() { return cGroup; }

		//paths+=Path
		public Assignment getPathsAssignment_0() { return cPathsAssignment_0; }

		//Path
		public RuleCall getPathsPathParserRuleCall_0_0() { return cPathsPathParserRuleCall_0_0; }

		//("," paths+=Path)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//paths+=Path
		public Assignment getPathsAssignment_1_1() { return cPathsAssignment_1_1; }

		//Path
		public RuleCall getPathsPathParserRuleCall_1_1_0() { return cPathsPathParserRuleCall_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class CompoundPathVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundPathVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCompoundPathVectorAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyPathVectorElementParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//CompoundPathVector:
		//  {CompoundPathVector} "{" body+=PathVectorElement* "}"; 
		//	
		//              
		//
		//// A path can be written without quotes if it consists of safe chars
		public ParserRule getRule() { return rule; }

		//{CompoundPathVector} "{" body+=PathVectorElement* "}"
		public Group getGroup() { return cGroup; }

		//{CompoundPathVector}
		public Action getCompoundPathVectorAction_0() { return cCompoundPathVectorAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//body+=PathVectorElement*
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//PathVectorElement
		public RuleCall getBodyPathVectorElementParserRuleCall_2_0() { return cBodyPathVectorElementParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Path");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cQIDParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cSolidusKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final RuleCall cQIDParserRuleCall_1_2_1 = (RuleCall)cGroup_1_2.eContents().get(1);
		private final Keyword cSolidusKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Path returns ecore::EString hidden ( ):
		//  STRING|"/"? QID ("/" QID)* "/"?; 
		//
		//// A path can be written without quotes if it consists of safe chars
		public ParserRule getRule() { return rule; }

		//STRING|"/"? QID ("/" QID)* "/"? 
		//
		//// A path can be written without quotes if it consists of safe chars
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//"/"? QID ("/" QID)* "/"?
		public Group getGroup_1() { return cGroup_1; }

		//"/"?
		public Keyword getSolidusKeyword_1_0() { return cSolidusKeyword_1_0; }

		//QID
		public RuleCall getQIDParserRuleCall_1_1() { return cQIDParserRuleCall_1_1; }

		//("/" QID)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"/"
		public Keyword getSolidusKeyword_1_2_0() { return cSolidusKeyword_1_2_0; }

		//QID
		public RuleCall getQIDParserRuleCall_1_2_1() { return cQIDParserRuleCall_1_2_1; }

		//"/"?
		public Keyword getSolidusKeyword_1_3() { return cSolidusKeyword_1_3; }
	}

	public class PrerequisiteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Prerequisite");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cFilterAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFilterFilterParserRuleCall_0_1_0 = (RuleCall)cFilterAssignment_0_1.eContents().get(0);
		private final Assignment cWithClauseAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWithClauseWithClauseParserRuleCall_1_0 = (RuleCall)cWithClauseAssignment_1.eContents().get(0);
		private final Assignment cPartReferenceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPartReferencePrerequisiteEntryParserRuleCall_2_0 = (RuleCall)cPartReferenceAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cAsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cAliasAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cAliasIDTerminalRuleCall_3_1_0 = (RuleCall)cAliasAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Prerequisite:
		//  ("when" filter=Filter)? withClause=WithClause? partReference=PrerequisiteEntry ("as"
		//  alias=ID)? ";"; 
		//
		//   
		//		    
		//		    
		//		 
		//		    
		//	
		//
		//// Validation checks that there is at least one of references, properties or concern.
		public ParserRule getRule() { return rule; }

		//("when" filter=Filter)? withClause=WithClause? partReference=PrerequisiteEntry ("as"
		//alias=ID)? ";"
		public Group getGroup() { return cGroup; }

		//("when" filter=Filter)?
		public Group getGroup_0() { return cGroup_0; }

		//"when"
		public Keyword getWhenKeyword_0_0() { return cWhenKeyword_0_0; }

		//filter=Filter
		public Assignment getFilterAssignment_0_1() { return cFilterAssignment_0_1; }

		//Filter
		public RuleCall getFilterFilterParserRuleCall_0_1_0() { return cFilterFilterParserRuleCall_0_1_0; }

		//withClause=WithClause?
		public Assignment getWithClauseAssignment_1() { return cWithClauseAssignment_1; }

		//WithClause
		public RuleCall getWithClauseWithClauseParserRuleCall_1_0() { return cWithClauseWithClauseParserRuleCall_1_0; }

		//partReference=PrerequisiteEntry
		public Assignment getPartReferenceAssignment_2() { return cPartReferenceAssignment_2; }

		//PrerequisiteEntry
		public RuleCall getPartReferencePrerequisiteEntryParserRuleCall_2_0() { return cPartReferencePrerequisiteEntryParserRuleCall_2_0; }

		//("as" alias=ID)?
		public Group getGroup_3() { return cGroup_3; }

		//"as"
		public Keyword getAsKeyword_3_0() { return cAsKeyword_3_0; }

		//alias=ID
		public Assignment getAliasAssignment_3_1() { return cAliasAssignment_3_1; }

		//ID
		public RuleCall getAliasIDTerminalRuleCall_3_1_0() { return cAliasIDTerminalRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class WithClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WithClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWithClauseAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWithKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cReferencesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cReferencesExpressionParserRuleCall_2_1_0 = (RuleCall)cReferencesAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cReferencesAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cReferencesExpressionParserRuleCall_2_2_1_0 = (RuleCall)cReferencesAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cPropertiesKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cPropertiesAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cPropertiesPropertySetParserRuleCall_3_0_1_0 = (RuleCall)cPropertiesAssignment_3_0_1.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Keyword cConcernKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cConcernAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cConcernConcernBlockParserRuleCall_3_1_1_0 = (RuleCall)cConcernAssignment_3_1_1.eContents().get(0);
		
		//WithClause:
		//  {WithClause} "with" ("(" references+=Expression ("," references+=Expression)* ")")? (
		//  "properties" properties+=PropertySet|"concern" concern+=ConcernBlock)*; 
		//
		//// Validation checks that there is at least one of references, properties or concern.
		public ParserRule getRule() { return rule; }

		//{WithClause} "with" ("(" references+=Expression ("," references+=Expression)* ")")? (
		//"properties" properties+=PropertySet|"concern" concern+=ConcernBlock)*
		public Group getGroup() { return cGroup; }

		//{WithClause}
		public Action getWithClauseAction_0() { return cWithClauseAction_0; }

		//"with"
		public Keyword getWithKeyword_1() { return cWithKeyword_1; }

		//("(" references+=Expression ("," references+=Expression)* ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//references+=Expression
		public Assignment getReferencesAssignment_2_1() { return cReferencesAssignment_2_1; }

		//Expression
		public RuleCall getReferencesExpressionParserRuleCall_2_1_0() { return cReferencesExpressionParserRuleCall_2_1_0; }

		//("," references+=Expression)*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//references+=Expression
		public Assignment getReferencesAssignment_2_2_1() { return cReferencesAssignment_2_2_1; }

		//Expression
		public RuleCall getReferencesExpressionParserRuleCall_2_2_1_0() { return cReferencesExpressionParserRuleCall_2_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }

		//("properties" properties+=PropertySet|"concern" concern+=ConcernBlock)*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//"properties" properties+=PropertySet
		public Group getGroup_3_0() { return cGroup_3_0; }

		//"properties"
		public Keyword getPropertiesKeyword_3_0_0() { return cPropertiesKeyword_3_0_0; }

		//properties+=PropertySet
		public Assignment getPropertiesAssignment_3_0_1() { return cPropertiesAssignment_3_0_1; }

		//PropertySet
		public RuleCall getPropertiesPropertySetParserRuleCall_3_0_1_0() { return cPropertiesPropertySetParserRuleCall_3_0_1_0; }

		//"concern" concern+=ConcernBlock
		public Group getGroup_3_1() { return cGroup_3_1; }

		//"concern"
		public Keyword getConcernKeyword_3_1_0() { return cConcernKeyword_3_1_0; }

		//concern+=ConcernBlock
		public Assignment getConcernAssignment_3_1_1() { return cConcernAssignment_3_1_1; }

		//ConcernBlock
		public RuleCall getConcernConcernBlockParserRuleCall_3_1_1_0() { return cConcernConcernBlockParserRuleCall_3_1_1_0; }
	}

	public class PrerequisiteEntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrerequisiteEntry");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDirectPartReferemceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCapabilityReferencedPartParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCompoundReferencesParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PrerequisiteEntry:
		//  DirectPartReferemce|CapabilityReferencedPart|CompoundReferences;
		public ParserRule getRule() { return rule; }

		//DirectPartReferemce|CapabilityReferencedPart|CompoundReferences
		public Alternatives getAlternatives() { return cAlternatives; }

		//DirectPartReferemce
		public RuleCall getDirectPartReferemceParserRuleCall_0() { return cDirectPartReferemceParserRuleCall_0; }

		//CapabilityReferencedPart
		public RuleCall getCapabilityReferencedPartParserRuleCall_1() { return cCapabilityReferencedPartParserRuleCall_1; }

		//CompoundReferences
		public RuleCall getCompoundReferencesParserRuleCall_2() { return cCompoundReferencesParserRuleCall_2; }
	}

	public class DirectPartReferemceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DirectPartReferemce");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cUnitAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cUnitQIDParserRuleCall_0_0_0 = (RuleCall)cUnitAssignment_0_0.eContents().get(0);
		private final Assignment cUnitAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cUnitUnitKeyword_0_1_0 = (Keyword)cUnitAssignment_0_1.eContents().get(0);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBuilderAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBuilderPartNameParserRuleCall_2_0 = (RuleCall)cBuilderAssignment_2.eContents().get(0);
		private final Assignment cParametersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParametersParameterListParserRuleCall_3_0 = (RuleCall)cParametersAssignment_3.eContents().get(0);
		
		//DirectPartReferemce:
		//  (unit=QID|unit="unit")? "#" builder=PartName parameters=ParameterList?;
		public ParserRule getRule() { return rule; }

		//(unit=QID|unit="unit")? "#" builder=PartName parameters=ParameterList?
		public Group getGroup() { return cGroup; }

		//(unit=QID|unit="unit")?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//unit=QID
		public Assignment getUnitAssignment_0_0() { return cUnitAssignment_0_0; }

		//QID
		public RuleCall getUnitQIDParserRuleCall_0_0_0() { return cUnitQIDParserRuleCall_0_0_0; }

		//unit="unit"
		public Assignment getUnitAssignment_0_1() { return cUnitAssignment_0_1; }

		//"unit"
		public Keyword getUnitUnitKeyword_0_1_0() { return cUnitUnitKeyword_0_1_0; }

		//"#"
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }

		//builder=PartName
		public Assignment getBuilderAssignment_2() { return cBuilderAssignment_2; }

		//PartName
		public RuleCall getBuilderPartNameParserRuleCall_2_0() { return cBuilderPartNameParserRuleCall_2_0; }

		//parameters=ParameterList?
		public Assignment getParametersAssignment_3() { return cParametersAssignment_3; }

		//ParameterList
		public RuleCall getParametersParameterListParserRuleCall_3_0() { return cParametersParameterListParserRuleCall_3_0; }
	}

	public class CapabilityReferencedPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CapabilityReferencedPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCapabilityAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCapabilityCapabilityParserRuleCall_0_0 = (RuleCall)cCapabilityAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRangeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRangeVersionRangeParserRuleCall_1_1_0 = (RuleCall)cRangeAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cNumberSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPartNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPartNamePartNameParserRuleCall_2_1_0 = (RuleCall)cPartNameAssignment_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParametersParameterListParserRuleCall_3_0 = (RuleCall)cParametersAssignment_3.eContents().get(0);
		
		//CapabilityReferencedPart:
		//  capability=Capability ("/" range=VersionRange)? ("#" partName=PartName)? parameters=
		//  ParameterList?;
		public ParserRule getRule() { return rule; }

		//capability=Capability ("/" range=VersionRange)? ("#" partName=PartName)? parameters=
		//ParameterList?
		public Group getGroup() { return cGroup; }

		//capability=Capability
		public Assignment getCapabilityAssignment_0() { return cCapabilityAssignment_0; }

		//Capability
		public RuleCall getCapabilityCapabilityParserRuleCall_0_0() { return cCapabilityCapabilityParserRuleCall_0_0; }

		//("/" range=VersionRange)?
		public Group getGroup_1() { return cGroup_1; }

		//"/"
		public Keyword getSolidusKeyword_1_0() { return cSolidusKeyword_1_0; }

		//range=VersionRange
		public Assignment getRangeAssignment_1_1() { return cRangeAssignment_1_1; }

		//VersionRange
		public RuleCall getRangeVersionRangeParserRuleCall_1_1_0() { return cRangeVersionRangeParserRuleCall_1_1_0; }

		//("#" partName=PartName)?
		public Group getGroup_2() { return cGroup_2; }

		//"#"
		public Keyword getNumberSignKeyword_2_0() { return cNumberSignKeyword_2_0; }

		//partName=PartName
		public Assignment getPartNameAssignment_2_1() { return cPartNameAssignment_2_1; }

		//PartName
		public RuleCall getPartNamePartNameParserRuleCall_2_1_0() { return cPartNamePartNameParserRuleCall_2_1_0; }

		//parameters=ParameterList?
		public Assignment getParametersAssignment_3() { return cParametersAssignment_3; }

		//ParameterList
		public RuleCall getParametersParameterListParserRuleCall_3_0() { return cParametersParameterListParserRuleCall_3_0; }
	}

	public class CompoundReferencesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundReferences");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCompounddReferencesAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPrerequisitesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPrerequisitesPrerequisiteParserRuleCall_2_0 = (RuleCall)cPrerequisitesAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//CompoundReferences:
		//  {CompounddReferences} "{" prerequisites+=Prerequisite* "}";
		public ParserRule getRule() { return rule; }

		//{CompounddReferences} "{" prerequisites+=Prerequisite* "}"
		public Group getGroup() { return cGroup; }

		//{CompounddReferences}
		public Action getCompounddReferencesAction_0() { return cCompounddReferencesAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//prerequisites+=Prerequisite*
		public Assignment getPrerequisitesAssignment_2() { return cPrerequisitesAssignment_2; }

		//Prerequisite
		public RuleCall getPrerequisitesPrerequisiteParserRuleCall_2_0() { return cPrerequisitesPrerequisiteParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class BuilderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Builder");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuilderAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Assignment cVisibilityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVisibilityVisibilityEnumRuleCall_2_0 = (RuleCall)cVisibilityAssignment_2.eContents().get(0);
		private final Assignment cExecutionModeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExecutionModeExecutionModeEnumRuleCall_3_0 = (RuleCall)cExecutionModeAssignment_3.eContents().get(0);
		private final Assignment cFinalAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cFinalFinalKeyword_4_0 = (Keyword)cFinalAssignment_4.eContents().get(0);
		private final Assignment cCachedAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cCachedCachedKeyword_5_0 = (Keyword)cCachedAssignment_5.eContents().get(0);
		private final Keyword cBuilderKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cNameAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cNamePartNameParserRuleCall_7_0 = (RuleCall)cNameAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cLeftParenthesisKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cParamsAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cParamsParameterDeclarationListParserRuleCall_8_1_0 = (RuleCall)cParamsAssignment_8_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cProvidesKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cProvidedCapabilitiesAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_0 = (RuleCall)cProvidedCapabilitiesAssignment_9_1.eContents().get(0);
		private final Group cGroup_9_2 = (Group)cGroup_9.eContents().get(2);
		private final Keyword cCommaKeyword_9_2_0 = (Keyword)cGroup_9_2.eContents().get(0);
		private final Assignment cProvidedCapabilitiesAssignment_9_2_1 = (Assignment)cGroup_9_2.eContents().get(1);
		private final RuleCall cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_2_1_0 = (RuleCall)cProvidedCapabilitiesAssignment_9_2_1.eContents().get(0);
		private final Assignment cPreConditionAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cPreConditionPreConditionParserRuleCall_10_0 = (RuleCall)cPreConditionAssignment_10.eContents().get(0);
		private final Assignment cPostConditionAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final RuleCall cPostConditionPostConditionParserRuleCall_11_0 = (RuleCall)cPostConditionAssignment_11.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final Group cGroup_13 = (Group)cGroup.eContents().get(13);
		private final Keyword cDefaultKeyword_13_0 = (Keyword)cGroup_13.eContents().get(0);
		private final Keyword cPropertiesKeyword_13_1 = (Keyword)cGroup_13.eContents().get(1);
		private final Assignment cPropertiesAssignment_13_2 = (Assignment)cGroup_13.eContents().get(2);
		private final RuleCall cPropertiesPropertySetParserRuleCall_13_2_0 = (RuleCall)cPropertiesAssignment_13_2.eContents().get(0);
		private final Assignment cInputAssignment_14 = (Assignment)cGroup.eContents().get(14);
		private final RuleCall cInputBuilderInputParserRuleCall_14_0 = (RuleCall)cInputAssignment_14.eContents().get(0);
		private final Assignment cOutputAssignment_15 = (Assignment)cGroup.eContents().get(15);
		private final RuleCall cOutputBuilderOutputParserRuleCall_15_0 = (RuleCall)cOutputAssignment_15.eContents().get(0);
		private final Assignment cExpressionListAssignment_16 = (Assignment)cGroup.eContents().get(16);
		private final RuleCall cExpressionListExpressionListParserRuleCall_16_0 = (RuleCall)cExpressionListAssignment_16.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_17 = (Keyword)cGroup.eContents().get(17);
		
		//Builder:
		//  {Builder} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
		//  ExecutionMode? final?="final"? cached?="cached"? "builder" name=PartName ("(" params=
		//  ParameterDeclarationList ")")? ("provides" providedCapabilities+=ProvidedCapability
		//  ("," providedCapabilities+=ProvidedCapability)*)? preCondition=PreCondition?
		//  postCondition=PostCondition? "{" ("default" "properties" properties=PropertySet)?
		//  input=BuilderInput? output=BuilderOutput? expressionList=ExpressionList? "}";
		public ParserRule getRule() { return rule; }

		//{Builder} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
		//ExecutionMode? final?="final"? cached?="cached"? "builder" name=PartName ("(" params=
		//ParameterDeclarationList ")")? ("provides" providedCapabilities+=ProvidedCapability
		//("," providedCapabilities+=ProvidedCapability)*)? preCondition=PreCondition?
		//postCondition=PostCondition? "{" ("default" "properties" properties=PropertySet)?
		//input=BuilderInput? output=BuilderOutput? expressionList=ExpressionList? "}"
		public Group getGroup() { return cGroup; }

		//{Builder}
		public Action getBuilderAction_0() { return cBuilderAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//visibility=Visibility?
		public Assignment getVisibilityAssignment_2() { return cVisibilityAssignment_2; }

		//Visibility
		public RuleCall getVisibilityVisibilityEnumRuleCall_2_0() { return cVisibilityVisibilityEnumRuleCall_2_0; }

		//executionMode=ExecutionMode?
		public Assignment getExecutionModeAssignment_3() { return cExecutionModeAssignment_3; }

		//ExecutionMode
		public RuleCall getExecutionModeExecutionModeEnumRuleCall_3_0() { return cExecutionModeExecutionModeEnumRuleCall_3_0; }

		//final?="final"?
		public Assignment getFinalAssignment_4() { return cFinalAssignment_4; }

		//"final"
		public Keyword getFinalFinalKeyword_4_0() { return cFinalFinalKeyword_4_0; }

		//cached?="cached"?
		public Assignment getCachedAssignment_5() { return cCachedAssignment_5; }

		//"cached"
		public Keyword getCachedCachedKeyword_5_0() { return cCachedCachedKeyword_5_0; }

		//"builder"
		public Keyword getBuilderKeyword_6() { return cBuilderKeyword_6; }

		//name=PartName
		public Assignment getNameAssignment_7() { return cNameAssignment_7; }

		//PartName
		public RuleCall getNamePartNameParserRuleCall_7_0() { return cNamePartNameParserRuleCall_7_0; }

		//("(" params=ParameterDeclarationList ")")?
		public Group getGroup_8() { return cGroup_8; }

		//"("
		public Keyword getLeftParenthesisKeyword_8_0() { return cLeftParenthesisKeyword_8_0; }

		//params=ParameterDeclarationList
		public Assignment getParamsAssignment_8_1() { return cParamsAssignment_8_1; }

		//ParameterDeclarationList
		public RuleCall getParamsParameterDeclarationListParserRuleCall_8_1_0() { return cParamsParameterDeclarationListParserRuleCall_8_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_8_2() { return cRightParenthesisKeyword_8_2; }

		//("provides" providedCapabilities+=ProvidedCapability ("," providedCapabilities+=
		//ProvidedCapability)*)?
		public Group getGroup_9() { return cGroup_9; }

		//"provides"
		public Keyword getProvidesKeyword_9_0() { return cProvidesKeyword_9_0; }

		//providedCapabilities+=ProvidedCapability
		public Assignment getProvidedCapabilitiesAssignment_9_1() { return cProvidedCapabilitiesAssignment_9_1; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_0() { return cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_1_0; }

		//("," providedCapabilities+=ProvidedCapability)*
		public Group getGroup_9_2() { return cGroup_9_2; }

		//","
		public Keyword getCommaKeyword_9_2_0() { return cCommaKeyword_9_2_0; }

		//providedCapabilities+=ProvidedCapability
		public Assignment getProvidedCapabilitiesAssignment_9_2_1() { return cProvidedCapabilitiesAssignment_9_2_1; }

		//ProvidedCapability
		public RuleCall getProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_2_1_0() { return cProvidedCapabilitiesProvidedCapabilityParserRuleCall_9_2_1_0; }

		//preCondition=PreCondition?
		public Assignment getPreConditionAssignment_10() { return cPreConditionAssignment_10; }

		//PreCondition
		public RuleCall getPreConditionPreConditionParserRuleCall_10_0() { return cPreConditionPreConditionParserRuleCall_10_0; }

		//postCondition=PostCondition?
		public Assignment getPostConditionAssignment_11() { return cPostConditionAssignment_11; }

		//PostCondition
		public RuleCall getPostConditionPostConditionParserRuleCall_11_0() { return cPostConditionPostConditionParserRuleCall_11_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_12() { return cLeftCurlyBracketKeyword_12; }

		//("default" "properties" properties=PropertySet)?
		public Group getGroup_13() { return cGroup_13; }

		//"default"
		public Keyword getDefaultKeyword_13_0() { return cDefaultKeyword_13_0; }

		//"properties"
		public Keyword getPropertiesKeyword_13_1() { return cPropertiesKeyword_13_1; }

		//properties=PropertySet
		public Assignment getPropertiesAssignment_13_2() { return cPropertiesAssignment_13_2; }

		//PropertySet
		public RuleCall getPropertiesPropertySetParserRuleCall_13_2_0() { return cPropertiesPropertySetParserRuleCall_13_2_0; }

		//input=BuilderInput?
		public Assignment getInputAssignment_14() { return cInputAssignment_14; }

		//BuilderInput
		public RuleCall getInputBuilderInputParserRuleCall_14_0() { return cInputBuilderInputParserRuleCall_14_0; }

		//output=BuilderOutput?
		public Assignment getOutputAssignment_15() { return cOutputAssignment_15; }

		//BuilderOutput
		public RuleCall getOutputBuilderOutputParserRuleCall_15_0() { return cOutputBuilderOutputParserRuleCall_15_0; }

		//expressionList=ExpressionList?
		public Assignment getExpressionListAssignment_16() { return cExpressionListAssignment_16; }

		//ExpressionList
		public RuleCall getExpressionListExpressionListParserRuleCall_16_0() { return cExpressionListExpressionListParserRuleCall_16_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_17() { return cRightCurlyBracketKeyword_17; }
	}

	public class ParameterListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBParameterListAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParametersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParametersFirstParameterParserRuleCall_1_0 = (RuleCall)cParametersAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParametersAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParametersFirstParameterParserRuleCall_2_1_0 = (RuleCall)cParametersAssignment_2_1.eContents().get(0);
		
		//ParameterList returns be::BParameterList:
		//  {be::BParameterList} parameters+=FirstParameter ("," parameters+=FirstParameter)*;
		public ParserRule getRule() { return rule; }

		//{be::BParameterList} parameters+=FirstParameter ("," parameters+=FirstParameter)*
		public Group getGroup() { return cGroup; }

		//{be::BParameterList}
		public Action getBParameterListAction_0() { return cBParameterListAction_0; }

		//parameters+=FirstParameter
		public Assignment getParametersAssignment_1() { return cParametersAssignment_1; }

		//FirstParameter
		public RuleCall getParametersFirstParameterParserRuleCall_1_0() { return cParametersFirstParameterParserRuleCall_1_0; }

		//("," parameters+=FirstParameter)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//parameters+=FirstParameter
		public Assignment getParametersAssignment_2_1() { return cParametersAssignment_2_1; }

		//FirstParameter
		public RuleCall getParametersFirstParameterParserRuleCall_2_1_0() { return cParametersFirstParameterParserRuleCall_2_1_0; }
	}

	public class FirstParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FirstParameter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClosureParameterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FirstParameter returns be::BParameter:
		//  ClosureParameter|Parameter;
		public ParserRule getRule() { return rule; }

		//ClosureParameter|Parameter
		public Alternatives getAlternatives() { return cAlternatives; }

		//ClosureParameter
		public RuleCall getClosureParameterParserRuleCall_0() { return cClosureParameterParserRuleCall_0; }

		//Parameter
		public RuleCall getParameterParserRuleCall_1() { return cParameterParserRuleCall_1; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//Parameter returns be::BParameter:
		//  {be::BParameter} expr=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BParameter} expr=Expression
		public Group getGroup() { return cGroup; }

		//{be::BParameter}
		public Action getBParameterAction_0() { return cBParameterAction_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
	}

	public class ClosureParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClosureParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprClosureExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//ClosureParameter returns be::BParameter:
		//  {be::BParameter} expr=ClosureExpression;
		public ParserRule getRule() { return rule; }

		//{be::BParameter} expr=ClosureExpression
		public Group getGroup() { return cGroup; }

		//{be::BParameter}
		public Action getBParameterAction_0() { return cBParameterAction_0; }

		//expr=ClosureExpression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//ClosureExpression
		public RuleCall getExprClosureExpressionParserRuleCall_1_0() { return cExprClosureExpressionParserRuleCall_1_0; }
	}

	public class ParameterDeclarationListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterDeclarationList");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cParamsAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cParamsParameterDeclarationParserRuleCall_0_0_0 = (RuleCall)cParamsAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cCommaKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cParamsAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cParamsParameterDeclarationParserRuleCall_0_1_1_0 = (RuleCall)cParamsAssignment_0_1_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cParamsAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cParamsParameterDeclarationEllipseParserRuleCall_0_2_1_0 = (RuleCall)cParamsAssignment_0_2_1.eContents().get(0);
		private final Assignment cParamsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cParamsParameterDeclarationEllipseParserRuleCall_1_0 = (RuleCall)cParamsAssignment_1.eContents().get(0);
		
		//ParameterDeclarationList:
		//  params+=ParameterDeclaration ("," params+=ParameterDeclaration)* ("," params+=
		//  ParameterDeclarationEllipse)?|params+=ParameterDeclarationEllipse;
		public ParserRule getRule() { return rule; }

		//params+=ParameterDeclaration ("," params+=ParameterDeclaration)* ("," params+=
		//ParameterDeclarationEllipse)?|params+=ParameterDeclarationEllipse
		public Alternatives getAlternatives() { return cAlternatives; }

		//params+=ParameterDeclaration ("," params+=ParameterDeclaration)* ("," params+=
		//ParameterDeclarationEllipse)?
		public Group getGroup_0() { return cGroup_0; }

		//params+=ParameterDeclaration
		public Assignment getParamsAssignment_0_0() { return cParamsAssignment_0_0; }

		//ParameterDeclaration
		public RuleCall getParamsParameterDeclarationParserRuleCall_0_0_0() { return cParamsParameterDeclarationParserRuleCall_0_0_0; }

		//("," params+=ParameterDeclaration)*
		public Group getGroup_0_1() { return cGroup_0_1; }

		//","
		public Keyword getCommaKeyword_0_1_0() { return cCommaKeyword_0_1_0; }

		//params+=ParameterDeclaration
		public Assignment getParamsAssignment_0_1_1() { return cParamsAssignment_0_1_1; }

		//ParameterDeclaration
		public RuleCall getParamsParameterDeclarationParserRuleCall_0_1_1_0() { return cParamsParameterDeclarationParserRuleCall_0_1_1_0; }

		//("," params+=ParameterDeclarationEllipse)?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//","
		public Keyword getCommaKeyword_0_2_0() { return cCommaKeyword_0_2_0; }

		//params+=ParameterDeclarationEllipse
		public Assignment getParamsAssignment_0_2_1() { return cParamsAssignment_0_2_1; }

		//ParameterDeclarationEllipse
		public RuleCall getParamsParameterDeclarationEllipseParserRuleCall_0_2_1_0() { return cParamsParameterDeclarationEllipseParserRuleCall_0_2_1_0; }

		//params+=ParameterDeclarationEllipse
		public Assignment getParamsAssignment_1() { return cParamsAssignment_1; }

		//ParameterDeclarationEllipse
		public RuleCall getParamsParameterDeclarationEllipseParserRuleCall_1_0() { return cParamsParameterDeclarationEllipseParserRuleCall_1_0; }
	}

	public class ParameterDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBParameterDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTypeTypeRefParserRuleCall_1_0_0 = (RuleCall)cTypeAssignment_1_0.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		
		//ParameterDeclaration returns be::BParameterDeclaration:
		//  {be::BParameterDeclaration} (type=TypeRef? name=ID);
		public ParserRule getRule() { return rule; }

		//{be::BParameterDeclaration} (type=TypeRef? name=ID)
		public Group getGroup() { return cGroup; }

		//{be::BParameterDeclaration}
		public Action getBParameterDeclarationAction_0() { return cBParameterDeclarationAction_0; }

		//type=TypeRef? name=ID
		public Group getGroup_1() { return cGroup_1; }

		//type=TypeRef?
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_1_0_0() { return cTypeTypeRefParserRuleCall_1_0_0; }

		//name=ID
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_1_0() { return cNameIDTerminalRuleCall_1_1_0; }
	}

	public class ParameterDeclarationEllipseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterDeclarationEllipse");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVarargParameterDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFullStopFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeRefParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		
		//ParameterDeclarationEllipse returns ParameterDeclaration:
		//  {VarargParameterDeclaration} "..." type=TypeRef? name=ID;
		public ParserRule getRule() { return rule; }

		//{VarargParameterDeclaration} "..." type=TypeRef? name=ID
		public Group getGroup() { return cGroup; }

		//{VarargParameterDeclaration}
		public Action getVarargParameterDeclarationAction_0() { return cVarargParameterDeclarationAction_0; }

		//"..."
		public Keyword getFullStopFullStopFullStopKeyword_1() { return cFullStopFullStopFullStopKeyword_1; }

		//type=TypeRef?
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_2_0() { return cTypeTypeRefParserRuleCall_2_0; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
	}

	public class InputKeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InputKeyword");
		private final Keyword cInputKeyword = (Keyword)rule.eContents().get(1);
		
		//InputKeyword returns ecore::EString:
		//  "input";
		public ParserRule getRule() { return rule; }

		//"input"
		public Keyword getInputKeyword() { return cInputKeyword; }
	}

	public class OutputKeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OutputKeyword");
		private final Keyword cOutputKeyword = (Keyword)rule.eContents().get(1);
		
		//OutputKeyword returns ecore::EString:
		//  "output";
		public ParserRule getRule() { return rule; }

		//"output"
		public Keyword getOutputKeyword() { return cOutputKeyword; }
	}

	public class BuilderOutputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderOutput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOutputKeywordParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyPathGroupParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BuilderOutput:
		//  OutputKeyword "{" body=PathGroup "}";
		public ParserRule getRule() { return rule; }

		//OutputKeyword "{" body=PathGroup "}"
		public Group getGroup() { return cGroup; }

		//OutputKeyword
		public RuleCall getOutputKeywordParserRuleCall_0() { return cOutputKeywordParserRuleCall_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//body=PathGroup
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//PathGroup
		public RuleCall getBodyPathGroupParserRuleCall_2_0() { return cBodyPathGroupParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class BuilderInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuilderInput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInputKeywordParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cPreConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPreConditionPreConditionParserRuleCall_1_0 = (RuleCall)cPreConditionAssignment_1.eContents().get(0);
		private final Assignment cPostConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPostConditionPostConditionParserRuleCall_2_0 = (RuleCall)cPostConditionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPrerequisitesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPrerequisitesPrerequisiteParserRuleCall_4_0 = (RuleCall)cPrerequisitesAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//BuilderInput:
		//  InputKeyword preCondition=PreCondition? postCondition=PostCondition? "{"
		//  prerequisites+=Prerequisite+ "}";
		public ParserRule getRule() { return rule; }

		//InputKeyword preCondition=PreCondition? postCondition=PostCondition? "{"
		//prerequisites+=Prerequisite+ "}"
		public Group getGroup() { return cGroup; }

		//InputKeyword
		public RuleCall getInputKeywordParserRuleCall_0() { return cInputKeywordParserRuleCall_0; }

		//preCondition=PreCondition?
		public Assignment getPreConditionAssignment_1() { return cPreConditionAssignment_1; }

		//PreCondition
		public RuleCall getPreConditionPreConditionParserRuleCall_1_0() { return cPreConditionPreConditionParserRuleCall_1_0; }

		//postCondition=PostCondition?
		public Assignment getPostConditionAssignment_2() { return cPostConditionAssignment_2; }

		//PostCondition
		public RuleCall getPostConditionPostConditionParserRuleCall_2_0() { return cPostConditionPostConditionParserRuleCall_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//prerequisites+=Prerequisite+
		public Assignment getPrerequisitesAssignment_4() { return cPrerequisitesAssignment_4; }

		//Prerequisite
		public RuleCall getPrerequisitesPrerequisiteParserRuleCall_4_0() { return cPrerequisitesPrerequisiteParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class RepositoryConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RepositoryConfiguration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRepositoryDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cResolutionStrategyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//RepositoryConfiguration:
		//  RepositoryDeclaration|ResolutionStrategy;
		public ParserRule getRule() { return rule; }

		//RepositoryDeclaration|ResolutionStrategy
		public Alternatives getAlternatives() { return cAlternatives; }

		//RepositoryDeclaration
		public RuleCall getRepositoryDeclarationParserRuleCall_0() { return cRepositoryDeclarationParserRuleCall_0; }

		//ResolutionStrategy
		public RuleCall getResolutionStrategyParserRuleCall_1() { return cResolutionStrategyParserRuleCall_1; }
	}

	public class RepositoryDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RepositoryDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDocumentationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_0_0 = (RuleCall)cDocumentationAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cLocationAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cLocationURIParserRuleCall_1_0_0 = (RuleCall)cLocationAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cRepositoryKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cTypeTypeRefParserRuleCall_1_1_1_0 = (RuleCall)cTypeAssignment_1_1_1.eContents().get(0);
		private final Assignment cContextAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContextContextBlockParserRuleCall_2_0 = (RuleCall)cContextAssignment_2.eContents().get(0);
		
		//RepositoryDeclaration:
		//  documentation=DOCUMENTATION? (location=URI|"repository" type=TypeRef) context=
		//  ContextBlock?;
		public ParserRule getRule() { return rule; }

		//documentation=DOCUMENTATION? (location=URI|"repository" type=TypeRef) context=
		//ContextBlock?
		public Group getGroup() { return cGroup; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_0() { return cDocumentationAssignment_0; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_0_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_0_0; }

		//location=URI|"repository" type=TypeRef
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//location=URI
		public Assignment getLocationAssignment_1_0() { return cLocationAssignment_1_0; }

		//URI
		public RuleCall getLocationURIParserRuleCall_1_0_0() { return cLocationURIParserRuleCall_1_0_0; }

		//"repository" type=TypeRef
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"repository"
		public Keyword getRepositoryKeyword_1_1_0() { return cRepositoryKeyword_1_1_0; }

		//type=TypeRef
		public Assignment getTypeAssignment_1_1_1() { return cTypeAssignment_1_1_1; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_1_1_1_0() { return cTypeTypeRefParserRuleCall_1_1_1_0; }

		//context=ContextBlock?
		public Assignment getContextAssignment_2() { return cContextAssignment_2; }

		//ContextBlock
		public RuleCall getContextContextBlockParserRuleCall_2_0() { return cContextContextBlockParserRuleCall_2_0; }
	}

	public class ResolutionStrategyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ResolutionStrategy");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStrategyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cStrategyAlternatives_0_0 = (Alternatives)cStrategyAssignment_0.eContents().get(0);
		private final Keyword cStrategySelectFirstKeyword_0_0_0 = (Keyword)cStrategyAlternatives_0_0.eContents().get(0);
		private final Keyword cStrategySelectBestKeyword_0_0_1 = (Keyword)cStrategyAlternatives_0_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRepositoryConfigAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRepositoryConfigRepositoryConfigurationParserRuleCall_2_0 = (RuleCall)cRepositoryConfigAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ResolutionStrategy:
		//  strategy=( "select-first" | "select-best" ) "{" repositoryConfig+=
		//  RepositoryConfiguration* "}";
		public ParserRule getRule() { return rule; }

		//strategy=( "select-first" | "select-best" ) "{" repositoryConfig+=
		//RepositoryConfiguration* "}"
		public Group getGroup() { return cGroup; }

		//strategy=( "select-first" | "select-best" )
		public Assignment getStrategyAssignment_0() { return cStrategyAssignment_0; }

		//"select-first"|"select-best"
		public Alternatives getStrategyAlternatives_0_0() { return cStrategyAlternatives_0_0; }

		//"select-first"
		public Keyword getStrategySelectFirstKeyword_0_0_0() { return cStrategySelectFirstKeyword_0_0_0; }

		//"select-best"
		public Keyword getStrategySelectBestKeyword_0_0_1() { return cStrategySelectBestKeyword_0_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//repositoryConfig+=RepositoryConfiguration*
		public Assignment getRepositoryConfigAssignment_2() { return cRepositoryConfigAssignment_2; }

		//RepositoryConfiguration
		public RuleCall getRepositoryConfigRepositoryConfigurationParserRuleCall_2_0() { return cRepositoryConfigRepositoryConfigurationParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ContainerConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ContainerConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDocumentationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_0_0 = (RuleCall)cDocumentationAssignment_0.eContents().get(0);
		private final Keyword cContainerKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cAgentKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTypeTypeRefParserRuleCall_4_0 = (RuleCall)cTypeAssignment_4.eContents().get(0);
		private final Assignment cContextBlockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cContextBlockContextBlockParserRuleCall_5_0 = (RuleCall)cContextBlockAssignment_5.eContents().get(0);
		
		//ContainerConfiguration:
		//  documentation=DOCUMENTATION? "container" name=ID "agent" type=TypeRef contextBlock=
		//  ContextBlock?;
		public ParserRule getRule() { return rule; }

		//documentation=DOCUMENTATION? "container" name=ID "agent" type=TypeRef contextBlock=
		//ContextBlock?
		public Group getGroup() { return cGroup; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_0() { return cDocumentationAssignment_0; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_0_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_0_0; }

		//"container"
		public Keyword getContainerKeyword_1() { return cContainerKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//"agent"
		public Keyword getAgentKeyword_3() { return cAgentKeyword_3; }

		//type=TypeRef
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_4_0() { return cTypeTypeRefParserRuleCall_4_0; }

		//contextBlock=ContextBlock?
		public Assignment getContextBlockAssignment_5() { return cContextBlockAssignment_5; }

		//ContextBlock
		public RuleCall getContextBlockContextBlockParserRuleCall_5_0() { return cContextBlockContextBlockParserRuleCall_5_0; }
	}

	public class URIElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "URI");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//URI returns ecore::EString:
		//  STRING; 
		//	
		//  / * returns types::URI * /
		public ParserRule getRule() { return rule; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}

	public class ConcernElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Concern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDocumentationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_0_0 = (RuleCall)cDocumentationAssignment_0.eContents().get(0);
		private final Keyword cConcernKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cConcernAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConcernConcernBlockParserRuleCall_3_0 = (RuleCall)cConcernAssignment_3.eContents().get(0);
		
		//Concern:
		//  documentation=DOCUMENTATION? "concern" name=ID concern=ConcernBlock;
		public ParserRule getRule() { return rule; }

		//documentation=DOCUMENTATION? "concern" name=ID concern=ConcernBlock
		public Group getGroup() { return cGroup; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_0() { return cDocumentationAssignment_0; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_0_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_0_0; }

		//"concern"
		public Keyword getConcernKeyword_1() { return cConcernKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//concern=ConcernBlock
		public Assignment getConcernAssignment_3() { return cConcernAssignment_3; }

		//ConcernBlock
		public RuleCall getConcernConcernBlockParserRuleCall_3_0() { return cConcernConcernBlockParserRuleCall_3_0; }
	}

	public class ConcernBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConcernBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConcernBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cExtendsKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSuperConcernsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSuperConcernsIDTerminalRuleCall_1_1_0 = (RuleCall)cSuperConcernsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cSuperConcernsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cSuperConcernsIDTerminalRuleCall_1_2_1_0 = (RuleCall)cSuperConcernsAssignment_1_2_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cContextsAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cContextsContextParserRuleCall_3_0_0 = (RuleCall)cContextsAssignment_3_0.eContents().get(0);
		private final Assignment cFunctionsAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_3_1_0 = (RuleCall)cFunctionsAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ConcernBlock:
		//  {ConcernBlock} ("extends" superConcerns+=ID ("," superConcerns+=ID)*)? "{" (contexts+=
		//  Context|functions+=Function)* "}";
		public ParserRule getRule() { return rule; }

		//{ConcernBlock} ("extends" superConcerns+=ID ("," superConcerns+=ID)*)? "{" (contexts+=
		//Context|functions+=Function)* "}"
		public Group getGroup() { return cGroup; }

		//{ConcernBlock}
		public Action getConcernBlockAction_0() { return cConcernBlockAction_0; }

		//("extends" superConcerns+=ID ("," superConcerns+=ID)*)?
		public Group getGroup_1() { return cGroup_1; }

		//"extends"
		public Keyword getExtendsKeyword_1_0() { return cExtendsKeyword_1_0; }

		//superConcerns+=ID
		public Assignment getSuperConcernsAssignment_1_1() { return cSuperConcernsAssignment_1_1; }

		//ID
		public RuleCall getSuperConcernsIDTerminalRuleCall_1_1_0() { return cSuperConcernsIDTerminalRuleCall_1_1_0; }

		//("," superConcerns+=ID)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//","
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }

		//superConcerns+=ID
		public Assignment getSuperConcernsAssignment_1_2_1() { return cSuperConcernsAssignment_1_2_1; }

		//ID
		public RuleCall getSuperConcernsIDTerminalRuleCall_1_2_1_0() { return cSuperConcernsIDTerminalRuleCall_1_2_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//(contexts+=Context|functions+=Function)*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//contexts+=Context
		public Assignment getContextsAssignment_3_0() { return cContextsAssignment_3_0; }

		//Context
		public RuleCall getContextsContextParserRuleCall_3_0_0() { return cContextsContextParserRuleCall_3_0_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_3_1() { return cFunctionsAssignment_3_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_3_1_0() { return cFunctionsFunctionParserRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class FilterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Filter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredicateExpressionParserRuleCall_1_0 = (RuleCall)cPredicateAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Filter:
		//  "(" predicate=Expression ")";
		public ParserRule getRule() { return rule; }

		//"(" predicate=Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//predicate=Expression
		public Assignment getPredicateAssignment_1() { return cPredicateAssignment_1; }

		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_1_0() { return cPredicateExpressionParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class PreConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPreconditionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAssertsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAssertsAssertionExpressionParserRuleCall_2_0 = (RuleCall)cAssertsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PreCondition:
		//  "precondition" "{" asserts+=AssertionExpression+ "}";
		public ParserRule getRule() { return rule; }

		//"precondition" "{" asserts+=AssertionExpression+ "}"
		public Group getGroup() { return cGroup; }

		//"precondition"
		public Keyword getPreconditionKeyword_0() { return cPreconditionKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//asserts+=AssertionExpression+
		public Assignment getAssertsAssignment_2() { return cAssertsAssignment_2; }

		//AssertionExpression
		public RuleCall getAssertsAssertionExpressionParserRuleCall_2_0() { return cAssertsAssertionExpressionParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class PostConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPostconditionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAssertsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAssertsAssertionExpressionParserRuleCall_2_0 = (RuleCall)cAssertsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PostCondition:
		//  "postcondition" "{" asserts+=AssertionExpression+ "}";
		public ParserRule getRule() { return rule; }

		//"postcondition" "{" asserts+=AssertionExpression+ "}"
		public Group getGroup() { return cGroup; }

		//"postcondition"
		public Keyword getPostconditionKeyword_0() { return cPostconditionKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//asserts+=AssertionExpression+
		public Assignment getAssertsAssignment_2() { return cAssertsAssignment_2; }

		//AssertionExpression
		public RuleCall getAssertsAssertionExpressionParserRuleCall_2_0() { return cAssertsAssertionExpressionParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class AssertionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssertionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAssertKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMessageAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMessageSTRINGTerminalRuleCall_3_0 = (RuleCall)cMessageAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//AssertionExpression:
		//  "assert" expr=Expression "," message=STRING ";";
		public ParserRule getRule() { return rule; }

		//"assert" expr=Expression "," message=STRING ";"
		public Group getGroup() { return cGroup; }

		//"assert"
		public Keyword getAssertKeyword_0() { return cAssertKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//message=STRING
		public Assignment getMessageAssignment_3() { return cMessageAssignment_3; }

		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_3_0() { return cMessageSTRINGTerminalRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class ExpressionListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ExpressionList:
		//  (expressions+=Expression ";")+;
		public ParserRule getRule() { return rule; }

		//(expressions+=Expression ";")+
		public Group getGroup() { return cGroup; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_0_0() { return cExpressionsExpressionParserRuleCall_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3FunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDocumentationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDocumentationDOCUMENTATIONTerminalRuleCall_1_0 = (RuleCall)cDocumentationAssignment_1.eContents().get(0);
		private final Assignment cVisibilityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVisibilityVisibilityEnumRuleCall_2_0 = (RuleCall)cVisibilityAssignment_2.eContents().get(0);
		private final Assignment cExecutionModeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExecutionModeExecutionModeEnumRuleCall_3_0 = (RuleCall)cExecutionModeAssignment_3.eContents().get(0);
		private final Assignment cFinalAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cFinalFinalKeyword_4_0 = (Keyword)cFinalAssignment_4.eContents().get(0);
		private final Keyword cFunctionKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnTypeTypeRefParserRuleCall_6_0 = (RuleCall)cReturnTypeAssignment_6.eContents().get(0);
		private final Assignment cNameAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cNameIDTerminalRuleCall_7_0 = (RuleCall)cNameAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cLeftParenthesisKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Group cGroup_8_1 = (Group)cGroup_8.eContents().get(1);
		private final Assignment cParametersAssignment_8_1_0 = (Assignment)cGroup_8_1.eContents().get(0);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_8_1_0_0 = (RuleCall)cParametersAssignment_8_1_0.eContents().get(0);
		private final Group cGroup_8_1_1 = (Group)cGroup_8_1.eContents().get(1);
		private final Keyword cCommaKeyword_8_1_1_0 = (Keyword)cGroup_8_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_8_1_1_1 = (Assignment)cGroup_8_1_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_8_1_1_1_0 = (RuleCall)cParametersAssignment_8_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		private final Alternatives cAlternatives_9 = (Alternatives)cGroup.eContents().get(9);
		private final Group cGroup_9_0 = (Group)cAlternatives_9.eContents().get(0);
		private final Keyword cColonKeyword_9_0_0 = (Keyword)cGroup_9_0.eContents().get(0);
		private final Assignment cFuncExprAssignment_9_0_1 = (Assignment)cGroup_9_0.eContents().get(1);
		private final RuleCall cFuncExprExpressionParserRuleCall_9_0_1_0 = (RuleCall)cFuncExprAssignment_9_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_9_0_2 = (Keyword)cGroup_9_0.eContents().get(2);
		private final Assignment cFuncExprAssignment_9_1 = (Assignment)cAlternatives_9.eContents().get(1);
		private final RuleCall cFuncExprBlockExpressionParserRuleCall_9_1_0 = (RuleCall)cFuncExprAssignment_9_1.eContents().get(0);
		
		//Function returns be::B3Function:
		//  {be::B3Function} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
		//  ExecutionMode? final?="final"? "function" returnType=TypeRef? name=ID ("(" (parameters
		//  +=ParameterDeclaration ("," parameters+=ParameterDeclaration)*)? ")")? (":" funcExpr=
		//  Expression ";"|funcExpr=BlockExpression); 
		//
		//      
		//	    
		//   	    
		//        	   	
		//   	    
		//   	
		//   	    
		//   	 
		////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
		//   	                   
		//   	        
		//	
		//	
		////TypeParamDeclaration 
		////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
		////	;
		//		
		/// * EXPRESSIONS * /
		public ParserRule getRule() { return rule; }

		//{be::B3Function} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
		//ExecutionMode? final?="final"? "function" returnType=TypeRef? name=ID ("(" (parameters
		//+=ParameterDeclaration ("," parameters+=ParameterDeclaration)*)? ")")? (":" funcExpr=
		//Expression ";"|funcExpr=BlockExpression)   
		//	    
		//   	    
		//        	   	
		//   	    
		//   	
		//   	    
		//   	 
		////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
		public Group getGroup() { return cGroup; }

		//{be::B3Function}
		public Action getB3FunctionAction_0() { return cB3FunctionAction_0; }

		//documentation=DOCUMENTATION?
		public Assignment getDocumentationAssignment_1() { return cDocumentationAssignment_1; }

		//DOCUMENTATION
		public RuleCall getDocumentationDOCUMENTATIONTerminalRuleCall_1_0() { return cDocumentationDOCUMENTATIONTerminalRuleCall_1_0; }

		//visibility=Visibility?
		public Assignment getVisibilityAssignment_2() { return cVisibilityAssignment_2; }

		//Visibility
		public RuleCall getVisibilityVisibilityEnumRuleCall_2_0() { return cVisibilityVisibilityEnumRuleCall_2_0; }

		//executionMode=ExecutionMode?
		public Assignment getExecutionModeAssignment_3() { return cExecutionModeAssignment_3; }

		//ExecutionMode
		public RuleCall getExecutionModeExecutionModeEnumRuleCall_3_0() { return cExecutionModeExecutionModeEnumRuleCall_3_0; }

		//final?="final"?
		public Assignment getFinalAssignment_4() { return cFinalAssignment_4; }

		//"final"
		public Keyword getFinalFinalKeyword_4_0() { return cFinalFinalKeyword_4_0; }

		//"function"
		public Keyword getFunctionKeyword_5() { return cFunctionKeyword_5; }

		//returnType=TypeRef?
		public Assignment getReturnTypeAssignment_6() { return cReturnTypeAssignment_6; }

		//TypeRef
		public RuleCall getReturnTypeTypeRefParserRuleCall_6_0() { return cReturnTypeTypeRefParserRuleCall_6_0; }

		//name=ID 
		//   	 
		////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
		public Assignment getNameAssignment_7() { return cNameAssignment_7; }

		//ID  
		////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
		public RuleCall getNameIDTerminalRuleCall_7_0() { return cNameIDTerminalRuleCall_7_0; }

		//("(" (parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)*)? ")"
		//)?
		public Group getGroup_8() { return cGroup_8; }

		//"("
		public Keyword getLeftParenthesisKeyword_8_0() { return cLeftParenthesisKeyword_8_0; }

		//(parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)*)?
		public Group getGroup_8_1() { return cGroup_8_1; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_8_1_0() { return cParametersAssignment_8_1_0; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_8_1_0_0() { return cParametersParameterDeclarationParserRuleCall_8_1_0_0; }

		//("," parameters+=ParameterDeclaration)*
		public Group getGroup_8_1_1() { return cGroup_8_1_1; }

		//","
		public Keyword getCommaKeyword_8_1_1_0() { return cCommaKeyword_8_1_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_8_1_1_1() { return cParametersAssignment_8_1_1_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_8_1_1_1_0() { return cParametersParameterDeclarationParserRuleCall_8_1_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_8_2() { return cRightParenthesisKeyword_8_2; }

		//":" funcExpr=Expression ";"|funcExpr=BlockExpression
		public Alternatives getAlternatives_9() { return cAlternatives_9; }

		//":" funcExpr=Expression ";"
		public Group getGroup_9_0() { return cGroup_9_0; }

		//":"
		public Keyword getColonKeyword_9_0_0() { return cColonKeyword_9_0_0; }

		//funcExpr=Expression
		public Assignment getFuncExprAssignment_9_0_1() { return cFuncExprAssignment_9_0_1; }

		//Expression
		public RuleCall getFuncExprExpressionParserRuleCall_9_0_1_0() { return cFuncExprExpressionParserRuleCall_9_0_1_0; }

		//";"
		public Keyword getSemicolonKeyword_9_0_2() { return cSemicolonKeyword_9_0_2; }

		//funcExpr=BlockExpression
		public Assignment getFuncExprAssignment_9_1() { return cFuncExprAssignment_9_1; }

		//BlockExpression
		public RuleCall getFuncExprBlockExpressionParserRuleCall_9_1_0() { return cFuncExprBlockExpressionParserRuleCall_9_1_0; }
	}

	public class AssignmentOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPlusSignEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cHyphenMinusEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cAsteriskEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cSolidusEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPercentSignEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//AssignmentOperator returns ecore::EString:
		//  "="|"+="|"-="|"*="|"/="|"%="; 
		//	
		////TypeParamDeclaration 
		////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
		////	;
		//		
		/// * EXPRESSIONS * / 
		// 
		//	              	        
		//// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
		////	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>="
		public ParserRule getRule() { return rule; }

		//"="|"+="|"-="|"*="|"/="|"%=" 
		//	
		////TypeParamDeclaration 
		////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
		////	;
		//		
		/// * EXPRESSIONS * / 
		// 
		//	              	        
		//// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
		////	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>="
		public Alternatives getAlternatives() { return cAlternatives; }

		//"="
		public Keyword getEqualsSignKeyword_0() { return cEqualsSignKeyword_0; }

		//"+="
		public Keyword getPlusSignEqualsSignKeyword_1() { return cPlusSignEqualsSignKeyword_1; }

		//"-="
		public Keyword getHyphenMinusEqualsSignKeyword_2() { return cHyphenMinusEqualsSignKeyword_2; }

		//"*="
		public Keyword getAsteriskEqualsSignKeyword_3() { return cAsteriskEqualsSignKeyword_3; }

		//"/="
		public Keyword getSolidusEqualsSignKeyword_4() { return cSolidusEqualsSignKeyword_4; }

		//"%="    
		//// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
		////	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>="
		public Keyword getPercentSignEqualsSignKeyword_5() { return cPercentSignEqualsSignKeyword_5; }
	}

	public class RelationalOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTildeEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEqualsSignEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cExclamationMarkEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cExclamationMarkEqualsSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cGreaterThanSignEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLessThanSignEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cGreaterThanSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLessThanSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		
		//RelationalOperator returns ecore::EString:
		//  "~="|"=="|"==="|"!="|"!=="|">="|"<="|">"|"<"; 
		//	
		// 
		//	                  
		//	              
		//	
		//
		//// All expressions, including variable and value definitions
		public ParserRule getRule() { return rule; }

		//"~="|"=="|"==="|"!="|"!=="|">="|"<="|">"|"<" 
		//	
		// 
		//	                  
		//	              
		//	
		//
		//// All expressions, including variable and value definitions
		public Alternatives getAlternatives() { return cAlternatives; }

		//"~="
		public Keyword getTildeEqualsSignKeyword_0() { return cTildeEqualsSignKeyword_0; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_1() { return cEqualsSignEqualsSignKeyword_1; }

		//"==="
		public Keyword getEqualsSignEqualsSignEqualsSignKeyword_2() { return cEqualsSignEqualsSignEqualsSignKeyword_2; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_3() { return cExclamationMarkEqualsSignKeyword_3; }

		//"!=="
		public Keyword getExclamationMarkEqualsSignEqualsSignKeyword_4() { return cExclamationMarkEqualsSignEqualsSignKeyword_4; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_5() { return cGreaterThanSignEqualsSignKeyword_5; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_6() { return cLessThanSignEqualsSignKeyword_6; }

		//">"
		public Keyword getGreaterThanSignKeyword_7() { return cGreaterThanSignKeyword_7; }

		//"<"
		public Keyword getLessThanSignKeyword_8() { return cLessThanSignKeyword_8; }
	}

	public class TopLevelExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TopLevelExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVarDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cValDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAssignmentExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//TopLevelExpression returns be::BExpression:
		//  VarDeclaration|ValDeclaration|AssignmentExpression; 
		//
		//// All expressions, including variable and value definitions
		//     
		//	           
		//	
		//
		//// All expressions except variable and value definitions
		public ParserRule getRule() { return rule; }

		//VarDeclaration|ValDeclaration|AssignmentExpression 
		//
		//// All expressions, including variable and value definitions
		//     
		//	           
		//	
		//
		//// All expressions except variable and value definitions
		public Alternatives getAlternatives() { return cAlternatives; }

		//VarDeclaration
		public RuleCall getVarDeclarationParserRuleCall_0() { return cVarDeclarationParserRuleCall_0; }

		//ValDeclaration
		public RuleCall getValDeclarationParserRuleCall_1() { return cValDeclarationParserRuleCall_1; }

		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall_2() { return cAssignmentExpressionParserRuleCall_2; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cAssignmentExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression returns be::BExpression:
		//  AssignmentExpression; 
		//
		//// All expressions except variable and value definitions
		public ParserRule getRule() { return rule; }

		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall() { return cAssignmentExpressionParserRuleCall; }
	}

	public class AssignmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCachedExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBAssignmentExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFunctionNameAssignmentOperatorParserRuleCall_1_1_0 = (RuleCall)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprAssignmentExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//AssignmentExpression returns be::BExpression:
		//  CachedExpression ({be::BAssignmentExpression.leftExpr=current} functionName=
		//  AssignmentOperator rightExpr=AssignmentExpression)?; 
		//
		//
		//    
		//	// note: VarDecl | OrExpr is order dependant
		//	      
		//	 	  
		//		
		//
		////AssignmentExpression returns be::BExpression:
		////	// note: VarDecl | OrExpr is order dependant
		////	 (VarDeclaration | ValDeclaration | CachedExpression) ({be::BAssignmentExpression.leftExpr=current} 
		////	 	functionName=AssignmentOperator rightExpr=AssignmentExpression)?
		////	;
		public ParserRule getRule() { return rule; }

		//CachedExpression ({be::BAssignmentExpression.leftExpr=current} functionName=
		//AssignmentOperator rightExpr=AssignmentExpression)? 
		//	// note: VarDecl | OrExpr is order dependant
		public Group getGroup() { return cGroup; }

		//CachedExpression 
		//	// note: VarDecl | OrExpr is order dependant
		public RuleCall getCachedExpressionParserRuleCall_0() { return cCachedExpressionParserRuleCall_0; }

		//({be::BAssignmentExpression.leftExpr=current} functionName=AssignmentOperator
		//rightExpr=AssignmentExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{be::BAssignmentExpression.leftExpr=current}
		public Action getBAssignmentExpressionLeftExprAction_1_0() { return cBAssignmentExpressionLeftExprAction_1_0; }

		//functionName=AssignmentOperator
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//AssignmentOperator
		public RuleCall getFunctionNameAssignmentOperatorParserRuleCall_1_1_0() { return cFunctionNameAssignmentOperatorParserRuleCall_1_1_0; }

		//rightExpr=AssignmentExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//AssignmentExpression
		public RuleCall getRightExprAssignmentExpressionParserRuleCall_1_2_0() { return cRightExprAssignmentExpressionParserRuleCall_1_2_0; }
	}

	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFinalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFinalFinalKeyword_1_0 = (Keyword)cFinalAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Keyword cVarKeyword_2_0_0 = (Keyword)cAlternatives_2_0.eContents().get(0);
		private final Assignment cTypeAssignment_2_0_1 = (Assignment)cAlternatives_2_0.eContents().get(1);
		private final RuleCall cTypeTypeRefParserRuleCall_2_0_1_0 = (RuleCall)cTypeAssignment_2_0_1.eContents().get(0);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cEqualsSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValueExprAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValueExprExpressionParserRuleCall_3_1_0 = (RuleCall)cValueExprAssignment_3_1.eContents().get(0);
		
		//VarDeclaration returns be::BExpression:
		//  {be::BDefValue} final?="final"? (("var"|type=TypeRef) name=ID) ("=" valueExpr=
		//  Expression)?; 	
		//
		////AssignmentExpression returns be::BExpression:
		////	// note: VarDecl | OrExpr is order dependant
		////	 (VarDeclaration | ValDeclaration | CachedExpression) ({be::BAssignmentExpression.leftExpr=current} 
		////	 	functionName=AssignmentOperator rightExpr=AssignmentExpression)?
		////	;
		public ParserRule getRule() { return rule; }

		//{be::BDefValue} final?="final"? (("var"|type=TypeRef) name=ID) ("=" valueExpr=
		//Expression)?
		public Group getGroup() { return cGroup; }

		//{be::BDefValue}
		public Action getBDefValueAction_0() { return cBDefValueAction_0; }

		//final?="final"?
		public Assignment getFinalAssignment_1() { return cFinalAssignment_1; }

		//"final"
		public Keyword getFinalFinalKeyword_1_0() { return cFinalFinalKeyword_1_0; }

		//("var"|type=TypeRef) name=ID
		public Group getGroup_2() { return cGroup_2; }

		//"var"|type=TypeRef
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }

		//"var"
		public Keyword getVarKeyword_2_0_0() { return cVarKeyword_2_0_0; }

		//type=TypeRef
		public Assignment getTypeAssignment_2_0_1() { return cTypeAssignment_2_0_1; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_2_0_1_0() { return cTypeTypeRefParserRuleCall_2_0_1_0; }

		//name=ID
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_1_0() { return cNameIDTerminalRuleCall_2_1_0; }

		//("=" valueExpr=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"="
		public Keyword getEqualsSignKeyword_3_0() { return cEqualsSignKeyword_3_0; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_3_1() { return cValueExprAssignment_3_1; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_3_1_0() { return cValueExprExpressionParserRuleCall_3_1_0; }
	}

	public class ValDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFinalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cFinalFinalKeyword_1_0 = (Keyword)cFinalAssignment_1.eContents().get(0);
		private final Assignment cImmutableAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cImmutableValKeyword_2_0 = (Keyword)cImmutableAssignment_2.eContents().get(0);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeRefParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Assignment cNameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNameIDTerminalRuleCall_4_0 = (RuleCall)cNameAssignment_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cValueExprAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cValueExprExpressionParserRuleCall_6_0 = (RuleCall)cValueExprAssignment_6.eContents().get(0);
		
		//ValDeclaration returns be::BExpression:
		//  {be::BDefValue} final?="final"? immutable?="val" type=TypeRef? name=ID "=" valueExpr=
		//  Expression;
		public ParserRule getRule() { return rule; }

		//{be::BDefValue} final?="final"? immutable?="val" type=TypeRef? name=ID "=" valueExpr=
		//Expression
		public Group getGroup() { return cGroup; }

		//{be::BDefValue}
		public Action getBDefValueAction_0() { return cBDefValueAction_0; }

		//final?="final"?
		public Assignment getFinalAssignment_1() { return cFinalAssignment_1; }

		//"final"
		public Keyword getFinalFinalKeyword_1_0() { return cFinalFinalKeyword_1_0; }

		//immutable?="val"
		public Assignment getImmutableAssignment_2() { return cImmutableAssignment_2; }

		//"val"
		public Keyword getImmutableValKeyword_2_0() { return cImmutableValKeyword_2_0; }

		//type=TypeRef?
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_3_0() { return cTypeTypeRefParserRuleCall_3_0; }

		//name=ID
		public Assignment getNameAssignment_4() { return cNameAssignment_4; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_4_0() { return cNameIDTerminalRuleCall_4_0; }

		//"="
		public Keyword getEqualsSignKeyword_5() { return cEqualsSignKeyword_5; }

		//valueExpr=Expression
		public Assignment getValueExprAssignment_6() { return cValueExprAssignment_6; }

		//Expression
		public RuleCall getValueExprExpressionParserRuleCall_6_0() { return cValueExprExpressionParserRuleCall_6_0; }
	}

	public class TypeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeRef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClosureTypeRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TypeRef returns be::IType:
		//  ClosureTypeRef|SimpleTypeRef; 
		//		
		//             // TODO: gets lots of warnings from this...
		public ParserRule getRule() { return rule; }

		//ClosureTypeRef|SimpleTypeRef 
		//		
		//             // TODO: gets lots of warnings from this...
		public Alternatives getAlternatives() { return cAlternatives; }

		//ClosureTypeRef
		public RuleCall getClosureTypeRefParserRuleCall_0() { return cClosureTypeRefParserRuleCall_0; }

		//SimpleTypeRef
		public RuleCall getSimpleTypeRefParserRuleCall_1() { return cSimpleTypeRefParserRuleCall_1; }
	}

	public class SimpleTypeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleTypeRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3ParameterizedTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cRawTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cRawTypeB3JavaImportCrossReference_1_0 = (CrossReference)cRawTypeAssignment_1.eContents().get(0);
		private final RuleCall cRawTypeB3JavaImportIDTerminalRuleCall_1_0_1 = (RuleCall)cRawTypeB3JavaImportCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLessThanSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cActualArgumentsListAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cActualArgumentsListB3JavaImportCrossReference_2_1_0 = (CrossReference)cActualArgumentsListAssignment_2_1.eContents().get(0);
		private final RuleCall cActualArgumentsListB3JavaImportIDTerminalRuleCall_2_1_0_1 = (RuleCall)cActualArgumentsListB3JavaImportCrossReference_2_1_0.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cActualArgumentsListAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final CrossReference cActualArgumentsListB3JavaImportCrossReference_2_2_1_0 = (CrossReference)cActualArgumentsListAssignment_2_2_1.eContents().get(0);
		private final RuleCall cActualArgumentsListB3JavaImportIDTerminalRuleCall_2_2_1_0_1 = (RuleCall)cActualArgumentsListB3JavaImportCrossReference_2_2_1_0.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		
		//SimpleTypeRef returns be::IType:
		//  {be::B3ParameterizedType} rawType=[be::B3JavaImport] ("<" actualArgumentsList+=[be
		//  ::B3JavaImport] ("," actualArgumentsList+=[be::B3JavaImport])* ">")?;   // TODO: gets lots of warnings from this...
		//    
		//	         
		//		                  
		////		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
		//	 
		//	
		//// TODO: typereference is simplified to only the name of a java type - for model imports
		//// the model is imported with name == namespace, and types in the model are referenced after
		//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
		//// referenced as mymodel::mytype
		//// There is more work required to link a reference to such a type and it is therefore deferred
		//// until we are up on Xtext 0.8 with better scoping and linking.
		//// For now, this is just proof of concept.
		//// 
		//
		//// ClosureTypeRef declares parameters and return type	TODO: use TypeRef instead of direct reference to imported class
		public ParserRule getRule() { return rule; }

		//{be::B3ParameterizedType} rawType=[be::B3JavaImport] ("<" actualArgumentsList+=[be
		//::B3JavaImport] ("," actualArgumentsList+=[be::B3JavaImport])* ">")?          
		//		                  
		////		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
		public Group getGroup() { return cGroup; }

		//{be::B3ParameterizedType}
		public Action getB3ParameterizedTypeAction_0() { return cB3ParameterizedTypeAction_0; }

		//rawType=[be::B3JavaImport]
		public Assignment getRawTypeAssignment_1() { return cRawTypeAssignment_1; }

		//[be::B3JavaImport]
		public CrossReference getRawTypeB3JavaImportCrossReference_1_0() { return cRawTypeB3JavaImportCrossReference_1_0; }

		//ID
		public RuleCall getRawTypeB3JavaImportIDTerminalRuleCall_1_0_1() { return cRawTypeB3JavaImportIDTerminalRuleCall_1_0_1; }

		//("<" actualArgumentsList+=[be::B3JavaImport] ("," actualArgumentsList+=[be::
		//B3JavaImport])* ">")?
		public Group getGroup_2() { return cGroup_2; }

		//"<"
		public Keyword getLessThanSignKeyword_2_0() { return cLessThanSignKeyword_2_0; }

		//actualArgumentsList+=[be::B3JavaImport]
		public Assignment getActualArgumentsListAssignment_2_1() { return cActualArgumentsListAssignment_2_1; }

		//[be::B3JavaImport]
		public CrossReference getActualArgumentsListB3JavaImportCrossReference_2_1_0() { return cActualArgumentsListB3JavaImportCrossReference_2_1_0; }

		//ID
		public RuleCall getActualArgumentsListB3JavaImportIDTerminalRuleCall_2_1_0_1() { return cActualArgumentsListB3JavaImportIDTerminalRuleCall_2_1_0_1; }

		//("," actualArgumentsList+=[be::B3JavaImport])*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//actualArgumentsList+=[be::B3JavaImport]
		public Assignment getActualArgumentsListAssignment_2_2_1() { return cActualArgumentsListAssignment_2_2_1; }

		//[be::B3JavaImport]
		public CrossReference getActualArgumentsListB3JavaImportCrossReference_2_2_1_0() { return cActualArgumentsListB3JavaImportCrossReference_2_2_1_0; }

		//ID
		public RuleCall getActualArgumentsListB3JavaImportIDTerminalRuleCall_2_2_1_0_1() { return cActualArgumentsListB3JavaImportIDTerminalRuleCall_2_2_1_0_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_2_3() { return cGreaterThanSignKeyword_2_3; }
	}

	public class ClosureTypeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClosureTypeRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3FunctionTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cParameterTypesAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final CrossReference cParameterTypesB3JavaImportCrossReference_1_1_0_0 = (CrossReference)cParameterTypesAssignment_1_1_0.eContents().get(0);
		private final RuleCall cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_0_1 = (RuleCall)cParameterTypesB3JavaImportCrossReference_1_1_0_0.eContents().get(1);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cParameterTypesAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final CrossReference cParameterTypesB3JavaImportCrossReference_1_1_1_1_0 = (CrossReference)cParameterTypesAssignment_1_1_1_1.eContents().get(0);
		private final RuleCall cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_1_1_0_1 = (RuleCall)cParameterTypesB3JavaImportCrossReference_1_1_1_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cReturnTypeAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final CrossReference cReturnTypeB3JavaImportCrossReference_1_4_0 = (CrossReference)cReturnTypeAssignment_1_4.eContents().get(0);
		private final RuleCall cReturnTypeB3JavaImportIDTerminalRuleCall_1_4_0_1 = (RuleCall)cReturnTypeB3JavaImportCrossReference_1_4_0.eContents().get(1);
		
		//ClosureTypeRef returns be::IType:
		//  {be::B3FunctionType} ("(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[
		//  be::B3JavaImport])*)? ")" "=>" returnType=[be::B3JavaImport]); 
		//	
		//// TODO: typereference is simplified to only the name of a java type - for model imports
		//// the model is imported with name == namespace, and types in the model are referenced after
		//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
		//// referenced as mymodel::mytype
		//// There is more work required to link a reference to such a type and it is therefore deferred
		//// until we are up on Xtext 0.8 with better scoping and linking.
		//// For now, this is just proof of concept.
		//// 
		//
		//// ClosureTypeRef declares parameters and return type	TODO: use TypeRef instead of direct reference to imported class
		public ParserRule getRule() { return rule; }

		//{be::B3FunctionType} ("(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[
		//be::B3JavaImport])*)? ")" "=>" returnType=[be::B3JavaImport])
		public Group getGroup() { return cGroup; }

		//{be::B3FunctionType}
		public Action getB3FunctionTypeAction_0() { return cB3FunctionTypeAction_0; }

		//"(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[be::B3JavaImport])*)?
		//")" "=>" returnType=[be::B3JavaImport]
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//(parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[be::B3JavaImport])*)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//parameterTypes+=[be::B3JavaImport]
		public Assignment getParameterTypesAssignment_1_1_0() { return cParameterTypesAssignment_1_1_0; }

		//[be::B3JavaImport]
		public CrossReference getParameterTypesB3JavaImportCrossReference_1_1_0_0() { return cParameterTypesB3JavaImportCrossReference_1_1_0_0; }

		//ID
		public RuleCall getParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_0_1() { return cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_0_0_1; }

		//("," parameterTypes+=[be::B3JavaImport])*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_1_0() { return cCommaKeyword_1_1_1_0; }

		//parameterTypes+=[be::B3JavaImport]
		public Assignment getParameterTypesAssignment_1_1_1_1() { return cParameterTypesAssignment_1_1_1_1; }

		//[be::B3JavaImport]
		public CrossReference getParameterTypesB3JavaImportCrossReference_1_1_1_1_0() { return cParameterTypesB3JavaImportCrossReference_1_1_1_1_0; }

		//ID
		public RuleCall getParameterTypesB3JavaImportIDTerminalRuleCall_1_1_1_1_0_1() { return cParameterTypesB3JavaImportIDTerminalRuleCall_1_1_1_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1_3() { return cEqualsSignGreaterThanSignKeyword_1_3; }

		//returnType=[be::B3JavaImport]
		public Assignment getReturnTypeAssignment_1_4() { return cReturnTypeAssignment_1_4; }

		//[be::B3JavaImport]
		public CrossReference getReturnTypeB3JavaImportCrossReference_1_4_0() { return cReturnTypeB3JavaImportCrossReference_1_4_0; }

		//ID
		public RuleCall getReturnTypeB3JavaImportIDTerminalRuleCall_1_4_0_1() { return cReturnTypeB3JavaImportIDTerminalRuleCall_1_4_0_1; }
	}

	public class TypeParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeParam");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeRefParamParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWildcardRefParamParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TypeParam returns be::IType:
		//  TypeRefParam|WildcardRefParam;
		public ParserRule getRule() { return rule; }

		//TypeRefParam|WildcardRefParam
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeRefParam
		public RuleCall getTypeRefParamParserRuleCall_0() { return cTypeRefParamParserRuleCall_0; }

		//WildcardRefParam
		public RuleCall getWildcardRefParamParserRuleCall_1() { return cWildcardRefParamParserRuleCall_1; }
	}

	public class TypeRefParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeRefParam");
		private final RuleCall cTypeRefParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TypeRefParam returns be::IType:
		//  TypeRef;
		public ParserRule getRule() { return rule; }

		//TypeRef
		public RuleCall getTypeRefParserRuleCall() { return cTypeRefParserRuleCall; }
	}

	public class WildcardRefParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WildcardRefParam");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3WildcardTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cExtendsKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cUpperBoundsListAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cUpperBoundsListTypeRefParserRuleCall_2_0_1_0 = (RuleCall)cUpperBoundsListAssignment_2_0_1.eContents().get(0);
		private final Group cGroup_2_0_2 = (Group)cGroup_2_0.eContents().get(2);
		private final Keyword cCommaKeyword_2_0_2_0 = (Keyword)cGroup_2_0_2.eContents().get(0);
		private final Assignment cUpperBoundsListAssignment_2_0_2_1 = (Assignment)cGroup_2_0_2.eContents().get(1);
		private final RuleCall cUpperBoundsListTypeRefParserRuleCall_2_0_2_1_0 = (RuleCall)cUpperBoundsListAssignment_2_0_2_1.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cSuperKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cLowerBoundsListAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cLowerBoundsListTypeRefParserRuleCall_2_1_1_0 = (RuleCall)cLowerBoundsListAssignment_2_1_1.eContents().get(0);
		
		//WildcardRefParam returns be::IType:
		//  {be::B3WildcardType} "?" ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=
		//  TypeRef)*|"super" lowerBoundsList+=TypeRef)?;
		public ParserRule getRule() { return rule; }

		//{be::B3WildcardType} "?" ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=
		//TypeRef)*|"super" lowerBoundsList+=TypeRef)?
		public Group getGroup() { return cGroup; }

		//{be::B3WildcardType}
		public Action getB3WildcardTypeAction_0() { return cB3WildcardTypeAction_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1() { return cQuestionMarkKeyword_1; }

		//("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=TypeRef)*|"super"
		//lowerBoundsList+=TypeRef)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"extends" upperBoundsList+=TypeRef ("," upperBoundsList+=TypeRef)*
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"extends"
		public Keyword getExtendsKeyword_2_0_0() { return cExtendsKeyword_2_0_0; }

		//upperBoundsList+=TypeRef
		public Assignment getUpperBoundsListAssignment_2_0_1() { return cUpperBoundsListAssignment_2_0_1; }

		//TypeRef
		public RuleCall getUpperBoundsListTypeRefParserRuleCall_2_0_1_0() { return cUpperBoundsListTypeRefParserRuleCall_2_0_1_0; }

		//("," upperBoundsList+=TypeRef)*
		public Group getGroup_2_0_2() { return cGroup_2_0_2; }

		//","
		public Keyword getCommaKeyword_2_0_2_0() { return cCommaKeyword_2_0_2_0; }

		//upperBoundsList+=TypeRef
		public Assignment getUpperBoundsListAssignment_2_0_2_1() { return cUpperBoundsListAssignment_2_0_2_1; }

		//TypeRef
		public RuleCall getUpperBoundsListTypeRefParserRuleCall_2_0_2_1_0() { return cUpperBoundsListTypeRefParserRuleCall_2_0_2_1_0; }

		//"super" lowerBoundsList+=TypeRef
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"super"
		public Keyword getSuperKeyword_2_1_0() { return cSuperKeyword_2_1_0; }

		//lowerBoundsList+=TypeRef
		public Assignment getLowerBoundsListAssignment_2_1_1() { return cLowerBoundsListAssignment_2_1_1; }

		//TypeRef
		public RuleCall getLowerBoundsListTypeRefParserRuleCall_2_1_1_0() { return cLowerBoundsListTypeRefParserRuleCall_2_1_1_0; }
	}

	public class CachedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CachedExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBCachedExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cCachedKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExprAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExprOrExpressionParserRuleCall_0_2_0 = (RuleCall)cExprAssignment_0_2.eContents().get(0);
		private final RuleCall cOrExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//CachedExpression returns be::BExpression:
		//  {be::BCachedExpression} "cached" expr=OrExpression|OrExpression;
		public ParserRule getRule() { return rule; }

		//{be::BCachedExpression} "cached" expr=OrExpression|OrExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{be::BCachedExpression} "cached" expr=OrExpression
		public Group getGroup_0() { return cGroup_0; }

		//{be::BCachedExpression}
		public Action getBCachedExpressionAction_0_0() { return cBCachedExpressionAction_0_0; }

		//"cached"
		public Keyword getCachedKeyword_0_1() { return cCachedKeyword_0_1; }

		//expr=OrExpression
		public Assignment getExprAssignment_0_2() { return cExprAssignment_0_2; }

		//OrExpression
		public RuleCall getExprOrExpressionParserRuleCall_0_2_0() { return cExprOrExpressionParserRuleCall_0_2_0; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_1() { return cOrExpressionParserRuleCall_1; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBOrExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//OrExpression returns be::BExpression:
		//  AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*;
		public ParserRule getRule() { return rule; }

		//AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BOrExpression.leftExpr=current}
		public Action getBOrExpressionLeftExprAction_1_0() { return cBOrExpressionLeftExprAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//rightExpr=AndExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//AndExpression
		public RuleCall getRightExprAndExpressionParserRuleCall_1_2_0() { return cRightExprAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBAndExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprRelationalExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//AndExpression returns be::BExpression:
		//  RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
		//  RelationalExpression)*; 
		//	
		//    
		//	      
		//
		//// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language.
		//// BitwiseExpression returns be::BExpression :
		//// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
		//RelationalExpression)*
		public Group getGroup() { return cGroup; }

		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }

		//({be::BAndExpression.leftExpr=current} "&&" rightExpr=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BAndExpression.leftExpr=current}
		public Action getBAndExpressionLeftExprAction_1_0() { return cBAndExpressionLeftExprAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//rightExpr=RelationalExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//RelationalExpression
		public RuleCall getRightExprRelationalExpressionParserRuleCall_1_2_0() { return cRightExprRelationalExpressionParserRuleCall_1_2_0; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInstanceOfExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFunctionNameRelationalOperatorParserRuleCall_1_1_0 = (RuleCall)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprInstanceOfExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//RelationalExpression returns be::BExpression:
		//  InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//  RelationalOperator rightExpr=InstanceOfExpression)*; 
		//
		//// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language.
		//// BitwiseExpression returns be::BExpression :
		//// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//RelationalOperator rightExpr=InstanceOfExpression)*
		public Group getGroup() { return cGroup; }

		//InstanceOfExpression
		public RuleCall getInstanceOfExpressionParserRuleCall_0() { return cInstanceOfExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName=RelationalOperator
		//rightExpr=InstanceOfExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName=RelationalOperator
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//RelationalOperator
		public RuleCall getFunctionNameRelationalOperatorParserRuleCall_1_1_0() { return cFunctionNameRelationalOperatorParserRuleCall_1_1_0; }

		//rightExpr=InstanceOfExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//InstanceOfExpression
		public RuleCall getRightExprInstanceOfExpressionParserRuleCall_1_2_0() { return cRightExprInstanceOfExpressionParserRuleCall_1_2_0; }
	}

	public class InstanceOfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstanceOfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cFunctionNameInstanceofKeyword_1_1_0 = (Keyword)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprLiteralTypeParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//InstanceOfExpression returns be::BExpression:
		//  AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//  "instanceof" rightExpr=LiteralType)*; 
		//
		//      
		//	        
		//
		//// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language.	
		//// ShiftExpression returns be::BExpression:
		//// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
		public ParserRule getRule() { return rule; }

		//AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//"instanceof" rightExpr=LiteralType)*
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName="instanceof" rightExpr=
		//LiteralType)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName="instanceof"
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//"instanceof"
		public Keyword getFunctionNameInstanceofKeyword_1_1_0() { return cFunctionNameInstanceofKeyword_1_1_0; }

		//rightExpr=LiteralType
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//LiteralType
		public RuleCall getRightExprLiteralTypeParserRuleCall_1_2_0() { return cRightExprLiteralTypeParserRuleCall_1_2_0; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_1_0 = (Alternatives)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Keyword cFunctionNamePlusSignKeyword_1_1_0_0 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cFunctionNameHyphenMinusKeyword_1_1_0_1 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//AdditiveExpression returns be::BExpression:
		//  MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//  ( "+" | "-" ) rightExpr=MultiplicativeExpression)*; 
		//
		//// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
		//// use the backend for some other language.	
		//// ShiftExpression returns be::BExpression:
		//// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
		public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//( "+" | "-" ) rightExpr=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName=( "+" | "-" ) rightExpr=
		//MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName=( "+" | "-" )
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//"+"|"-"
		public Alternatives getFunctionNameAlternatives_1_1_0() { return cFunctionNameAlternatives_1_1_0; }

		//"+"
		public Keyword getFunctionNamePlusSignKeyword_1_1_0_0() { return cFunctionNamePlusSignKeyword_1_1_0_0; }

		//"-"
		public Keyword getFunctionNameHyphenMinusKeyword_1_1_0_1() { return cFunctionNameHyphenMinusKeyword_1_1_0_1; }

		//rightExpr=MultiplicativeExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//MultiplicativeExpression
		public RuleCall getRightExprMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightExprMultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSetExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_1_0 = (Alternatives)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Keyword cFunctionNameAsteriskKeyword_1_1_0_0 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cFunctionNameSolidusKeyword_1_1_0_1 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(1);
		private final Keyword cFunctionNamePercentSignKeyword_1_1_0_2 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprSetExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//MultiplicativeExpression returns be::BExpression:
		//  SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" |
		//  "%" ) rightExpr=SetExpression)*;
		public ParserRule getRule() { return rule; }

		//SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" |
		//"%" ) rightExpr=SetExpression)*
		public Group getGroup() { return cGroup; }

		//SetExpression
		public RuleCall getSetExpressionParserRuleCall_0() { return cSetExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" | "%" ) rightExpr=
		//SetExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName=( "*" | "/" | "%" )
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//"*"|"/"|"%"
		public Alternatives getFunctionNameAlternatives_1_1_0() { return cFunctionNameAlternatives_1_1_0; }

		//"*"
		public Keyword getFunctionNameAsteriskKeyword_1_1_0_0() { return cFunctionNameAsteriskKeyword_1_1_0_0; }

		//"/"
		public Keyword getFunctionNameSolidusKeyword_1_1_0_1() { return cFunctionNameSolidusKeyword_1_1_0_1; }

		//"%"
		public Keyword getFunctionNamePercentSignKeyword_1_1_0_2() { return cFunctionNamePercentSignKeyword_1_1_0_2; }

		//rightExpr=SetExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//SetExpression
		public RuleCall getRightExprSetExpressionParserRuleCall_1_2_0() { return cRightExprSetExpressionParserRuleCall_1_2_0; }
	}

	public class SetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOrInfixExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBBinaryOpExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cFunctionNameFullStopFullStopKeyword_1_1_0 = (Keyword)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprUnaryOrInfixExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//SetExpression returns be::BExpression:
		//  UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//  ".." rightExpr=UnaryOrInfixExpression)*;
		public ParserRule getRule() { return rule; }

		//UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
		//".." rightExpr=UnaryOrInfixExpression)*
		public Group getGroup() { return cGroup; }

		//UnaryOrInfixExpression
		public RuleCall getUnaryOrInfixExpressionParserRuleCall_0() { return cUnaryOrInfixExpressionParserRuleCall_0; }

		//({be::BBinaryOpExpression.leftExpr=current} functionName=".." rightExpr=
		//UnaryOrInfixExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BBinaryOpExpression.leftExpr=current}
		public Action getBBinaryOpExpressionLeftExprAction_1_0() { return cBBinaryOpExpressionLeftExprAction_1_0; }

		//functionName=".."
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//".."
		public Keyword getFunctionNameFullStopFullStopKeyword_1_1_0() { return cFunctionNameFullStopFullStopKeyword_1_1_0; }

		//rightExpr=UnaryOrInfixExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//UnaryOrInfixExpression
		public RuleCall getRightExprUnaryOrInfixExpressionParserRuleCall_1_2_0() { return cRightExprUnaryOrInfixExpressionParserRuleCall_1_2_0; }
	}

	public class UnaryOrInfixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOrInfixExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPostopExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPreopExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//UnaryOrInfixExpression returns be::BExpression:
		//  PostopExpression|UnaryExpression|PreopExpression; 
		//
		//    
		//	   
		//	  
		//	  
		//	 
		//	
		//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
		//// kept as comment here if someone wants to use thi grammar for other purposes. 
		//// UnaryExpression returns be::BExpression:
		////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
		public ParserRule getRule() { return rule; }

		//PostopExpression|UnaryExpression|PreopExpression 
		//
		//    
		//	   
		//	  
		//	  
		//	 
		//	
		//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
		//// kept as comment here if someone wants to use thi grammar for other purposes. 
		//// UnaryExpression returns be::BExpression:
		////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
		public Alternatives getAlternatives() { return cAlternatives; }

		//PostopExpression
		public RuleCall getPostopExpressionParserRuleCall_0() { return cPostopExpressionParserRuleCall_0; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_1() { return cUnaryExpressionParserRuleCall_1; }

		//PreopExpression
		public RuleCall getPreopExpressionParserRuleCall_2() { return cPreopExpressionParserRuleCall_2; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBUnaryOpExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_0 = (Alternatives)cFunctionNameAssignment_1.eContents().get(0);
		private final Keyword cFunctionNameExclamationMarkKeyword_1_0_0 = (Keyword)cFunctionNameAlternatives_1_0.eContents().get(0);
		private final Keyword cFunctionNameHyphenMinusKeyword_1_0_1 = (Keyword)cFunctionNameAlternatives_1_0.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprInfixExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//UnaryExpression returns be::BExpression:
		//  {be::BUnaryOpExpression} functionName=( "!" | "-" ) expr=InfixExpression;  
		//	
		//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
		//// kept as comment here if someone wants to use thi grammar for other purposes. 
		//// UnaryExpression returns be::BExpression:
		////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
		public ParserRule getRule() { return rule; }

		//{be::BUnaryOpExpression} functionName=( "!" | "-" ) expr=InfixExpression
		public Group getGroup() { return cGroup; }

		//{be::BUnaryOpExpression}
		public Action getBUnaryOpExpressionAction_0() { return cBUnaryOpExpressionAction_0; }

		//functionName=( "!" | "-" )
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }

		//"!"|"-"
		public Alternatives getFunctionNameAlternatives_1_0() { return cFunctionNameAlternatives_1_0; }

		//"!"
		public Keyword getFunctionNameExclamationMarkKeyword_1_0_0() { return cFunctionNameExclamationMarkKeyword_1_0_0; }

		//"-"
		public Keyword getFunctionNameHyphenMinusKeyword_1_0_1() { return cFunctionNameHyphenMinusKeyword_1_0_1; }

		//expr=InfixExpression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//InfixExpression
		public RuleCall getExprInfixExpressionParserRuleCall_2_0() { return cExprInfixExpressionParserRuleCall_2_0; }
	}

	public class PreopExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreopExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBUnaryPreOpExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_0 = (Alternatives)cFunctionNameAssignment_1.eContents().get(0);
		private final Keyword cFunctionNamePlusSignPlusSignKeyword_1_0_0 = (Keyword)cFunctionNameAlternatives_1_0.eContents().get(0);
		private final Keyword cFunctionNameHyphenMinusHyphenMinusKeyword_1_0_1 = (Keyword)cFunctionNameAlternatives_1_0.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprInfixExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//PreopExpression returns be::BExpression:
		//  {be::BUnaryPreOpExpression} functionName=( "++" | "--" ) expr=InfixExpression;
		public ParserRule getRule() { return rule; }

		//{be::BUnaryPreOpExpression} functionName=( "++" | "--" ) expr=InfixExpression
		public Group getGroup() { return cGroup; }

		//{be::BUnaryPreOpExpression}
		public Action getBUnaryPreOpExpressionAction_0() { return cBUnaryPreOpExpressionAction_0; }

		//functionName=( "++" | "--" )
		public Assignment getFunctionNameAssignment_1() { return cFunctionNameAssignment_1; }

		//"++"|"--"
		public Alternatives getFunctionNameAlternatives_1_0() { return cFunctionNameAlternatives_1_0; }

		//"++"
		public Keyword getFunctionNamePlusSignPlusSignKeyword_1_0_0() { return cFunctionNamePlusSignPlusSignKeyword_1_0_0; }

		//"--"
		public Keyword getFunctionNameHyphenMinusHyphenMinusKeyword_1_0_1() { return cFunctionNameHyphenMinusHyphenMinusKeyword_1_0_1; }

		//expr=InfixExpression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//InfixExpression
		public RuleCall getExprInfixExpressionParserRuleCall_2_0() { return cExprInfixExpressionParserRuleCall_2_0; }
	}

	public class PostopExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostopExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInfixExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBUnaryPostOpExpressionExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cFunctionNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cFunctionNameAlternatives_1_1_0 = (Alternatives)cFunctionNameAssignment_1_1.eContents().get(0);
		private final Keyword cFunctionNameHyphenMinusHyphenMinusKeyword_1_1_0_0 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(0);
		private final Keyword cFunctionNamePlusSignPlusSignKeyword_1_1_0_1 = (Keyword)cFunctionNameAlternatives_1_1_0.eContents().get(1);
		
		//PostopExpression returns be::BExpression:
		//  InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++"
		//  ))?;
		public ParserRule getRule() { return rule; }

		//InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++"
		//))?
		public Group getGroup() { return cGroup; }

		//InfixExpression
		public RuleCall getInfixExpressionParserRuleCall_0() { return cInfixExpressionParserRuleCall_0; }

		//({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++" ))?
		public Group getGroup_1() { return cGroup_1; }

		//{be::BUnaryPostOpExpression.expr=current}
		public Action getBUnaryPostOpExpressionExprAction_1_0() { return cBUnaryPostOpExpressionExprAction_1_0; }

		//functionName=( "--" | "++" )
		public Assignment getFunctionNameAssignment_1_1() { return cFunctionNameAssignment_1_1; }

		//"--"|"++"
		public Alternatives getFunctionNameAlternatives_1_1_0() { return cFunctionNameAlternatives_1_1_0; }

		//"--"
		public Keyword getFunctionNameHyphenMinusHyphenMinusKeyword_1_1_0_0() { return cFunctionNameHyphenMinusHyphenMinusKeyword_1_1_0_0; }

		//"++"
		public Keyword getFunctionNamePlusSignPlusSignKeyword_1_1_0_1() { return cFunctionNamePlusSignPlusSignKeyword_1_1_0_1; }
	}

	public class InfixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InfixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCallExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cBCallExpressionFuncExprAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cNameAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_1_0_2_0 = (RuleCall)cNameAssignment_1_0_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_0_3 = (Keyword)cGroup_1_0.eContents().get(3);
		private final Assignment cParameterListAssignment_1_0_4 = (Assignment)cGroup_1_0.eContents().get(4);
		private final RuleCall cParameterListParameterListParserRuleCall_1_0_4_0 = (RuleCall)cParameterListAssignment_1_0_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_0_5 = (Keyword)cGroup_1_0.eContents().get(5);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cBAtExpressionObjExprAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cIndexExprAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cIndexExprExpressionParserRuleCall_1_1_2_0 = (RuleCall)cIndexExprAssignment_1_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_3 = (Keyword)cGroup_1_1.eContents().get(3);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cBFeatureExpressionObjExprAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cFullStopKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cFeatureNameAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cFeatureNameIDTerminalRuleCall_1_2_2_0 = (RuleCall)cFeatureNameAssignment_1_2_2.eContents().get(0);
		
		//InfixExpression returns be::BExpression:
		//  CallExpression ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=
		//  ParameterList? ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|
		//  {be::BFeatureExpression.objExpr=current} "." featureName=ID)*;
		public ParserRule getRule() { return rule; }

		//CallExpression ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=
		//ParameterList? ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|
		//{be::BFeatureExpression.objExpr=current} "." featureName=ID)*
		public Group getGroup() { return cGroup; }

		//CallExpression
		public RuleCall getCallExpressionParserRuleCall_0() { return cCallExpressionParserRuleCall_0; }

		//({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=ParameterList?
		//")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|{be::
		//BFeatureExpression.objExpr=current} "." featureName=ID)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=ParameterList?
		//")"
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{be::BCallExpression.funcExpr=current}
		public Action getBCallExpressionFuncExprAction_1_0_0() { return cBCallExpressionFuncExprAction_1_0_0; }

		//"."
		public Keyword getFullStopKeyword_1_0_1() { return cFullStopKeyword_1_0_1; }

		//name=ID
		public Assignment getNameAssignment_1_0_2() { return cNameAssignment_1_0_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_2_0() { return cNameIDTerminalRuleCall_1_0_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0_3() { return cLeftParenthesisKeyword_1_0_3; }

		//parameterList=ParameterList?
		public Assignment getParameterListAssignment_1_0_4() { return cParameterListAssignment_1_0_4; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_1_0_4_0() { return cParameterListParameterListParserRuleCall_1_0_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_0_5() { return cRightParenthesisKeyword_1_0_5; }

		//{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{be::BAtExpression.objExpr=current}
		public Action getBAtExpressionObjExprAction_1_1_0() { return cBAtExpressionObjExprAction_1_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1_1() { return cLeftSquareBracketKeyword_1_1_1; }

		//indexExpr=Expression
		public Assignment getIndexExprAssignment_1_1_2() { return cIndexExprAssignment_1_1_2; }

		//Expression
		public RuleCall getIndexExprExpressionParserRuleCall_1_1_2_0() { return cIndexExprExpressionParserRuleCall_1_1_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_1_3() { return cRightSquareBracketKeyword_1_1_3; }

		//{be::BFeatureExpression.objExpr=current} "." featureName=ID
		public Group getGroup_1_2() { return cGroup_1_2; }

		//{be::BFeatureExpression.objExpr=current}
		public Action getBFeatureExpressionObjExprAction_1_2_0() { return cBFeatureExpressionObjExprAction_1_2_0; }

		//"."
		public Keyword getFullStopKeyword_1_2_1() { return cFullStopKeyword_1_2_1; }

		//featureName=ID
		public Assignment getFeatureNameAssignment_1_2_2() { return cFeatureNameAssignment_1_2_2; }

		//ID
		public RuleCall getFeatureNameIDTerminalRuleCall_1_2_2_0() { return cFeatureNameIDTerminalRuleCall_1_2_2_0; }
	}

	public class CallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBCallExpressionFuncExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cParameterListAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cParameterListParameterListParserRuleCall_1_2_0 = (RuleCall)cParameterListAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//CallExpression returns be::BExpression:
		//  PrimaryExpression ({be::BCallExpression.funcExpr=current} "(" parameterList=
		//  ParameterList? ")")*;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression ({be::BCallExpression.funcExpr=current} "(" parameterList=
		//ParameterList? ")")*
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//({be::BCallExpression.funcExpr=current} "(" parameterList=ParameterList? ")")*
		public Group getGroup_1() { return cGroup_1; }

		//{be::BCallExpression.funcExpr=current}
		public Action getBCallExpressionFuncExprAction_1_0() { return cBCallExpressionFuncExprAction_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//parameterList=ParameterList?
		public Assignment getParameterListAssignment_1_2() { return cParameterListAssignment_1_2; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_1_2_0() { return cParameterListParameterListParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFeatureCallParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstructorCallExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPropertyValueParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cKeywordVariablesParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cParanthesizedExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cIfExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cBlockExpressionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cSwitchExpressionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cThrowExpressionParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cTryCatchExpressionParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cWildcardExpressionParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		
		//PrimaryExpression returns be::BExpression:
		//  FeatureCall|ConstructorCallExpression|VariableValue|Literal|PropertyValue|
		//  KeywordVariables|ParanthesizedExpression|IfExpression|BlockExpression|
		//  SwitchExpression|ThrowExpression|TryCatchExpression|WildcardExpression; 
		//		
		//    
		//	  
		//	  
		//	  
		//	   
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		////	| WithExpression
		//	 
		//	
		////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
		////WithClauseExpression returns Expression : {WithClauseExpression} 
		////	withclause=WithClause expr = BlockExpression 
		////	;
		////WithContextExpression returns Expresion : {WithContextExpression } 
		////	"with" "context" context = Expression expr = BlockExpression
		////	;
		public ParserRule getRule() { return rule; }

		//FeatureCall|ConstructorCallExpression|VariableValue|Literal|PropertyValue|
		//KeywordVariables|ParanthesizedExpression|IfExpression|BlockExpression|
		//SwitchExpression|ThrowExpression|TryCatchExpression|WildcardExpression 
		//		
		//    
		//	  
		//	  
		//	  
		//	   
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		//	  
		////	| WithExpression
		//	 
		//	
		////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
		////WithClauseExpression returns Expression : {WithClauseExpression} 
		////	withclause=WithClause expr = BlockExpression 
		////	;
		////WithContextExpression returns Expresion : {WithContextExpression } 
		////	"with" "context" context = Expression expr = BlockExpression
		////	;
		public Alternatives getAlternatives() { return cAlternatives; }

		//FeatureCall
		public RuleCall getFeatureCallParserRuleCall_0() { return cFeatureCallParserRuleCall_0; }

		//ConstructorCallExpression
		public RuleCall getConstructorCallExpressionParserRuleCall_1() { return cConstructorCallExpressionParserRuleCall_1; }

		//VariableValue
		public RuleCall getVariableValueParserRuleCall_2() { return cVariableValueParserRuleCall_2; }

		//Literal
		public RuleCall getLiteralParserRuleCall_3() { return cLiteralParserRuleCall_3; }

		//PropertyValue
		public RuleCall getPropertyValueParserRuleCall_4() { return cPropertyValueParserRuleCall_4; }

		//KeywordVariables
		public RuleCall getKeywordVariablesParserRuleCall_5() { return cKeywordVariablesParserRuleCall_5; }

		//ParanthesizedExpression
		public RuleCall getParanthesizedExpressionParserRuleCall_6() { return cParanthesizedExpressionParserRuleCall_6; }

		//IfExpression
		public RuleCall getIfExpressionParserRuleCall_7() { return cIfExpressionParserRuleCall_7; }

		//BlockExpression
		public RuleCall getBlockExpressionParserRuleCall_8() { return cBlockExpressionParserRuleCall_8; }

		//SwitchExpression
		public RuleCall getSwitchExpressionParserRuleCall_9() { return cSwitchExpressionParserRuleCall_9; }

		//ThrowExpression
		public RuleCall getThrowExpressionParserRuleCall_10() { return cThrowExpressionParserRuleCall_10; }

		//TryCatchExpression
		public RuleCall getTryCatchExpressionParserRuleCall_11() { return cTryCatchExpressionParserRuleCall_11; }

		//WildcardExpression   
		////	| WithExpression
		public RuleCall getWildcardExpressionParserRuleCall_12() { return cWildcardExpressionParserRuleCall_12; }
	}

	public class WildcardExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WildcardExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralAnyAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword c_Keyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//WildcardExpression returns be::BExpression:
		//  {be::BLiteralAny} "_"; 
		//	
		////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
		////WithClauseExpression returns Expression : {WithClauseExpression} 
		////	withclause=WithClause expr = BlockExpression 
		////	;
		////WithContextExpression returns Expresion : {WithContextExpression } 
		////	"with" "context" context = Expression expr = BlockExpression
		////	;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralAny} "_"
		public Group getGroup() { return cGroup; }

		//{be::BLiteralAny}
		public Action getBLiteralAnyAction_0() { return cBLiteralAnyAction_0; }

		//"_"
		public Keyword get_Keyword_1() { return c_Keyword_1; }
	}

	public class ThrowExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ThrowExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBThrowExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cThrowKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//ThrowExpression returns be::BExpression:
		//  {be::BThrowExpression} "throw" expr=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BThrowExpression} "throw" expr=Expression
		public Group getGroup() { return cGroup; }

		//{be::BThrowExpression}
		public Action getBThrowExpressionAction_0() { return cBThrowExpressionAction_0; }

		//"throw"
		public Keyword getThrowKeyword_1() { return cThrowKeyword_1; }

		//expr=Expression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }
	}

	public class TryCatchExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TryCatchExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBTryExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTryKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTryExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTryExprExpressionParserRuleCall_2_0 = (RuleCall)cTryExprAssignment_2.eContents().get(0);
		private final Assignment cCatchBlocksAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCatchBlocksCatchBlockParserRuleCall_3_0 = (RuleCall)cCatchBlocksAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cFinallyKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cFinallyExprAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cFinallyExprExpressionParserRuleCall_4_1_0 = (RuleCall)cFinallyExprAssignment_4_1.eContents().get(0);
		private final Keyword cEndtryKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//TryCatchExpression returns be::BExpression:
		//  {be::BTryExpression} "try" tryExpr=Expression catchBlocks+=CatchBlock* ("finally"
		//  finallyExpr=Expression)? "endtry";
		public ParserRule getRule() { return rule; }

		//{be::BTryExpression} "try" tryExpr=Expression catchBlocks+=CatchBlock* ("finally"
		//finallyExpr=Expression)? "endtry"
		public Group getGroup() { return cGroup; }

		//{be::BTryExpression}
		public Action getBTryExpressionAction_0() { return cBTryExpressionAction_0; }

		//"try"
		public Keyword getTryKeyword_1() { return cTryKeyword_1; }

		//tryExpr=Expression
		public Assignment getTryExprAssignment_2() { return cTryExprAssignment_2; }

		//Expression
		public RuleCall getTryExprExpressionParserRuleCall_2_0() { return cTryExprExpressionParserRuleCall_2_0; }

		//catchBlocks+=CatchBlock*
		public Assignment getCatchBlocksAssignment_3() { return cCatchBlocksAssignment_3; }

		//CatchBlock
		public RuleCall getCatchBlocksCatchBlockParserRuleCall_3_0() { return cCatchBlocksCatchBlockParserRuleCall_3_0; }

		//("finally" finallyExpr=Expression)?
		public Group getGroup_4() { return cGroup_4; }

		//"finally"
		public Keyword getFinallyKeyword_4_0() { return cFinallyKeyword_4_0; }

		//finallyExpr=Expression
		public Assignment getFinallyExprAssignment_4_1() { return cFinallyExprAssignment_4_1; }

		//Expression
		public RuleCall getFinallyExprExpressionParserRuleCall_4_1_0() { return cFinallyExprExpressionParserRuleCall_4_1_0; }

		//"endtry"
		public Keyword getEndtryKeyword_5() { return cEndtryKeyword_5; }
	}

	public class CatchBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CatchBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBCatchAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCatchKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExceptionTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExceptionTypeTypeRefParserRuleCall_2_0 = (RuleCall)cExceptionTypeAssignment_2.eContents().get(0);
		private final Assignment cVarnameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarnameIDTerminalRuleCall_3_0 = (RuleCall)cVarnameAssignment_3.eContents().get(0);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCatchExprAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCatchExprExpressionParserRuleCall_5_0 = (RuleCall)cCatchExprAssignment_5.eContents().get(0);
		
		//CatchBlock returns be::BCatch:
		//  {be::BCatch} "catch" exceptionType=TypeRef varname=ID ":" catchExpr=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BCatch} "catch" exceptionType=TypeRef varname=ID ":" catchExpr=Expression
		public Group getGroup() { return cGroup; }

		//{be::BCatch}
		public Action getBCatchAction_0() { return cBCatchAction_0; }

		//"catch"
		public Keyword getCatchKeyword_1() { return cCatchKeyword_1; }

		//exceptionType=TypeRef
		public Assignment getExceptionTypeAssignment_2() { return cExceptionTypeAssignment_2; }

		//TypeRef
		public RuleCall getExceptionTypeTypeRefParserRuleCall_2_0() { return cExceptionTypeTypeRefParserRuleCall_2_0; }

		//varname=ID
		public Assignment getVarnameAssignment_3() { return cVarnameAssignment_3; }

		//ID
		public RuleCall getVarnameIDTerminalRuleCall_3_0() { return cVarnameIDTerminalRuleCall_3_0; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//catchExpr=Expression
		public Assignment getCatchExprAssignment_5() { return cCatchExprAssignment_5; }

		//Expression
		public RuleCall getCatchExprExpressionParserRuleCall_5_0() { return cCatchExprExpressionParserRuleCall_5_0; }
	}

	public class SwitchExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SwitchExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBSwitchExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSwitchKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSwitchExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSwitchExpressionExpressionParserRuleCall_2_0 = (RuleCall)cSwitchExpressionAssignment_2.eContents().get(0);
		private final Assignment cCaseListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCaseListCaseParserRuleCall_3_0 = (RuleCall)cCaseListAssignment_3.eContents().get(0);
		private final Keyword cEndswitchKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SwitchExpression returns be::BExpression:
		//  {be::BSwitchExpression} "switch" switchExpression=Expression? caseList+=Case+
		//  "endswitch";
		public ParserRule getRule() { return rule; }

		//{be::BSwitchExpression} "switch" switchExpression=Expression? caseList+=Case+
		//"endswitch"
		public Group getGroup() { return cGroup; }

		//{be::BSwitchExpression}
		public Action getBSwitchExpressionAction_0() { return cBSwitchExpressionAction_0; }

		//"switch"
		public Keyword getSwitchKeyword_1() { return cSwitchKeyword_1; }

		//switchExpression=Expression?
		public Assignment getSwitchExpressionAssignment_2() { return cSwitchExpressionAssignment_2; }

		//Expression
		public RuleCall getSwitchExpressionExpressionParserRuleCall_2_0() { return cSwitchExpressionExpressionParserRuleCall_2_0; }

		//caseList+=Case+
		public Assignment getCaseListAssignment_3() { return cCaseListAssignment_3; }

		//Case
		public RuleCall getCaseListCaseParserRuleCall_3_0() { return cCaseListCaseParserRuleCall_3_0; }

		//"endswitch"
		public Keyword getEndswitchKeyword_4() { return cEndswitchKeyword_4; }
	}

	public class CaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Case");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBCaseAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCaseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExprExpressionParserRuleCall_2_0 = (RuleCall)cConditionExprAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenExprExpressionParserRuleCall_4_0 = (RuleCall)cThenExprAssignment_4.eContents().get(0);
		
		//Case returns be::BCase:
		//  {be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression; 
		//			
		//	               
		//
		//// TODO VAREXPR: Blockexpression can have local variables
		public ParserRule getRule() { return rule; }

		//{be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression
		public Group getGroup() { return cGroup; }

		//{be::BCase}
		public Action getBCaseAction_0() { return cBCaseAction_0; }

		//"case"
		public Keyword getCaseKeyword_1() { return cCaseKeyword_1; }

		//conditionExpr=Expression
		public Assignment getConditionExprAssignment_2() { return cConditionExprAssignment_2; }

		//Expression
		public RuleCall getConditionExprExpressionParserRuleCall_2_0() { return cConditionExprExpressionParserRuleCall_2_0; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//thenExpr=Expression
		public Assignment getThenExprAssignment_4() { return cThenExprAssignment_4; }

		//Expression
		public RuleCall getThenExprExpressionParserRuleCall_4_0() { return cThenExprExpressionParserRuleCall_4_0; }
	}

	public class BlockExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBChainedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpressionsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionsTopLevelExpressionParserRuleCall_2_0_0 = (RuleCall)cExpressionsAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BlockExpression returns be::BExpression:
		//  {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"; 
		//
		//// TODO VAREXPR: Blockexpression can have local variables
		public ParserRule getRule() { return rule; }

		//{be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"
		public Group getGroup() { return cGroup; }

		//{be::BChainedExpression}
		public Action getBChainedExpressionAction_0() { return cBChainedExpressionAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(expressions+=TopLevelExpression ";")*
		public Group getGroup_2() { return cGroup_2; }

		//expressions+=TopLevelExpression
		public Assignment getExpressionsAssignment_2_0() { return cExpressionsAssignment_2_0; }

		//TopLevelExpression
		public RuleCall getExpressionsTopLevelExpressionParserRuleCall_2_0_0() { return cExpressionsTopLevelExpressionParserRuleCall_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class IfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBIfExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExprExpressionParserRuleCall_2_0 = (RuleCall)cConditionExprAssignment_2.eContents().get(0);
		private final Keyword cThenKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenExprExpressionParserRuleCall_4_0 = (RuleCall)cThenExprAssignment_4.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cElseExprAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cElseExprElseIfExpressionParserRuleCall_5_0_0 = (RuleCall)cElseExprAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cElseKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cElseExprAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cElseExprExpressionParserRuleCall_5_1_1_0 = (RuleCall)cElseExprAssignment_5_1_1.eContents().get(0);
		private final Keyword cEndifKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IfExpression returns be::BExpression:
		//  {be::BIfExpression} "if" conditionExpr=Expression "then" thenExpr=Expression (
		//  elseExpr=ElseIfExpression|"else" elseExpr=Expression)? "endif";
		public ParserRule getRule() { return rule; }

		//{be::BIfExpression} "if" conditionExpr=Expression "then" thenExpr=Expression (
		//elseExpr=ElseIfExpression|"else" elseExpr=Expression)? "endif"
		public Group getGroup() { return cGroup; }

		//{be::BIfExpression}
		public Action getBIfExpressionAction_0() { return cBIfExpressionAction_0; }

		//"if"
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }

		//conditionExpr=Expression
		public Assignment getConditionExprAssignment_2() { return cConditionExprAssignment_2; }

		//Expression
		public RuleCall getConditionExprExpressionParserRuleCall_2_0() { return cConditionExprExpressionParserRuleCall_2_0; }

		//"then"
		public Keyword getThenKeyword_3() { return cThenKeyword_3; }

		//thenExpr=Expression
		public Assignment getThenExprAssignment_4() { return cThenExprAssignment_4; }

		//Expression
		public RuleCall getThenExprExpressionParserRuleCall_4_0() { return cThenExprExpressionParserRuleCall_4_0; }

		//(elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//elseExpr=ElseIfExpression
		public Assignment getElseExprAssignment_5_0() { return cElseExprAssignment_5_0; }

		//ElseIfExpression
		public RuleCall getElseExprElseIfExpressionParserRuleCall_5_0_0() { return cElseExprElseIfExpressionParserRuleCall_5_0_0; }

		//"else" elseExpr=Expression
		public Group getGroup_5_1() { return cGroup_5_1; }

		//"else"
		public Keyword getElseKeyword_5_1_0() { return cElseKeyword_5_1_0; }

		//elseExpr=Expression
		public Assignment getElseExprAssignment_5_1_1() { return cElseExprAssignment_5_1_1; }

		//Expression
		public RuleCall getElseExprExpressionParserRuleCall_5_1_1_0() { return cElseExprExpressionParserRuleCall_5_1_1_0; }

		//"endif"
		public Keyword getEndifKeyword_6() { return cEndifKeyword_6; }
	}

	public class ElseIfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElseIfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBIfExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cElseifKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExprExpressionParserRuleCall_2_0 = (RuleCall)cConditionExprAssignment_2.eContents().get(0);
		private final Keyword cThenKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenExprExpressionParserRuleCall_4_0 = (RuleCall)cThenExprAssignment_4.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cElseExprAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cElseExprElseIfExpressionParserRuleCall_5_0_0 = (RuleCall)cElseExprAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cElseKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cElseExprAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cElseExprExpressionParserRuleCall_5_1_1_0 = (RuleCall)cElseExprAssignment_5_1_1.eContents().get(0);
		
		//ElseIfExpression returns be::BExpression:
		//  {be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression (
		//  elseExpr=ElseIfExpression|"else" elseExpr=Expression)?;
		public ParserRule getRule() { return rule; }

		//{be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression (
		//elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
		public Group getGroup() { return cGroup; }

		//{be::BIfExpression}
		public Action getBIfExpressionAction_0() { return cBIfExpressionAction_0; }

		//"elseif"
		public Keyword getElseifKeyword_1() { return cElseifKeyword_1; }

		//conditionExpr=Expression
		public Assignment getConditionExprAssignment_2() { return cConditionExprAssignment_2; }

		//Expression
		public RuleCall getConditionExprExpressionParserRuleCall_2_0() { return cConditionExprExpressionParserRuleCall_2_0; }

		//"then"
		public Keyword getThenKeyword_3() { return cThenKeyword_3; }

		//thenExpr=Expression
		public Assignment getThenExprAssignment_4() { return cThenExprAssignment_4; }

		//Expression
		public RuleCall getThenExprExpressionParserRuleCall_4_0() { return cThenExprExpressionParserRuleCall_4_0; }

		//(elseExpr=ElseIfExpression|"else" elseExpr=Expression)?
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//elseExpr=ElseIfExpression
		public Assignment getElseExprAssignment_5_0() { return cElseExprAssignment_5_0; }

		//ElseIfExpression
		public RuleCall getElseExprElseIfExpressionParserRuleCall_5_0_0() { return cElseExprElseIfExpressionParserRuleCall_5_0_0; }

		//"else" elseExpr=Expression
		public Group getGroup_5_1() { return cGroup_5_1; }

		//"else"
		public Keyword getElseKeyword_5_1_0() { return cElseKeyword_5_1_0; }

		//elseExpr=Expression
		public Assignment getElseExprAssignment_5_1_1() { return cElseExprAssignment_5_1_1; }

		//Expression
		public RuleCall getElseExprExpressionParserRuleCall_5_1_1_0() { return cElseExprExpressionParserRuleCall_5_1_1_0; }
	}

	public class PropertyValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBVariableExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PropertyValue returns be::BExpression:
		//  {be::BVariableExpression} name=PID;
		public ParserRule getRule() { return rule; }

		//{be::BVariableExpression} name=PID
		public Group getGroup() { return cGroup; }

		//{be::BVariableExpression}
		public Action getBVariableExpressionAction_0() { return cBVariableExpressionAction_0; }

		//name=PID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_1_0() { return cNamePIDTerminalRuleCall_1_0; }
	}

	public class VariableValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBVariableExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//VariableValue returns be::BExpression:
		//  {be::BVariableExpression} name=ID;
		public ParserRule getRule() { return rule; }

		//{be::BVariableExpression} name=ID
		public Group getGroup() { return cGroup; }

		//{be::BVariableExpression}
		public Action getBVariableExpressionAction_0() { return cBVariableExpressionAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class KeywordVariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "KeywordVariables");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBVariableExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameInputKeywordParserRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameOutputKeywordParserRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final Keyword cNamePropertiesKeyword_1_0_2 = (Keyword)cNameAlternatives_1_0.eContents().get(2);
		private final Keyword cNameUnitKeyword_1_0_3 = (Keyword)cNameAlternatives_1_0.eContents().get(3);
		
		//KeywordVariables returns be::BExpression:
		//  {be::BVariableExpression} name=( InputKeyword | OutputKeyword | "properties" | "unit" );
		public ParserRule getRule() { return rule; }

		//{be::BVariableExpression} name=( InputKeyword | OutputKeyword | "properties" | "unit" )
		public Group getGroup() { return cGroup; }

		//{be::BVariableExpression}
		public Action getBVariableExpressionAction_0() { return cBVariableExpressionAction_0; }

		//name=( InputKeyword | OutputKeyword | "properties" | "unit" )
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//InputKeyword|OutputKeyword|"properties"|"unit"
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }

		//InputKeyword
		public RuleCall getNameInputKeywordParserRuleCall_1_0_0() { return cNameInputKeywordParserRuleCall_1_0_0; }

		//OutputKeyword
		public RuleCall getNameOutputKeywordParserRuleCall_1_0_1() { return cNameOutputKeywordParserRuleCall_1_0_1; }

		//"properties"
		public Keyword getNamePropertiesKeyword_1_0_2() { return cNamePropertiesKeyword_1_0_2; }

		//"unit"
		public Keyword getNameUnitKeyword_1_0_3() { return cNameUnitKeyword_1_0_3; }
	}

	public class FeatureCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeatureCall");
		private final RuleCall cOperationCallParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//FeatureCall returns be::BExpression:
		//  OperationCall;
		public ParserRule getRule() { return rule; }

		//OperationCall
		public RuleCall getOperationCallParserRuleCall() { return cOperationCallParserRuleCall; }
	}

	public class OperationCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperationCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBCallExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNamePIDTerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParameterListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParameterListParameterListParserRuleCall_3_0 = (RuleCall)cParameterListAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//OperationCall returns be::BCallExpression:
		//  {be::BCallExpression} name=( ID | PID ) "(" parameterList=ParameterList? ")";
		public ParserRule getRule() { return rule; }

		//{be::BCallExpression} name=( ID | PID ) "(" parameterList=ParameterList? ")"
		public Group getGroup() { return cGroup; }

		//{be::BCallExpression}
		public Action getBCallExpressionAction_0() { return cBCallExpressionAction_0; }

		//name=( ID | PID )
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID|PID
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_0() { return cNameIDTerminalRuleCall_1_0_0; }

		//PID
		public RuleCall getNamePIDTerminalRuleCall_1_0_1() { return cNamePIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//parameterList=ParameterList?
		public Assignment getParameterListAssignment_3() { return cParameterListAssignment_3; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_3_0() { return cParameterListParameterListParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class ConstructorCallExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstructorCallExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBCreateExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNewKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeExprLiteralTypeParserRuleCall_2_0 = (RuleCall)cTypeExprAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParameterListAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParameterListParameterListParserRuleCall_3_1_0 = (RuleCall)cParameterListAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cAsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cAliasAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cAliasIDTerminalRuleCall_4_1_0 = (RuleCall)cAliasAssignment_4_1.eContents().get(0);
		private final Assignment cContextBlockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cContextBlockContextBlockParserRuleCall_5_0 = (RuleCall)cContextBlockAssignment_5.eContents().get(0);
		
		//ConstructorCallExpression returns be::BExpression:
		//  {be::BCreateExpression} "new" typeExpr=LiteralType ("(" parameterList=ParameterList?
		//  ")")? ("as" alias=ID)? contextBlock=ContextBlock?;
		public ParserRule getRule() { return rule; }

		//{be::BCreateExpression} "new" typeExpr=LiteralType ("(" parameterList=ParameterList?
		//")")? ("as" alias=ID)? contextBlock=ContextBlock?
		public Group getGroup() { return cGroup; }

		//{be::BCreateExpression}
		public Action getBCreateExpressionAction_0() { return cBCreateExpressionAction_0; }

		//"new"
		public Keyword getNewKeyword_1() { return cNewKeyword_1; }

		//typeExpr=LiteralType
		public Assignment getTypeExprAssignment_2() { return cTypeExprAssignment_2; }

		//LiteralType
		public RuleCall getTypeExprLiteralTypeParserRuleCall_2_0() { return cTypeExprLiteralTypeParserRuleCall_2_0; }

		//("(" parameterList=ParameterList? ")")?
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//parameterList=ParameterList?
		public Assignment getParameterListAssignment_3_1() { return cParameterListAssignment_3_1; }

		//ParameterList
		public RuleCall getParameterListParameterListParserRuleCall_3_1_0() { return cParameterListParameterListParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }

		//("as" alias=ID)?
		public Group getGroup_4() { return cGroup_4; }

		//"as"
		public Keyword getAsKeyword_4_0() { return cAsKeyword_4_0; }

		//alias=ID
		public Assignment getAliasAssignment_4_1() { return cAliasAssignment_4_1; }

		//ID
		public RuleCall getAliasIDTerminalRuleCall_4_1_0() { return cAliasIDTerminalRuleCall_4_1_0; }

		//contextBlock=ContextBlock?
		public Assignment getContextBlockAssignment_5() { return cContextBlockAssignment_5; }

		//ContextBlock
		public RuleCall getContextBlockContextBlockParserRuleCall_5_0() { return cContextBlockContextBlockParserRuleCall_5_0; }
	}

	public class ContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Context");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cContextKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSelectorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSelectorContextSelectorParserRuleCall_1_0 = (RuleCall)cSelectorAssignment_1.eContents().get(0);
		private final Assignment cBlockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBlockContextBlockParserRuleCall_2_0 = (RuleCall)cBlockAssignment_2.eContents().get(0);
		
		//Context:
		//  "context" selector=ContextSelector block=ContextBlock;
		public ParserRule getRule() { return rule; }

		//"context" selector=ContextSelector block=ContextBlock
		public Group getGroup() { return cGroup; }

		//"context"
		public Keyword getContextKeyword_0() { return cContextKeyword_0; }

		//selector=ContextSelector
		public Assignment getSelectorAssignment_1() { return cSelectorAssignment_1; }

		//ContextSelector
		public RuleCall getSelectorContextSelectorParserRuleCall_1_0() { return cSelectorContextSelectorParserRuleCall_1_0; }

		//block=ContextBlock
		public Assignment getBlockAssignment_2() { return cBlockAssignment_2; }

		//ContextBlock
		public RuleCall getBlockContextBlockParserRuleCall_2_0() { return cBlockContextBlockParserRuleCall_2_0; }
	}

	public class ContextSelectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ContextSelector");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeRefSelectorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionSelectorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUnitSelectorParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ContextSelector:
		//  TypeRefSelector|ExpressionSelector|UnitSelector;
		public ParserRule getRule() { return rule; }

		//TypeRefSelector|ExpressionSelector|UnitSelector
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeRefSelector
		public RuleCall getTypeRefSelectorParserRuleCall_0() { return cTypeRefSelectorParserRuleCall_0; }

		//ExpressionSelector
		public RuleCall getExpressionSelectorParserRuleCall_1() { return cExpressionSelectorParserRuleCall_1; }

		//UnitSelector
		public RuleCall getUnitSelectorParserRuleCall_2() { return cUnitSelectorParserRuleCall_2; }
	}

	public class TypeRefSelectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeRefSelector");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTypeTypeRefParserRuleCall_0 = (RuleCall)cTypeAssignment.eContents().get(0);
		
		//TypeRefSelector returns ContextSelector:
		//  type=TypeRef;
		public ParserRule getRule() { return rule; }

		//type=TypeRef
		public Assignment getTypeAssignment() { return cTypeAssignment; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_0() { return cTypeTypeRefParserRuleCall_0; }
	}

	public class ExpressionSelectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionSelector");
		private final Assignment cExprAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_0 = (RuleCall)cExprAssignment.eContents().get(0);
		
		//ExpressionSelector:
		//  expr=Expression;
		public ParserRule getRule() { return rule; }

		//expr=Expression
		public Assignment getExprAssignment() { return cExprAssignment; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_0() { return cExprExpressionParserRuleCall_0; }
	}

	public class UnitSelectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitSelector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInterfaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInterfaceQIDParserRuleCall_1_0 = (RuleCall)cInterfaceAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cSolidusKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Assignment cNameAssignment_2_1_0 = (Assignment)cAlternatives_2_1.eContents().get(0);
		private final RuleCall cNameUnitNameParserRuleCall_2_1_0_0 = (RuleCall)cNameAssignment_2_1_0.eContents().get(0);
		private final Assignment cNamePatternAssignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cNamePatternREGULAR_EXPRTerminalRuleCall_2_1_1_0 = (RuleCall)cNamePatternAssignment_2_1_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cSolidusKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cVersionRangeAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cVersionRangeVersionRangeParserRuleCall_2_2_1_0 = (RuleCall)cVersionRangeAssignment_2_2_1.eContents().get(0);
		
		//UnitSelector:
		//  "unit" interface=QID ("/" (name=UnitName|namePattern=REGULAR_EXPR) ("/" versionRange=
		//  VersionRange)?)?;
		public ParserRule getRule() { return rule; }

		//"unit" interface=QID ("/" (name=UnitName|namePattern=REGULAR_EXPR) ("/" versionRange=
		//VersionRange)?)?
		public Group getGroup() { return cGroup; }

		//"unit"
		public Keyword getUnitKeyword_0() { return cUnitKeyword_0; }

		//interface=QID
		public Assignment getInterfaceAssignment_1() { return cInterfaceAssignment_1; }

		//QID
		public RuleCall getInterfaceQIDParserRuleCall_1_0() { return cInterfaceQIDParserRuleCall_1_0; }

		//("/" (name=UnitName|namePattern=REGULAR_EXPR) ("/" versionRange=VersionRange)?)?
		public Group getGroup_2() { return cGroup_2; }

		//"/"
		public Keyword getSolidusKeyword_2_0() { return cSolidusKeyword_2_0; }

		//name=UnitName|namePattern=REGULAR_EXPR
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//name=UnitName
		public Assignment getNameAssignment_2_1_0() { return cNameAssignment_2_1_0; }

		//UnitName
		public RuleCall getNameUnitNameParserRuleCall_2_1_0_0() { return cNameUnitNameParserRuleCall_2_1_0_0; }

		//namePattern=REGULAR_EXPR
		public Assignment getNamePatternAssignment_2_1_1() { return cNamePatternAssignment_2_1_1; }

		//REGULAR_EXPR
		public RuleCall getNamePatternREGULAR_EXPRTerminalRuleCall_2_1_1_0() { return cNamePatternREGULAR_EXPRTerminalRuleCall_2_1_1_0; }

		//("/" versionRange=VersionRange)?
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"/"
		public Keyword getSolidusKeyword_2_2_0() { return cSolidusKeyword_2_2_0; }

		//versionRange=VersionRange
		public Assignment getVersionRangeAssignment_2_2_1() { return cVersionRangeAssignment_2_2_1; }

		//VersionRange
		public RuleCall getVersionRangeVersionRangeParserRuleCall_2_2_1_0() { return cVersionRangeVersionRangeParserRuleCall_2_2_1_0; }
	}

	public class ContextBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ContextBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBChainedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cExpressionsAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cExpressionsFunctionDefinitionParserRuleCall_2_0_0 = (RuleCall)cExpressionsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cExpressionsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cExpressionsTopLevelExpressionParserRuleCall_2_1_0_0 = (RuleCall)cExpressionsAssignment_2_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ContextBlock returns be::BExpression:
		//  {be::BChainedExpression} "{" (expressions+=FunctionDefinition|expressions+=
		//  TopLevelExpression ";")* "}"; 
		//
		//         
		//	      
		////		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		//		     
		////		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		//		    
		//		
		//					
		////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
		////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = NamedPropertySet ;
		public ParserRule getRule() { return rule; }

		//{be::BChainedExpression} "{" (expressions+=FunctionDefinition|expressions+=
		//TopLevelExpression ";")* "}"    
		//	      
		////		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		//		     
		////		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		public Group getGroup() { return cGroup; }

		//{be::BChainedExpression}
		public Action getBChainedExpressionAction_0() { return cBChainedExpressionAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(expressions+=FunctionDefinition|expressions+=TopLevelExpression ";")*       
		////		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		//		     
		////		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//expressions+=FunctionDefinition
		public Assignment getExpressionsAssignment_2_0() { return cExpressionsAssignment_2_0; }

		//FunctionDefinition
		public RuleCall getExpressionsFunctionDefinitionParserRuleCall_2_0_0() { return cExpressionsFunctionDefinitionParserRuleCall_2_0_0; }

		//expressions+=TopLevelExpression ";"
		public Group getGroup_2_1() { return cGroup_2_1; }

		//expressions+=TopLevelExpression
		public Assignment getExpressionsAssignment_2_1_0() { return cExpressionsAssignment_2_1_0; }

		//TopLevelExpression
		public RuleCall getExpressionsTopLevelExpressionParserRuleCall_2_1_0_0() { return cExpressionsTopLevelExpressionParserRuleCall_2_1_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1_1() { return cSemicolonKeyword_2_1_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class FunctionDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBDefFunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionFunctionParserRuleCall_1_0 = (RuleCall)cFunctionAssignment_1.eContents().get(0);
		
		//FunctionDefinition returns be::BExpression:
		//  {be::BDefFunction} function=Function; 
		//					
		////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
		////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = NamedPropertySet ;
		//              
		////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
		public ParserRule getRule() { return rule; }

		//{be::BDefFunction} function=Function
		public Group getGroup() { return cGroup; }

		//{be::BDefFunction}
		public Action getBDefFunctionAction_0() { return cBDefFunctionAction_0; }

		//function=Function
		public Assignment getFunctionAssignment_1() { return cFunctionAssignment_1; }

		//Function
		public RuleCall getFunctionFunctionParserRuleCall_1_0() { return cFunctionFunctionParserRuleCall_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRegexpLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLiteralMapParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralListParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLiteralFunctionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Literal returns be::BExpression:
		//  ValueLiteral|RegexpLiteral|LiteralMap|LiteralList|LiteralFunction; 
		////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
		public ParserRule getRule() { return rule; }

		//ValueLiteral|RegexpLiteral|LiteralMap|LiteralList|LiteralFunction 
		////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
		public Alternatives getAlternatives() { return cAlternatives; }

		//ValueLiteral
		public RuleCall getValueLiteralParserRuleCall_0() { return cValueLiteralParserRuleCall_0; }

		//RegexpLiteral
		public RuleCall getRegexpLiteralParserRuleCall_1() { return cRegexpLiteralParserRuleCall_1; }

		//LiteralMap
		public RuleCall getLiteralMapParserRuleCall_2() { return cLiteralMapParserRuleCall_2; }

		//LiteralList
		public RuleCall getLiteralListParserRuleCall_3() { return cLiteralListParserRuleCall_3; }

		//LiteralFunction
		public RuleCall getLiteralFunctionParserRuleCall_4() { return cLiteralFunctionParserRuleCall_4; }
	}

	public class LiteralListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralList");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBLiteralListExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLessThanSignKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cEntryTypeAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cEntryTypeTypeRefParserRuleCall_0_2_1_0 = (RuleCall)cEntryTypeAssignment_0_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_0_2_2 = (Keyword)cGroup_0_2.eContents().get(2);
		private final Assignment cEntriesAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cEntriesExpressionParserRuleCall_0_3_0 = (RuleCall)cEntriesAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cCommaKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cEntriesAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cEntriesExpressionParserRuleCall_0_4_1_0 = (RuleCall)cEntriesAssignment_0_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBLiteralListExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cEntryTypeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cEntryTypeTypeRefParserRuleCall_1_3_0 = (RuleCall)cEntryTypeAssignment_1_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cRightSquareBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		
		//LiteralList returns be::BExpression:
		//  {be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
		//  entries+=Expression)* "]"|{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">"
		//  "]";
		public ParserRule getRule() { return rule; }

		//{be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
		//entries+=Expression)* "]"|{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">"
		//"]"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
		//entries+=Expression)* "]"
		public Group getGroup_0() { return cGroup_0; }

		//{be::BLiteralListExpression}
		public Action getBLiteralListExpressionAction_0_0() { return cBLiteralListExpressionAction_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_1() { return cLeftSquareBracketKeyword_0_1; }

		//("<" entryType=TypeRef ">")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"<"
		public Keyword getLessThanSignKeyword_0_2_0() { return cLessThanSignKeyword_0_2_0; }

		//entryType=TypeRef
		public Assignment getEntryTypeAssignment_0_2_1() { return cEntryTypeAssignment_0_2_1; }

		//TypeRef
		public RuleCall getEntryTypeTypeRefParserRuleCall_0_2_1_0() { return cEntryTypeTypeRefParserRuleCall_0_2_1_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_0_2_2() { return cGreaterThanSignKeyword_0_2_2; }

		//entries+=Expression
		public Assignment getEntriesAssignment_0_3() { return cEntriesAssignment_0_3; }

		//Expression
		public RuleCall getEntriesExpressionParserRuleCall_0_3_0() { return cEntriesExpressionParserRuleCall_0_3_0; }

		//("," entries+=Expression)*
		public Group getGroup_0_4() { return cGroup_0_4; }

		//","
		public Keyword getCommaKeyword_0_4_0() { return cCommaKeyword_0_4_0; }

		//entries+=Expression
		public Assignment getEntriesAssignment_0_4_1() { return cEntriesAssignment_0_4_1; }

		//Expression
		public RuleCall getEntriesExpressionParserRuleCall_0_4_1_0() { return cEntriesExpressionParserRuleCall_0_4_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_5() { return cRightSquareBracketKeyword_0_5; }

		//{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">" "]"
		public Group getGroup_1() { return cGroup_1; }

		//{be::BLiteralListExpression}
		public Action getBLiteralListExpressionAction_1_0() { return cBLiteralListExpressionAction_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_2() { return cLessThanSignKeyword_1_2; }

		//entryType=TypeRef
		public Assignment getEntryTypeAssignment_1_3() { return cEntryTypeAssignment_1_3; }

		//TypeRef
		public RuleCall getEntryTypeTypeRefParserRuleCall_1_3_0() { return cEntryTypeTypeRefParserRuleCall_1_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_4() { return cGreaterThanSignKeyword_1_4; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_5() { return cRightSquareBracketKeyword_1_5; }
	}

	public class LiteralMapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralMap");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBLiteralMapExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLessThanSignKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cKeyTypeAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cKeyTypeTypeRefParserRuleCall_0_2_1_0 = (RuleCall)cKeyTypeAssignment_0_2_1.eContents().get(0);
		private final Keyword cCommaKeyword_0_2_2 = (Keyword)cGroup_0_2.eContents().get(2);
		private final Assignment cValueTypeAssignment_0_2_3 = (Assignment)cGroup_0_2.eContents().get(3);
		private final RuleCall cValueTypeTypeRefParserRuleCall_0_2_3_0 = (RuleCall)cValueTypeAssignment_0_2_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_0_2_4 = (Keyword)cGroup_0_2.eContents().get(4);
		private final Assignment cEntriesAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cEntriesMapEntryParserRuleCall_0_3_0 = (RuleCall)cEntriesAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cCommaKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cEntriesAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cEntriesMapEntryParserRuleCall_0_4_1_0 = (RuleCall)cEntriesAssignment_0_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBLiteralMapExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cKeyTypeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cKeyTypeTypeRefParserRuleCall_1_3_0 = (RuleCall)cKeyTypeAssignment_1_3.eContents().get(0);
		private final Keyword cCommaKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cValueTypeAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cValueTypeTypeRefParserRuleCall_1_5_0 = (RuleCall)cValueTypeAssignment_1_5.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		private final Keyword cRightSquareBracketKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		
		//LiteralMap returns be::BExpression:
		//  {be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
		//  entries+=MapEntry ("," entries+=MapEntry)* "]"|{be::BLiteralMapExpression} "[" "<"
		//  keyType=TypeRef "," valueType=TypeRef ">" "]";
		public ParserRule getRule() { return rule; }

		//{be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
		//entries+=MapEntry ("," entries+=MapEntry)* "]"|{be::BLiteralMapExpression} "[" "<"
		//keyType=TypeRef "," valueType=TypeRef ">" "]"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
		//entries+=MapEntry ("," entries+=MapEntry)* "]"
		public Group getGroup_0() { return cGroup_0; }

		//{be::BLiteralMapExpression}
		public Action getBLiteralMapExpressionAction_0_0() { return cBLiteralMapExpressionAction_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_1() { return cLeftSquareBracketKeyword_0_1; }

		//("<" keyType=TypeRef "," valueType=TypeRef ">")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"<"
		public Keyword getLessThanSignKeyword_0_2_0() { return cLessThanSignKeyword_0_2_0; }

		//keyType=TypeRef
		public Assignment getKeyTypeAssignment_0_2_1() { return cKeyTypeAssignment_0_2_1; }

		//TypeRef
		public RuleCall getKeyTypeTypeRefParserRuleCall_0_2_1_0() { return cKeyTypeTypeRefParserRuleCall_0_2_1_0; }

		//","
		public Keyword getCommaKeyword_0_2_2() { return cCommaKeyword_0_2_2; }

		//valueType=TypeRef
		public Assignment getValueTypeAssignment_0_2_3() { return cValueTypeAssignment_0_2_3; }

		//TypeRef
		public RuleCall getValueTypeTypeRefParserRuleCall_0_2_3_0() { return cValueTypeTypeRefParserRuleCall_0_2_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_0_2_4() { return cGreaterThanSignKeyword_0_2_4; }

		//entries+=MapEntry
		public Assignment getEntriesAssignment_0_3() { return cEntriesAssignment_0_3; }

		//MapEntry
		public RuleCall getEntriesMapEntryParserRuleCall_0_3_0() { return cEntriesMapEntryParserRuleCall_0_3_0; }

		//("," entries+=MapEntry)*
		public Group getGroup_0_4() { return cGroup_0_4; }

		//","
		public Keyword getCommaKeyword_0_4_0() { return cCommaKeyword_0_4_0; }

		//entries+=MapEntry
		public Assignment getEntriesAssignment_0_4_1() { return cEntriesAssignment_0_4_1; }

		//MapEntry
		public RuleCall getEntriesMapEntryParserRuleCall_0_4_1_0() { return cEntriesMapEntryParserRuleCall_0_4_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_5() { return cRightSquareBracketKeyword_0_5; }

		//{be::BLiteralMapExpression} "[" "<" keyType=TypeRef "," valueType=TypeRef ">" "]"
		public Group getGroup_1() { return cGroup_1; }

		//{be::BLiteralMapExpression}
		public Action getBLiteralMapExpressionAction_1_0() { return cBLiteralMapExpressionAction_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_2() { return cLessThanSignKeyword_1_2; }

		//keyType=TypeRef
		public Assignment getKeyTypeAssignment_1_3() { return cKeyTypeAssignment_1_3; }

		//TypeRef
		public RuleCall getKeyTypeTypeRefParserRuleCall_1_3_0() { return cKeyTypeTypeRefParserRuleCall_1_3_0; }

		//","
		public Keyword getCommaKeyword_1_4() { return cCommaKeyword_1_4; }

		//valueType=TypeRef
		public Assignment getValueTypeAssignment_1_5() { return cValueTypeAssignment_1_5; }

		//TypeRef
		public RuleCall getValueTypeTypeRefParserRuleCall_1_5_0() { return cValueTypeTypeRefParserRuleCall_1_5_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_6() { return cGreaterThanSignKeyword_1_6; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_7() { return cRightSquareBracketKeyword_1_7; }
	}

	public class LiteralFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3FunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLessThanSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cReturnTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cReturnTypeTypeRefParserRuleCall_2_1_0 = (RuleCall)cReturnTypeAssignment_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_3_0_0 = (RuleCall)cParametersAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParametersAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_3_1_1_0 = (RuleCall)cParametersAssignment_3_1_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFuncExprAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFuncExprOneOrManyExpressionsParserRuleCall_5_0 = (RuleCall)cFuncExprAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//LiteralFunction returns be::BExpression:
		//  {be::B3Function} "{" ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (
		//  "," parameters+=ParameterDeclaration)*)? "|" funcExpr=OneOrManyExpressions "}";
		public ParserRule getRule() { return rule; }

		//{be::B3Function} "{" ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (
		//"," parameters+=ParameterDeclaration)*)? "|" funcExpr=OneOrManyExpressions "}"
		public Group getGroup() { return cGroup; }

		//{be::B3Function}
		public Action getB3FunctionAction_0() { return cB3FunctionAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//("<" returnType=TypeRef ">")?
		public Group getGroup_2() { return cGroup_2; }

		//"<"
		public Keyword getLessThanSignKeyword_2_0() { return cLessThanSignKeyword_2_0; }

		//returnType=TypeRef
		public Assignment getReturnTypeAssignment_2_1() { return cReturnTypeAssignment_2_1; }

		//TypeRef
		public RuleCall getReturnTypeTypeRefParserRuleCall_2_1_0() { return cReturnTypeTypeRefParserRuleCall_2_1_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_2_2() { return cGreaterThanSignKeyword_2_2; }

		//(parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)*)?
		public Group getGroup_3() { return cGroup_3; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_3_0() { return cParametersAssignment_3_0; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_3_0_0() { return cParametersParameterDeclarationParserRuleCall_3_0_0; }

		//("," parameters+=ParameterDeclaration)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_3_1_1() { return cParametersAssignment_3_1_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_3_1_1_0() { return cParametersParameterDeclarationParserRuleCall_3_1_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_4() { return cVerticalLineKeyword_4; }

		//funcExpr=OneOrManyExpressions
		public Assignment getFuncExprAssignment_5() { return cFuncExprAssignment_5; }

		//OneOrManyExpressions
		public RuleCall getFuncExprOneOrManyExpressionsParserRuleCall_5_0() { return cFuncExprOneOrManyExpressionsParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class ClosureExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClosureExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cB3FunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cReturnTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cReturnTypeTypeRefParserRuleCall_1_1_0 = (RuleCall)cReturnTypeAssignment_1_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParametersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_2_0_0 = (RuleCall)cParametersAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParametersParameterDeclarationParserRuleCall_2_1_1_0 = (RuleCall)cParametersAssignment_2_1_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFuncExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFuncExprOneOrManyExpressionsParserRuleCall_4_0 = (RuleCall)cFuncExprAssignment_4.eContents().get(0);
		
		//ClosureExpression returns be::BExpression:
		//  {be::B3Function} ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (","
		//  parameters+=ParameterDeclaration)*)? "|" funcExpr=OneOrManyExpressions;
		public ParserRule getRule() { return rule; }

		//{be::B3Function} ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (","
		//parameters+=ParameterDeclaration)*)? "|" funcExpr=OneOrManyExpressions
		public Group getGroup() { return cGroup; }

		//{be::B3Function}
		public Action getB3FunctionAction_0() { return cB3FunctionAction_0; }

		//("<" returnType=TypeRef ">")?
		public Group getGroup_1() { return cGroup_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0() { return cLessThanSignKeyword_1_0; }

		//returnType=TypeRef
		public Assignment getReturnTypeAssignment_1_1() { return cReturnTypeAssignment_1_1; }

		//TypeRef
		public RuleCall getReturnTypeTypeRefParserRuleCall_1_1_0() { return cReturnTypeTypeRefParserRuleCall_1_1_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_2() { return cGreaterThanSignKeyword_1_2; }

		//(parameters+=ParameterDeclaration ("," parameters+=ParameterDeclaration)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_2_0() { return cParametersAssignment_2_0; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_2_0_0() { return cParametersParameterDeclarationParserRuleCall_2_0_0; }

		//("," parameters+=ParameterDeclaration)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameters+=ParameterDeclaration
		public Assignment getParametersAssignment_2_1_1() { return cParametersAssignment_2_1_1; }

		//ParameterDeclaration
		public RuleCall getParametersParameterDeclarationParserRuleCall_2_1_1_0() { return cParametersParameterDeclarationParserRuleCall_2_1_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }

		//funcExpr=OneOrManyExpressions
		public Assignment getFuncExprAssignment_4() { return cFuncExprAssignment_4; }

		//OneOrManyExpressions
		public RuleCall getFuncExprOneOrManyExpressionsParserRuleCall_4_0() { return cFuncExprOneOrManyExpressionsParserRuleCall_4_0; }
	}

	public class OneOrManyExpressionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OneOrManyExpressions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockExpressionWithoutBracketsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//OneOrManyExpressions returns be::BExpression:
		//  BlockExpressionWithoutBrackets|Expression; 
		//
		//    
		//	  
		//	  
		//	
		//// TODO VAREXPR - can have variable definitions
		public ParserRule getRule() { return rule; }

		//BlockExpressionWithoutBrackets|Expression 
		//
		//    
		//	  
		//	  
		//	
		//// TODO VAREXPR - can have variable definitions
		public Alternatives getAlternatives() { return cAlternatives; }

		//BlockExpressionWithoutBrackets
		public RuleCall getBlockExpressionWithoutBracketsParserRuleCall_0() { return cBlockExpressionWithoutBracketsParserRuleCall_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}

	public class BlockExpressionWithoutBracketsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockExpressionWithoutBrackets");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBChainedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionsTopLevelExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionsAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//BlockExpressionWithoutBrackets returns be::BExpression:
		//  {be::BChainedExpression} (expressions+=TopLevelExpression ";")+; 
		//// TODO VAREXPR - can have variable definitions
		public ParserRule getRule() { return rule; }

		//{be::BChainedExpression} (expressions+=TopLevelExpression ";")+
		public Group getGroup() { return cGroup; }

		//{be::BChainedExpression}
		public Action getBChainedExpressionAction_0() { return cBChainedExpressionAction_0; }

		//(expressions+=TopLevelExpression ";")+
		public Group getGroup_1() { return cGroup_1; }

		//expressions+=TopLevelExpression
		public Assignment getExpressionsAssignment_1_0() { return cExpressionsAssignment_1_0; }

		//TopLevelExpression
		public RuleCall getExpressionsTopLevelExpressionParserRuleCall_1_0_0() { return cExpressionsTopLevelExpressionParserRuleCall_1_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}

	public class MapEntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MapEntry");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBMapEntryAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cKeyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKeyKeyLiteralParserRuleCall_1_0 = (RuleCall)cKeyAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//MapEntry returns be::BMapEntry:
		//  {be::BMapEntry} key=KeyLiteral ":" value=Expression;
		public ParserRule getRule() { return rule; }

		//{be::BMapEntry} key=KeyLiteral ":" value=Expression
		public Group getGroup() { return cGroup; }

		//{be::BMapEntry}
		public Action getBMapEntryAction_0() { return cBMapEntryAction_0; }

		//key=KeyLiteral
		public Assignment getKeyAssignment_1() { return cKeyAssignment_1; }

		//KeyLiteral
		public RuleCall getKeyKeyLiteralParserRuleCall_1_0() { return cKeyKeyLiteralParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
	}

	public class KeyLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "KeyLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cValueAlternatives_1_0 = (Alternatives)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueIDTerminalRuleCall_1_0_0 = (RuleCall)cValueAlternatives_1_0.eContents().get(0);
		private final RuleCall cValuePIDTerminalRuleCall_1_0_1 = (RuleCall)cValueAlternatives_1_0.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0_2 = (RuleCall)cValueAlternatives_1_0.eContents().get(2);
		
		//KeyLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=( ID | PID | STRING );
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=( ID | PID | STRING )
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=( ID | PID | STRING )
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//ID|PID|STRING
		public Alternatives getValueAlternatives_1_0() { return cValueAlternatives_1_0; }

		//ID
		public RuleCall getValueIDTerminalRuleCall_1_0_0() { return cValueIDTerminalRuleCall_1_0_0; }

		//PID
		public RuleCall getValuePIDTerminalRuleCall_1_0_1() { return cValuePIDTerminalRuleCall_1_0_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0_2() { return cValueSTRINGTerminalRuleCall_1_0_2; }
	}

	public class LiteralTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeRefParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		
		//LiteralType returns be::BExpression:
		//  {be::BLiteralType} type=TypeRef;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralType} type=TypeRef
		public Group getGroup() { return cGroup; }

		//{be::BLiteralType}
		public Action getBLiteralTypeAction_0() { return cBLiteralTypeAction_0; }

		//type=TypeRef
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//TypeRef
		public RuleCall getTypeTypeRefParserRuleCall_1_0() { return cTypeTypeRefParserRuleCall_1_0; }
	}

	public class ValueLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRealLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegerLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNullLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStringLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cUnitLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//ValueLiteral returns be::BExpression:
		//  BooleanLiteral|RealLiteral|IntegerLiteral|NullLiteral|StringLiteral|UnitLiteral; 
		//
		//     
		//	   
		//	     // SEE ISSUE 297089 - must be placed before IntegerLiteral
		//	    
		//	   
		//	  
		////	| QueryLiteral
		public ParserRule getRule() { return rule; }

		//BooleanLiteral|RealLiteral|IntegerLiteral|NullLiteral|StringLiteral|UnitLiteral 
		//
		//     
		//	   
		//	     // SEE ISSUE 297089 - must be placed before IntegerLiteral
		//	    
		//	   
		//	  
		////	| QueryLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }

		//RealLiteral      // SEE ISSUE 297089 - must be placed before IntegerLiteral
		public RuleCall getRealLiteralParserRuleCall_1() { return cRealLiteralParserRuleCall_1; }

		//IntegerLiteral
		public RuleCall getIntegerLiteralParserRuleCall_2() { return cIntegerLiteralParserRuleCall_2; }

		//NullLiteral
		public RuleCall getNullLiteralParserRuleCall_3() { return cNullLiteralParserRuleCall_3; }

		//StringLiteral   
		////	| QueryLiteral
		public RuleCall getStringLiteralParserRuleCall_4() { return cStringLiteralParserRuleCall_4; }

		//UnitLiteral
		public RuleCall getUnitLiteralParserRuleCall_5() { return cUnitLiteralParserRuleCall_5; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBooleanValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//BooleanLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=BooleanValue;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=BooleanValue
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=BooleanValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//BooleanValue
		public RuleCall getValueBooleanValueParserRuleCall_1_0() { return cValueBooleanValueParserRuleCall_1_0; }
	}

	public class IntegerLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueIntValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//IntegerLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=IntValue;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=IntValue
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=IntValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//IntValue
		public RuleCall getValueIntValueParserRuleCall_1_0() { return cValueIntValueParserRuleCall_1_0; }
	}

	public class UnitLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cValueUnitKeyword_1_0 = (Keyword)cValueAssignment_1.eContents().get(0);
		
		//UnitLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value="unit";
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value="unit"
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value="unit"
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//"unit"
		public Keyword getValueUnitKeyword_1_0() { return cValueUnitKeyword_1_0; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//StringLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=STRING;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=STRING
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}

	public class RealLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RealLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueRealValueParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//RealLiteral returns be::BExpression:
		//  {be::BLiteralExpression} value=RealValue;
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} value=RealValue
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//value=RealValue
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//RealValue
		public RuleCall getValueRealValueParserRuleCall_1_0() { return cValueRealValueParserRuleCall_1_0; }
	}

	public class RegexpLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RegexpLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBRegularExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPatternAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPatternREGULAR_EXPRTerminalRuleCall_1_0 = (RuleCall)cPatternAssignment_1.eContents().get(0);
		
		//RegexpLiteral returns be::BExpression:
		//  {be::BRegularExpression} pattern=REGULAR_EXPR;
		public ParserRule getRule() { return rule; }

		//{be::BRegularExpression} pattern=REGULAR_EXPR
		public Group getGroup() { return cGroup; }

		//{be::BRegularExpression}
		public Action getBRegularExpressionAction_0() { return cBRegularExpressionAction_0; }

		//pattern=REGULAR_EXPR
		public Assignment getPatternAssignment_1() { return cPatternAssignment_1; }

		//REGULAR_EXPR
		public RuleCall getPatternREGULAR_EXPRTerminalRuleCall_1_0() { return cPatternREGULAR_EXPRTerminalRuleCall_1_0; }
	}

	public class NullLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NullLiteral returns be::BExpression:
		//  {be::BLiteralExpression} "null"; 
		//	          // TODO: check that type is Object
		//
		////ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
		////SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
		//
		//// Has conversion rule
		public ParserRule getRule() { return rule; }

		//{be::BLiteralExpression} "null"
		public Group getGroup() { return cGroup; }

		//{be::BLiteralExpression}
		public Action getBLiteralExpressionAction_0() { return cBLiteralExpressionAction_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}

	public class BooleanValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BooleanValue returns ecore::EBooleanObject:
		//  "true"|"false";   // TODO: check that type is Object
		//
		////ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
		////SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
		//
		//// Has conversion rule
		//              
		//
		//// Has conversion rule
		public ParserRule getRule() { return rule; }

		//"true"|"false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class RealValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RealValue");
		private final RuleCall cREALParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//RealValue returns ecore::EDoubleObject:
		//  REAL; 
		//
		//// Has conversion rule
		//        
		//
		//// Has conversion rule that handles dec, oct, and hex values with radix
		public ParserRule getRule() { return rule; }

		//REAL
		public RuleCall getREALParserRuleCall() { return cREALParserRuleCall; }
	}

	public class IntValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//IntValue returns ecore::EIntegerObject:
		//  INT|HEX; 
		//
		//// Has conversion rule that handles dec, oct, and hex values with radix
		public ParserRule getRule() { return rule; }

		//INT|HEX 
		//
		//// Has conversion rule that handles dec, oct, and hex values with radix
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1() { return cHEXTerminalRuleCall_1; }
	}

	public class ParanthesizedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParanthesizedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParanthesizedExpression returns be::BExpression:
		//  "(" Expression ")";
		public ParserRule getRule() { return rule; }

		//"(" Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class VersionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Version");
		private final Assignment cVersionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVersionVersionLiteralParserRuleCall_0 = (RuleCall)cVersionAssignment.eContents().get(0);
		
		//Version:
		//  version=VersionLiteral;
		public ParserRule getRule() { return rule; }

		//version=VersionLiteral
		public Assignment getVersionAssignment() { return cVersionAssignment; }

		//VersionLiteral
		public RuleCall getVersionVersionLiteralParserRuleCall_0() { return cVersionVersionLiteralParserRuleCall_0; }
	}

	public class VersionLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VersionLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//VersionLiteral returns types::Version:
		//  STRING|AlfanumSym;
		public ParserRule getRule() { return rule; }

		//STRING|AlfanumSym
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_1() { return cAlfanumSymParserRuleCall_1; }
	}

	public class VersionRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VersionRange");
		private final Assignment cRangeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cRangeVersionRangeLiteralParserRuleCall_0 = (RuleCall)cRangeAssignment.eContents().get(0);
		
		//VersionRange:
		//  range=VersionRangeLiteral;
		public ParserRule getRule() { return rule; }

		//range=VersionRangeLiteral
		public Assignment getRangeAssignment() { return cRangeAssignment; }

		//VersionRangeLiteral
		public RuleCall getRangeVersionRangeLiteralParserRuleCall_0() { return cRangeVersionRangeLiteralParserRuleCall_0; }
	}

	public class VersionRangeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VersionRangeLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0_1_0 = (RuleCall)cAlternatives_0_1.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_0_1_1 = (RuleCall)cAlternatives_0_1.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Alternatives cAlternatives_0_2_1 = (Alternatives)cGroup_0_2.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0_2_1_0 = (RuleCall)cAlternatives_0_2_1.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_0_2_1_1 = (RuleCall)cAlternatives_0_2_1.eContents().get(1);
		private final Alternatives cAlternatives_0_3 = (Alternatives)cGroup_0.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_0_3_0 = (Keyword)cAlternatives_0_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_3_1 = (Keyword)cAlternatives_0_3.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cAlternatives.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cAlfanumSymParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//VersionRangeLiteral returns types::VersionRange:
		//  ("["|"(") (STRING|AlfanumSym) ("," (STRING|AlfanumSym))? ("]"|")")|(STRING|
		//  AlfanumSym); 
		//
		//    
		//	                      
		//	      
		//	
		//
		//// Reference to qualified named item, possibly in unit, this or super, or
		//// this.super, or unit.super
		public ParserRule getRule() { return rule; }

		//("["|"(") (STRING|AlfanumSym) ("," (STRING|AlfanumSym))? ("]"|")")|(STRING|
		//AlfanumSym) 
		//
		//    
		//	                      
		//	      
		//	
		//
		//// Reference to qualified named item, possibly in unit, this or super, or
		//// this.super, or unit.super
		public Alternatives getAlternatives() { return cAlternatives; }

		//("["|"(") (STRING|AlfanumSym) ("," (STRING|AlfanumSym))? ("]"|")")
		public Group getGroup_0() { return cGroup_0; }

		//"["|"("
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_0_0() { return cLeftSquareBracketKeyword_0_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0_1() { return cLeftParenthesisKeyword_0_0_1; }

		//STRING|AlfanumSym
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0_1_0() { return cSTRINGTerminalRuleCall_0_1_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_0_1_1() { return cAlfanumSymParserRuleCall_0_1_1; }

		//("," (STRING|AlfanumSym))?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//","
		public Keyword getCommaKeyword_0_2_0() { return cCommaKeyword_0_2_0; }

		//STRING|AlfanumSym
		public Alternatives getAlternatives_0_2_1() { return cAlternatives_0_2_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0_2_1_0() { return cSTRINGTerminalRuleCall_0_2_1_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_0_2_1_1() { return cAlfanumSymParserRuleCall_0_2_1_1; }

		//"]"|")"
		public Alternatives getAlternatives_0_3() { return cAlternatives_0_3; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_3_0() { return cRightSquareBracketKeyword_0_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_3_1() { return cRightParenthesisKeyword_0_3_1; }

		//STRING|AlfanumSym
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1_0() { return cSTRINGTerminalRuleCall_1_0; }

		//AlfanumSym
		public RuleCall getAlfanumSymParserRuleCall_1_1() { return cAlfanumSymParserRuleCall_1_1; }
	}

	public class QIDREFElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QIDREF");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cSuperKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Group cGroup_0_0_1 = (Group)cAlternatives_0_0.eContents().get(1);
		private final Alternatives cAlternatives_0_0_1_0 = (Alternatives)cGroup_0_0_1.eContents().get(0);
		private final Keyword cUnitKeyword_0_0_1_0_0 = (Keyword)cAlternatives_0_0_1_0.eContents().get(0);
		private final Keyword cThisKeyword_0_0_1_0_1 = (Keyword)cAlternatives_0_0_1_0.eContents().get(1);
		private final Group cGroup_0_0_1_1 = (Group)cGroup_0_0_1.eContents().get(1);
		private final Keyword cFullStopKeyword_0_0_1_1_0 = (Keyword)cGroup_0_0_1_1.eContents().get(0);
		private final Keyword cSuperKeyword_0_0_1_1_1 = (Keyword)cGroup_0_0_1_1.eContents().get(1);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cFullStopKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final RuleCall cQIDParserRuleCall_0_1_1 = (RuleCall)cGroup_0_1.eContents().get(1);
		private final RuleCall cQIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//QIDREF returns ecore::EString:
		//  ("super"|("unit"|"this") ("." "super")?) ("." QID)?|QID; 
		//
		//// Reference to qualified named item, possibly in unit, this or super, or
		//// this.super, or unit.super
		//                        
		//
		//// Qualified name
		public ParserRule getRule() { return rule; }

		//("super"|("unit"|"this") ("." "super")?) ("." QID)?|QID 
		//
		//// Reference to qualified named item, possibly in unit, this or super, or
		//// this.super, or unit.super
		//                        
		//
		//// Qualified name
		public Alternatives getAlternatives() { return cAlternatives; }

		//("super"|("unit"|"this") ("." "super")?) ("." QID)?
		public Group getGroup_0() { return cGroup_0; }

		//"super"|("unit"|"this") ("." "super")?
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"super"
		public Keyword getSuperKeyword_0_0_0() { return cSuperKeyword_0_0_0; }

		//("unit"|"this") ("." "super")?
		public Group getGroup_0_0_1() { return cGroup_0_0_1; }

		//"unit"|"this"
		public Alternatives getAlternatives_0_0_1_0() { return cAlternatives_0_0_1_0; }

		//"unit"
		public Keyword getUnitKeyword_0_0_1_0_0() { return cUnitKeyword_0_0_1_0_0; }

		//"this"
		public Keyword getThisKeyword_0_0_1_0_1() { return cThisKeyword_0_0_1_0_1; }

		//("." "super")?
		public Group getGroup_0_0_1_1() { return cGroup_0_0_1_1; }

		//"."
		public Keyword getFullStopKeyword_0_0_1_1_0() { return cFullStopKeyword_0_0_1_1_0; }

		//"super"
		public Keyword getSuperKeyword_0_0_1_1_1() { return cSuperKeyword_0_0_1_1_1; }

		//("." QID)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"."
		public Keyword getFullStopKeyword_0_1_0() { return cFullStopKeyword_0_1_0; }

		//QID
		public RuleCall getQIDParserRuleCall_0_1_1() { return cQIDParserRuleCall_0_1_1; }

		//QID
		public RuleCall getQIDParserRuleCall_1() { return cQIDParserRuleCall_1; }
	}

	public class QIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Alternatives cAlternatives_2_2 = (Alternatives)cGroup_2.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_2_2_0 = (RuleCall)cAlternatives_2_2.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_2_2_1 = (RuleCall)cAlternatives_2_2.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_2_2_2 = (RuleCall)cAlternatives_2_2.eContents().get(2);
		
		//QID returns ecore::EString hidden ( ):
		//  ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)*; 
		//
		//// Qualified name
		public ParserRule getRule() { return rule; }

		//ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//(INT|HEX|ID)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_0() { return cINTTerminalRuleCall_1_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1_1() { return cHEXTerminalRuleCall_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_2() { return cIDTerminalRuleCall_1_2; }

		//("." ID (INT|HEX|ID)*)*
		public Group getGroup_2() { return cGroup_2; }

		//"."
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_2_1() { return cIDTerminalRuleCall_2_1; }

		//(INT|HEX|ID)*
		public Alternatives getAlternatives_2_2() { return cAlternatives_2_2; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_2_0() { return cINTTerminalRuleCall_2_2_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_2_2_1() { return cHEXTerminalRuleCall_2_2_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_2_2_2() { return cIDTerminalRuleCall_2_2_2; }
	}

	public class PropertyNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyName");
		private final RuleCall cPIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PropertyName returns ecore::EString:
		//  PID;
		public ParserRule getRule() { return rule; }

		//PID
		public RuleCall getPIDTerminalRuleCall() { return cPIDTerminalRuleCall; }
	}

	public class EscapedQualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EscapedQualifiedName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EscapedQualifiedName returns ecore::EString:
		//  STRING|QID;
		public ParserRule getRule() { return rule; }

		//STRING|QID
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//QID
		public RuleCall getQIDParserRuleCall_1() { return cQIDParserRuleCall_1; }
	}

	public class InterfaceNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InterfaceName");
		private final RuleCall cQIDParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//InterfaceName returns ecore::EString:
		//  QID; 
		//    
		//
		//// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
		//// do not allow being broken across lines.
		////
		public ParserRule getRule() { return rule; }

		//QID
		public RuleCall getQIDParserRuleCall() { return cQIDParserRuleCall; }
	}

	public class CompoundNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEscapedQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cEscapedQualifiedNameParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//CompoundName returns ecore::EString:
		//  EscapedQualifiedName "/" EscapedQualifiedName; 
		//
		//// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
		//// do not allow being broken across lines.
		////
		//          
		//
		//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName "/" EscapedQualifiedName
		public Group getGroup() { return cGroup; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall_0() { return cEscapedQualifiedNameParserRuleCall_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall_2() { return cEscapedQualifiedNameParserRuleCall_2; }
	}

	public class UnitNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnitName");
		private final RuleCall cEscapedQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//UnitName returns ecore::EString:
		//  EscapedQualifiedName; 
		//
		//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall() { return cEscapedQualifiedNameParserRuleCall; }
	}

	public class PartNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PartName");
		private final RuleCall cEscapedQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//PartName returns ecore::EString:
		//  EscapedQualifiedName;
		public ParserRule getRule() { return rule; }

		//EscapedQualifiedName
		public RuleCall getEscapedQualifiedNameParserRuleCall() { return cEscapedQualifiedNameParserRuleCall; }
	}

	public class SeparatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Separator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cCommercialAtKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDollarSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPercentSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cAmpersandKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cPlusSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cEqualsSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cAsteriskKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cLessThanSignKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cGreaterThanSignKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cColonKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cQuestionMarkKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		
		//Separator returns ecore::EString:
		//  "."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?"; 
		//
		//
		//// Version, and VersionRange
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public ParserRule getRule() { return rule; }

		//"."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?" 
		//
		//
		//// Version, and VersionRange
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }

		//"!"
		public Keyword getExclamationMarkKeyword_2() { return cExclamationMarkKeyword_2; }

		//"@"
		public Keyword getCommercialAtKeyword_3() { return cCommercialAtKeyword_3; }

		//"$"
		public Keyword getDollarSignKeyword_4() { return cDollarSignKeyword_4; }

		//"%"
		public Keyword getPercentSignKeyword_5() { return cPercentSignKeyword_5; }

		//"&"
		public Keyword getAmpersandKeyword_6() { return cAmpersandKeyword_6; }

		//"+"
		public Keyword getPlusSignKeyword_7() { return cPlusSignKeyword_7; }

		//"="
		public Keyword getEqualsSignKeyword_8() { return cEqualsSignKeyword_8; }

		//"*"
		public Keyword getAsteriskKeyword_9() { return cAsteriskKeyword_9; }

		//"<"
		public Keyword getLessThanSignKeyword_10() { return cLessThanSignKeyword_10; }

		//">"
		public Keyword getGreaterThanSignKeyword_11() { return cGreaterThanSignKeyword_11; }

		//":"
		public Keyword getColonKeyword_12() { return cColonKeyword_12; }

		//"?"
		public Keyword getQuestionMarkKeyword_13() { return cQuestionMarkKeyword_13; }
	}

	public class AlfanumSymElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AlfanumSym");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cHEXTerminalRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cEXT_INTTerminalRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cSeparatorParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cHEXTerminalRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		private final RuleCall cEXT_INTTerminalRuleCall_1_4 = (RuleCall)cAlternatives_1.eContents().get(4);
		
		//AlfanumSym returns ecore::EString:
		//  (ID|INT|HEX|EXT_INT) (Separator|ID|INT|HEX|EXT_INT)*; 
		//                      
		//
		//// --TERMINALS
		//// (Does not use standard terminals to have full control).
		//
		//// TODO: Possibly use some other char instead of ^ as escape mechanism ??
		public ParserRule getRule() { return rule; }

		//(ID|INT|HEX|EXT_INT) (Separator|ID|INT|HEX|EXT_INT)*
		public Group getGroup() { return cGroup; }

		//ID|INT|HEX|EXT_INT
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_0() { return cIDTerminalRuleCall_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_0_2() { return cHEXTerminalRuleCall_0_2; }

		//EXT_INT
		public RuleCall getEXT_INTTerminalRuleCall_0_3() { return cEXT_INTTerminalRuleCall_0_3; }

		//(Separator|ID|INT|HEX|EXT_INT)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//Separator
		public RuleCall getSeparatorParserRuleCall_1_0() { return cSeparatorParserRuleCall_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_2() { return cINTTerminalRuleCall_1_2; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1_3() { return cHEXTerminalRuleCall_1_3; }

		//EXT_INT
		public RuleCall getEXT_INTTerminalRuleCall_1_4() { return cEXT_INTTerminalRuleCall_1_4; }
	}

	public class REALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "REAL");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cEXT_INTTerminalRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		
		//REAL returns ecore::EString hidden ( ):
		//  INT? "." (EXT_INT|INT);
		public ParserRule getRule() { return rule; }

		//INT? "." (EXT_INT|INT)
		public Group getGroup() { return cGroup; }

		//INT?
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//EXT_INT|INT
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//EXT_INT
		public RuleCall getEXT_INTTerminalRuleCall_2_0() { return cEXT_INTTerminalRuleCall_2_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}
	
	
	public class VisibilityElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Visibility");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPublicEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPublicPublicKeyword_0_0 = (Keyword)cPublicEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPrivateEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPrivatePrivateKeyword_1_0 = (Keyword)cPrivateEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Visibility returns be::Visibility:
		//  public | private;
		public EnumRule getRule() { return rule; }

		//public | private
		public Alternatives getAlternatives() { return cAlternatives; }

		//public
		public EnumLiteralDeclaration getPublicEnumLiteralDeclaration_0() { return cPublicEnumLiteralDeclaration_0; }

		//"public"
		public Keyword getPublicPublicKeyword_0_0() { return cPublicPublicKeyword_0_0; }

		//private
		public EnumLiteralDeclaration getPrivateEnumLiteralDeclaration_1() { return cPrivateEnumLiteralDeclaration_1; }

		//"private"
		public Keyword getPrivatePrivateKeyword_1_0() { return cPrivatePrivateKeyword_1_0; }
	}

	public class ExecutionModeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ExecutionMode");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cParallelEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cParallelParallelKeyword_0_0 = (Keyword)cParallelEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSequentialEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSequentialSequentialKeyword_1_0 = (Keyword)cSequentialEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ExecutionMode returns be::ExecutionMode:
		//  parallel | sequential; 
		//   	           
		//
		//
		//// Version, and VersionRange
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public EnumRule getRule() { return rule; }

		//parallel | sequential 
		//   	           
		//
		//
		//// Version, and VersionRange
		//// TODO: uncertain if the set of allowed chars is definitive.
		////
		public Alternatives getAlternatives() { return cAlternatives; }

		//parallel
		public EnumLiteralDeclaration getParallelEnumLiteralDeclaration_0() { return cParallelEnumLiteralDeclaration_0; }

		//"parallel"
		public Keyword getParallelParallelKeyword_0_0() { return cParallelParallelKeyword_0_0; }

		//sequential
		public EnumLiteralDeclaration getSequentialEnumLiteralDeclaration_1() { return cSequentialEnumLiteralDeclaration_1; }

		//"sequential"
		public Keyword getSequentialSequentialKeyword_1_0() { return cSequentialSequentialKeyword_1_0; }
	}
	
	private BeeModelElements pBeeModel;
	private ImportElements pImport;
	private UnitElements pUnit;
	private ProvidedCapabilityElements pProvidedCapability;
	private RequiredCapabilityElements pRequiredCapability;
	private FilteredCapabilityElements pFilteredCapability;
	private CapabilityElements pCapability;
	private NamedPropertySetElements pNamedPropertySet;
	private PropertySetElements pPropertySet;
	private PropertyOperationElements pPropertyOperation;
	private FilteredPropertyOperationElements pFilteredPropertyOperation;
	private PropertyValDeclarationElements pPropertyValDeclaration;
	private PropertyVarDeclarationElements pPropertyVarDeclaration;
	private SetPropertyOperationElements pSetPropertyOperation;
	private UnsetPropertyOperationElements pUnsetPropertyOperation;
	private SynchronizationElements pSynchronization;
	private SynchronizedPartElements pSynchronizedPart;
	private PathGroupElements pPathGroup;
	private PathVectorElementElements pPathVectorElement;
	private FilteredPathVectorElements pFilteredPathVector;
	private BasePathVectorElements pBasePathVector;
	private UnbasedPathVectorElements pUnbasedPathVector;
	private CompoundPathVectorElements pCompoundPathVector;
	private PathElements pPath;
	private PrerequisiteElements pPrerequisite;
	private WithClauseElements pWithClause;
	private PrerequisiteEntryElements pPrerequisiteEntry;
	private DirectPartReferemceElements pDirectPartReferemce;
	private CapabilityReferencedPartElements pCapabilityReferencedPart;
	private CompoundReferencesElements pCompoundReferences;
	private BuilderElements pBuilder;
	private ParameterListElements pParameterList;
	private FirstParameterElements pFirstParameter;
	private ParameterElements pParameter;
	private ClosureParameterElements pClosureParameter;
	private ParameterDeclarationListElements pParameterDeclarationList;
	private ParameterDeclarationElements pParameterDeclaration;
	private ParameterDeclarationEllipseElements pParameterDeclarationEllipse;
	private InputKeywordElements pInputKeyword;
	private OutputKeywordElements pOutputKeyword;
	private BuilderOutputElements pBuilderOutput;
	private BuilderInputElements pBuilderInput;
	private RepositoryConfigurationElements pRepositoryConfiguration;
	private RepositoryDeclarationElements pRepositoryDeclaration;
	private ResolutionStrategyElements pResolutionStrategy;
	private ContainerConfigurationElements pContainerConfiguration;
	private URIElements pURI;
	private ConcernElements pConcern;
	private ConcernBlockElements pConcernBlock;
	private FilterElements pFilter;
	private PreConditionElements pPreCondition;
	private PostConditionElements pPostCondition;
	private AssertionExpressionElements pAssertionExpression;
	private ExpressionListElements pExpressionList;
	private FunctionElements pFunction;
	private AssignmentOperatorElements pAssignmentOperator;
	private RelationalOperatorElements pRelationalOperator;
	private TopLevelExpressionElements pTopLevelExpression;
	private ExpressionElements pExpression;
	private AssignmentExpressionElements pAssignmentExpression;
	private VarDeclarationElements pVarDeclaration;
	private ValDeclarationElements pValDeclaration;
	private TypeRefElements pTypeRef;
	private SimpleTypeRefElements pSimpleTypeRef;
	private ClosureTypeRefElements pClosureTypeRef;
	private TypeParamElements pTypeParam;
	private TypeRefParamElements pTypeRefParam;
	private WildcardRefParamElements pWildcardRefParam;
	private CachedExpressionElements pCachedExpression;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private RelationalExpressionElements pRelationalExpression;
	private InstanceOfExpressionElements pInstanceOfExpression;
	private AdditiveExpressionElements pAdditiveExpression;
	private MultiplicativeExpressionElements pMultiplicativeExpression;
	private SetExpressionElements pSetExpression;
	private UnaryOrInfixExpressionElements pUnaryOrInfixExpression;
	private UnaryExpressionElements pUnaryExpression;
	private PreopExpressionElements pPreopExpression;
	private PostopExpressionElements pPostopExpression;
	private InfixExpressionElements pInfixExpression;
	private CallExpressionElements pCallExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private WildcardExpressionElements pWildcardExpression;
	private ThrowExpressionElements pThrowExpression;
	private TryCatchExpressionElements pTryCatchExpression;
	private CatchBlockElements pCatchBlock;
	private SwitchExpressionElements pSwitchExpression;
	private CaseElements pCase;
	private BlockExpressionElements pBlockExpression;
	private IfExpressionElements pIfExpression;
	private ElseIfExpressionElements pElseIfExpression;
	private PropertyValueElements pPropertyValue;
	private VariableValueElements pVariableValue;
	private KeywordVariablesElements pKeywordVariables;
	private FeatureCallElements pFeatureCall;
	private OperationCallElements pOperationCall;
	private ConstructorCallExpressionElements pConstructorCallExpression;
	private ContextElements pContext;
	private ContextSelectorElements pContextSelector;
	private TypeRefSelectorElements pTypeRefSelector;
	private ExpressionSelectorElements pExpressionSelector;
	private UnitSelectorElements pUnitSelector;
	private ContextBlockElements pContextBlock;
	private FunctionDefinitionElements pFunctionDefinition;
	private LiteralElements pLiteral;
	private LiteralListElements pLiteralList;
	private LiteralMapElements pLiteralMap;
	private LiteralFunctionElements pLiteralFunction;
	private ClosureExpressionElements pClosureExpression;
	private OneOrManyExpressionsElements pOneOrManyExpressions;
	private BlockExpressionWithoutBracketsElements pBlockExpressionWithoutBrackets;
	private MapEntryElements pMapEntry;
	private KeyLiteralElements pKeyLiteral;
	private LiteralTypeElements pLiteralType;
	private ValueLiteralElements pValueLiteral;
	private BooleanLiteralElements pBooleanLiteral;
	private IntegerLiteralElements pIntegerLiteral;
	private UnitLiteralElements pUnitLiteral;
	private StringLiteralElements pStringLiteral;
	private RealLiteralElements pRealLiteral;
	private RegexpLiteralElements pRegexpLiteral;
	private NullLiteralElements pNullLiteral;
	private BooleanValueElements pBooleanValue;
	private RealValueElements pRealValue;
	private IntValueElements pIntValue;
	private ParanthesizedExpressionElements pParanthesizedExpression;
	private VersionElements pVersion;
	private VersionLiteralElements pVersionLiteral;
	private VersionRangeElements pVersionRange;
	private VersionRangeLiteralElements pVersionRangeLiteral;
	private QIDREFElements pQIDREF;
	private QIDElements pQID;
	private PropertyNameElements pPropertyName;
	private EscapedQualifiedNameElements pEscapedQualifiedName;
	private InterfaceNameElements pInterfaceName;
	private CompoundNameElements pCompoundName;
	private UnitNameElements pUnitName;
	private PartNameElements pPartName;
	private VisibilityElements unknownRuleVisibility;
	private ExecutionModeElements unknownRuleExecutionMode;
	private SeparatorElements pSeparator;
	private AlfanumSymElements pAlfanumSym;
	private TerminalRule tID;
	private TerminalRule tPID;
	private TerminalRule tREGULAR_EXPR;
	private TerminalRule tSTRING;
	private TerminalRule tDOCUMENTATION;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tHEX;
	private TerminalRule tINT;
	private REALElements pREAL;
	private TerminalRule tEXT_INT;
	private TerminalRule tANY_OTHER;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public BeeLangGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	//BeeModel hidden ( WS , SL_COMMENT , ML_COMMENT ):
	//  imports+=Import* (functions+=Function|concern+=Concern)* body=Unit?;
	public BeeModelElements getBeeModelAccess() {
		return (pBeeModel != null) ? pBeeModel : (pBeeModel = new BeeModelElements());
	}
	
	public ParserRule getBeeModelRule() {
		return getBeeModelAccess().getRule();
	}

	//Import returns be::IType:
	//  {be::B3JavaImport} reexport?="reexport"? "import" qualifiedName=QID ("as" name=ID)?
	//  ";"; 
	//
	//                        
	//
	//// Wanted later 
	////Import : (reexport ?='reexport')? 
	////		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
	////	; 
	//
	////JavaImporter 	: qualifiedName=QID ;
	////NativeImporter 	: uriString = STRING ;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//Unit returns BuildUnit hidden ( WS , ML_COMMENT , SL_COMMENT ):
	//  {BuildUnit} documentation=DOCUMENTATION? executionMode=ExecutionMode? "unit" name=
	//  UnitName? ("version" version=Version)? ("implements" implements+=InterfaceName (","
	//  implements+=InterfaceName)*)? "{" ("default" "properties" defaultProperties=
	//  PropertySet)? ("provides" "{" (providedCapabilities+=ProvidedCapability ";")+ "}"|
	//  "provides" providedCapabilities+=ProvidedCapability ";"|"requires" "{" (
	//  requiredCapabilities+=RequiredCapability ";")+ "}"|"requires" requiredCapabilities
	//  +=RequiredCapability ";"|"env" "requires" "{" (metaRequiredCapabilities+=
	//  RequiredCapability ";")+ "}"|"env" "requires" metaRequiredCapabilities+=
	//  RequiredCapability ";"|concerns+=Concern|"sequential" "{" synchronizations+=
	//  Synchronization+ "}"|"sequential" synchronizations+=Synchronization|builders+=
	//  Builder|functions+=Function|"repositories" "{" repositoryConfigurations+=
	//  RepositoryConfiguration* "}"|"properties" propertySets+=NamedPropertySet|
	//  "containers" "{" containers+=ContainerConfiguration* "}")* "}"; 
	//
	//// Wanted later 
	////Import : (reexport ?='reexport')? 
	////		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
	////	; 
	//
	////JavaImporter 	: qualifiedName=QID ;
	////NativeImporter 	: uriString = STRING ;
	//		
	//              
	//	    
	//	    
	//	          
	//		           
	//	
	//			 //-- PROPERTIES
	//			 // goes first, because they may be used in the other clauses. TODO: can probably be relaxed
	//			 // since linking will find them anyway.
	//			 //
	//			            
	//		
	//		 	 //-- PROVIDES
	//			               
	//			          
	//			//-- REQUIRES & META REQUIRES
	//			               
	//			          
	//			                  
	//			            
	//			//--CONCERNS
	//			     
	//			//--SYNCHRONIZE
	//			                  
	//			           
	//			//--BUILD METHODS & FUNCTIONS
	//			         			
	//			        			
	//			//-- REPOSITORIES
	public UnitElements getUnitAccess() {
		return (pUnit != null) ? pUnit : (pUnit = new UnitElements());
	}
	
	public ParserRule getUnitRule() {
		return getUnitAccess().getRule();
	}

	//ProvidedCapability:
	//  capability=FilteredCapability ("/" version=Version)?;
	public ProvidedCapabilityElements getProvidedCapabilityAccess() {
		return (pProvidedCapability != null) ? pProvidedCapability : (pProvidedCapability = new ProvidedCapabilityElements());
	}
	
	public ParserRule getProvidedCapabilityRule() {
		return getProvidedCapabilityAccess().getRule();
	}

	//RequiredCapability:
	//  capability=FilteredCapability ("/" range=VersionRange)?;
	public RequiredCapabilityElements getRequiredCapabilityAccess() {
		return (pRequiredCapability != null) ? pRequiredCapability : (pRequiredCapability = new RequiredCapabilityElements());
	}
	
	public ParserRule getRequiredCapabilityRule() {
		return getRequiredCapabilityAccess().getRule();
	}

	//FilteredCapability:
	//  ("when" filter=Filter)? capability=Capability;
	public FilteredCapabilityElements getFilteredCapabilityAccess() {
		return (pFilteredCapability != null) ? pFilteredCapability : (pFilteredCapability = new FilteredCapabilityElements());
	}
	
	public ParserRule getFilteredCapabilityRule() {
		return getFilteredCapabilityAccess().getRule();
	}

	//Capability:
	//  interface=InterfaceName "/" name=UnitName; 
	//          
	//
	//// An optionally named sequence of property statements
	public CapabilityElements getCapabilityAccess() {
		return (pCapability != null) ? pCapability : (pCapability = new CapabilityElements());
	}
	
	public ParserRule getCapabilityRule() {
		return getCapabilityAccess().getRule();
	}

	//NamedPropertySet:
	//  name=ID body=PropertySet; 
	//
	//// An optionally named sequence of property statements
	//    
	//	             
	//	
	//
	//// Sequence of possibly filtered property statements
	public NamedPropertySetElements getNamedPropertySetAccess() {
		return (pNamedPropertySet != null) ? pNamedPropertySet : (pNamedPropertySet = new NamedPropertySetElements());
	}
	
	public ParserRule getNamedPropertySetRule() {
		return getNamedPropertySetAccess().getRule();
	}

	//PropertySet:
	//  {PropertySet} ("extends" extends=QIDREF)? "{" operations+=PropertyOperation* "}"; 
	//
	//// Sequence of possibly filtered property statements	
	//    
	//	                 
	////	:  ("extends" extends=[NamedPropertySet | QIDREF])? '{' (operations += PropertyOperation)* '}'
	//	 
	//
	//// For model generation, to get supertype correct
	public PropertySetElements getPropertySetAccess() {
		return (pPropertySet != null) ? pPropertySet : (pPropertySet = new PropertySetElements());
	}
	
	public ParserRule getPropertySetRule() {
		return getPropertySetAccess().getRule();
	}

	//PropertyOperation:
	//  FilteredPropertyOperation|SetPropertyOperation|UnsetPropertyOperation|
	//  PropertySet; 
	//
	//// For model generation, to get supertype correct
	public PropertyOperationElements getPropertyOperationAccess() {
		return (pPropertyOperation != null) ? pPropertyOperation : (pPropertyOperation = new PropertyOperationElements());
	}
	
	public ParserRule getPropertyOperationRule() {
		return getPropertyOperationAccess().getRule();
	}

	//FilteredPropertyOperation:
	//  "when" filter=Filter body=( SetPropertyOperation | UnsetPropertyOperation | PropertySet
	//  ); 
	//
	//    
	//	    
	//		         
	//	
	//// be::BDefProperty   immutable ?= "val"
	//// property values, must be assigned (but can be assigned null).
	public FilteredPropertyOperationElements getFilteredPropertyOperationAccess() {
		return (pFilteredPropertyOperation != null) ? pFilteredPropertyOperation : (pFilteredPropertyOperation = new FilteredPropertyOperationElements());
	}
	
	public ParserRule getFilteredPropertyOperationRule() {
		return getFilteredPropertyOperationAccess().getRule();
	}

	//PropertyValDeclaration returns be::BExpression:
	//  {be::BDefProperty} final?="final"? (("property"|type=TypeRef) name=PID) "=" valueExpr
	//  =Expression; 
	//// be::BDefProperty   immutable ?= "val"
	//// property values, must be assigned (but can be assigned null).
	public PropertyValDeclarationElements getPropertyValDeclarationAccess() {
		return (pPropertyValDeclaration != null) ? pPropertyValDeclaration : (pPropertyValDeclaration = new PropertyValDeclarationElements());
	}
	
	public ParserRule getPropertyValDeclarationRule() {
		return getPropertyValDeclarationAccess().getRule();
	}

	//PropertyVarDeclaration returns be::BExpression:
	//  {be::BDefProperty} final?="final"? mutable?="mutable" (("property"|type=TypeRef)
	//  name=PID) ("=" valueExpr=Expression)?;
	public PropertyVarDeclarationElements getPropertyVarDeclarationAccess() {
		return (pPropertyVarDeclaration != null) ? pPropertyVarDeclaration : (pPropertyVarDeclaration = new PropertyVarDeclarationElements());
	}
	
	public ParserRule getPropertyVarDeclarationRule() {
		return getPropertyVarDeclarationAccess().getRule();
	}

	//SetPropertyOperation:
	//  final?="final"? key=PropertyName op=AssignmentOperator value=Expression ";";
	public SetPropertyOperationElements getSetPropertyOperationAccess() {
		return (pSetPropertyOperation != null) ? pSetPropertyOperation : (pSetPropertyOperation = new SetPropertyOperationElements());
	}
	
	public ParserRule getSetPropertyOperationRule() {
		return getSetPropertyOperationAccess().getRule();
	}

	//UnsetPropertyOperation:
	//  "unset" key=PropertyName ";";
	public UnsetPropertyOperationElements getUnsetPropertyOperationAccess() {
		return (pUnsetPropertyOperation != null) ? pUnsetPropertyOperation : (pUnsetPropertyOperation = new UnsetPropertyOperationElements());
	}
	
	public ParserRule getUnsetPropertyOperationRule() {
		return getUnsetPropertyOperationAccess().getRule();
	}

	//Synchronization:
	//  partrefs+=SynchronizedPart ("," partrefs+=SynchronizedPart)+ ";"; 
	//
	// 
	//	                // TODO: verify at least 2 partrefs
	public SynchronizationElements getSynchronizationAccess() {
		return (pSynchronization != null) ? pSynchronization : (pSynchronization = new SynchronizationElements());
	}
	
	public ParserRule getSynchronizationRule() {
		return getSynchronizationAccess().getRule();
	}

	//SynchronizedPart returns ecore::EString:
	//  CompoundName ("#" PartName)?|PartName;
	public SynchronizedPartElements getSynchronizedPartAccess() {
		return (pSynchronizedPart != null) ? pSynchronizedPart : (pSynchronizedPart = new SynchronizedPartElements());
	}
	
	public ParserRule getSynchronizedPartRule() {
		return getSynchronizedPartAccess().getRule();
	}

	//PathGroup:
	//  paths+=PathVectorElement+ ("annotations" annotations=PropertySet)?;
	public PathGroupElements getPathGroupAccess() {
		return (pPathGroup != null) ? pPathGroup : (pPathGroup = new PathGroupElements());
	}
	
	public ParserRule getPathGroupRule() {
		return getPathGroupAccess().getRule();
	}

	//PathVectorElement:
	//  FilteredPathVector|BasePathVector|UnbasedPathVector;
	public PathVectorElementElements getPathVectorElementAccess() {
		return (pPathVectorElement != null) ? pPathVectorElement : (pPathVectorElement = new PathVectorElementElements());
	}
	
	public ParserRule getPathVectorElementRule() {
		return getPathVectorElementAccess().getRule();
	}

	//FilteredPathVector:
	//  "when" filter=Filter body=( BasePathVector | UnbasedPathVector | CompoundPathVector );
	public FilteredPathVectorElements getFilteredPathVectorAccess() {
		return (pFilteredPathVector != null) ? pFilteredPathVector : (pFilteredPathVector = new FilteredPathVectorElements());
	}
	
	public ParserRule getFilteredPathVectorRule() {
		return getFilteredPathVectorAccess().getRule();
	}

	//BasePathVector returns PathVector:
	//  basePath=Path "[" (paths+=Path ("," paths+=Path)*)? "]" ";";
	public BasePathVectorElements getBasePathVectorAccess() {
		return (pBasePathVector != null) ? pBasePathVector : (pBasePathVector = new BasePathVectorElements());
	}
	
	public ParserRule getBasePathVectorRule() {
		return getBasePathVectorAccess().getRule();
	}

	//UnbasedPathVector returns PathVector:
	//  paths+=Path ("," paths+=Path)* ";";
	public UnbasedPathVectorElements getUnbasedPathVectorAccess() {
		return (pUnbasedPathVector != null) ? pUnbasedPathVector : (pUnbasedPathVector = new UnbasedPathVectorElements());
	}
	
	public ParserRule getUnbasedPathVectorRule() {
		return getUnbasedPathVectorAccess().getRule();
	}

	//CompoundPathVector:
	//  {CompoundPathVector} "{" body+=PathVectorElement* "}"; 
	//	
	//              
	//
	//// A path can be written without quotes if it consists of safe chars
	public CompoundPathVectorElements getCompoundPathVectorAccess() {
		return (pCompoundPathVector != null) ? pCompoundPathVector : (pCompoundPathVector = new CompoundPathVectorElements());
	}
	
	public ParserRule getCompoundPathVectorRule() {
		return getCompoundPathVectorAccess().getRule();
	}

	//Path returns ecore::EString hidden ( ):
	//  STRING|"/"? QID ("/" QID)* "/"?; 
	//
	//// A path can be written without quotes if it consists of safe chars
	public PathElements getPathAccess() {
		return (pPath != null) ? pPath : (pPath = new PathElements());
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}

	//Prerequisite:
	//  ("when" filter=Filter)? withClause=WithClause? partReference=PrerequisiteEntry ("as"
	//  alias=ID)? ";"; 
	//
	//   
	//		    
	//		    
	//		 
	//		    
	//	
	//
	//// Validation checks that there is at least one of references, properties or concern.
	public PrerequisiteElements getPrerequisiteAccess() {
		return (pPrerequisite != null) ? pPrerequisite : (pPrerequisite = new PrerequisiteElements());
	}
	
	public ParserRule getPrerequisiteRule() {
		return getPrerequisiteAccess().getRule();
	}

	//WithClause:
	//  {WithClause} "with" ("(" references+=Expression ("," references+=Expression)* ")")? (
	//  "properties" properties+=PropertySet|"concern" concern+=ConcernBlock)*; 
	//
	//// Validation checks that there is at least one of references, properties or concern.
	public WithClauseElements getWithClauseAccess() {
		return (pWithClause != null) ? pWithClause : (pWithClause = new WithClauseElements());
	}
	
	public ParserRule getWithClauseRule() {
		return getWithClauseAccess().getRule();
	}

	//PrerequisiteEntry:
	//  DirectPartReferemce|CapabilityReferencedPart|CompoundReferences;
	public PrerequisiteEntryElements getPrerequisiteEntryAccess() {
		return (pPrerequisiteEntry != null) ? pPrerequisiteEntry : (pPrerequisiteEntry = new PrerequisiteEntryElements());
	}
	
	public ParserRule getPrerequisiteEntryRule() {
		return getPrerequisiteEntryAccess().getRule();
	}

	//DirectPartReferemce:
	//  (unit=QID|unit="unit")? "#" builder=PartName parameters=ParameterList?;
	public DirectPartReferemceElements getDirectPartReferemceAccess() {
		return (pDirectPartReferemce != null) ? pDirectPartReferemce : (pDirectPartReferemce = new DirectPartReferemceElements());
	}
	
	public ParserRule getDirectPartReferemceRule() {
		return getDirectPartReferemceAccess().getRule();
	}

	//CapabilityReferencedPart:
	//  capability=Capability ("/" range=VersionRange)? ("#" partName=PartName)? parameters=
	//  ParameterList?;
	public CapabilityReferencedPartElements getCapabilityReferencedPartAccess() {
		return (pCapabilityReferencedPart != null) ? pCapabilityReferencedPart : (pCapabilityReferencedPart = new CapabilityReferencedPartElements());
	}
	
	public ParserRule getCapabilityReferencedPartRule() {
		return getCapabilityReferencedPartAccess().getRule();
	}

	//CompoundReferences:
	//  {CompounddReferences} "{" prerequisites+=Prerequisite* "}";
	public CompoundReferencesElements getCompoundReferencesAccess() {
		return (pCompoundReferences != null) ? pCompoundReferences : (pCompoundReferences = new CompoundReferencesElements());
	}
	
	public ParserRule getCompoundReferencesRule() {
		return getCompoundReferencesAccess().getRule();
	}

	//Builder:
	//  {Builder} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
	//  ExecutionMode? final?="final"? cached?="cached"? "builder" name=PartName ("(" params=
	//  ParameterDeclarationList ")")? ("provides" providedCapabilities+=ProvidedCapability
	//  ("," providedCapabilities+=ProvidedCapability)*)? preCondition=PreCondition?
	//  postCondition=PostCondition? "{" ("default" "properties" properties=PropertySet)?
	//  input=BuilderInput? output=BuilderOutput? expressionList=ExpressionList? "}";
	public BuilderElements getBuilderAccess() {
		return (pBuilder != null) ? pBuilder : (pBuilder = new BuilderElements());
	}
	
	public ParserRule getBuilderRule() {
		return getBuilderAccess().getRule();
	}

	//ParameterList returns be::BParameterList:
	//  {be::BParameterList} parameters+=FirstParameter ("," parameters+=FirstParameter)*;
	public ParameterListElements getParameterListAccess() {
		return (pParameterList != null) ? pParameterList : (pParameterList = new ParameterListElements());
	}
	
	public ParserRule getParameterListRule() {
		return getParameterListAccess().getRule();
	}

	//FirstParameter returns be::BParameter:
	//  ClosureParameter|Parameter;
	public FirstParameterElements getFirstParameterAccess() {
		return (pFirstParameter != null) ? pFirstParameter : (pFirstParameter = new FirstParameterElements());
	}
	
	public ParserRule getFirstParameterRule() {
		return getFirstParameterAccess().getRule();
	}

	//Parameter returns be::BParameter:
	//  {be::BParameter} expr=Expression;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//ClosureParameter returns be::BParameter:
	//  {be::BParameter} expr=ClosureExpression;
	public ClosureParameterElements getClosureParameterAccess() {
		return (pClosureParameter != null) ? pClosureParameter : (pClosureParameter = new ClosureParameterElements());
	}
	
	public ParserRule getClosureParameterRule() {
		return getClosureParameterAccess().getRule();
	}

	//ParameterDeclarationList:
	//  params+=ParameterDeclaration ("," params+=ParameterDeclaration)* ("," params+=
	//  ParameterDeclarationEllipse)?|params+=ParameterDeclarationEllipse;
	public ParameterDeclarationListElements getParameterDeclarationListAccess() {
		return (pParameterDeclarationList != null) ? pParameterDeclarationList : (pParameterDeclarationList = new ParameterDeclarationListElements());
	}
	
	public ParserRule getParameterDeclarationListRule() {
		return getParameterDeclarationListAccess().getRule();
	}

	//ParameterDeclaration returns be::BParameterDeclaration:
	//  {be::BParameterDeclaration} (type=TypeRef? name=ID);
	public ParameterDeclarationElements getParameterDeclarationAccess() {
		return (pParameterDeclaration != null) ? pParameterDeclaration : (pParameterDeclaration = new ParameterDeclarationElements());
	}
	
	public ParserRule getParameterDeclarationRule() {
		return getParameterDeclarationAccess().getRule();
	}

	//ParameterDeclarationEllipse returns ParameterDeclaration:
	//  {VarargParameterDeclaration} "..." type=TypeRef? name=ID;
	public ParameterDeclarationEllipseElements getParameterDeclarationEllipseAccess() {
		return (pParameterDeclarationEllipse != null) ? pParameterDeclarationEllipse : (pParameterDeclarationEllipse = new ParameterDeclarationEllipseElements());
	}
	
	public ParserRule getParameterDeclarationEllipseRule() {
		return getParameterDeclarationEllipseAccess().getRule();
	}

	//InputKeyword returns ecore::EString:
	//  "input";
	public InputKeywordElements getInputKeywordAccess() {
		return (pInputKeyword != null) ? pInputKeyword : (pInputKeyword = new InputKeywordElements());
	}
	
	public ParserRule getInputKeywordRule() {
		return getInputKeywordAccess().getRule();
	}

	//OutputKeyword returns ecore::EString:
	//  "output";
	public OutputKeywordElements getOutputKeywordAccess() {
		return (pOutputKeyword != null) ? pOutputKeyword : (pOutputKeyword = new OutputKeywordElements());
	}
	
	public ParserRule getOutputKeywordRule() {
		return getOutputKeywordAccess().getRule();
	}

	//BuilderOutput:
	//  OutputKeyword "{" body=PathGroup "}";
	public BuilderOutputElements getBuilderOutputAccess() {
		return (pBuilderOutput != null) ? pBuilderOutput : (pBuilderOutput = new BuilderOutputElements());
	}
	
	public ParserRule getBuilderOutputRule() {
		return getBuilderOutputAccess().getRule();
	}

	//BuilderInput:
	//  InputKeyword preCondition=PreCondition? postCondition=PostCondition? "{"
	//  prerequisites+=Prerequisite+ "}";
	public BuilderInputElements getBuilderInputAccess() {
		return (pBuilderInput != null) ? pBuilderInput : (pBuilderInput = new BuilderInputElements());
	}
	
	public ParserRule getBuilderInputRule() {
		return getBuilderInputAccess().getRule();
	}

	//RepositoryConfiguration:
	//  RepositoryDeclaration|ResolutionStrategy;
	public RepositoryConfigurationElements getRepositoryConfigurationAccess() {
		return (pRepositoryConfiguration != null) ? pRepositoryConfiguration : (pRepositoryConfiguration = new RepositoryConfigurationElements());
	}
	
	public ParserRule getRepositoryConfigurationRule() {
		return getRepositoryConfigurationAccess().getRule();
	}

	//RepositoryDeclaration:
	//  documentation=DOCUMENTATION? (location=URI|"repository" type=TypeRef) context=
	//  ContextBlock?;
	public RepositoryDeclarationElements getRepositoryDeclarationAccess() {
		return (pRepositoryDeclaration != null) ? pRepositoryDeclaration : (pRepositoryDeclaration = new RepositoryDeclarationElements());
	}
	
	public ParserRule getRepositoryDeclarationRule() {
		return getRepositoryDeclarationAccess().getRule();
	}

	//ResolutionStrategy:
	//  strategy=( "select-first" | "select-best" ) "{" repositoryConfig+=
	//  RepositoryConfiguration* "}";
	public ResolutionStrategyElements getResolutionStrategyAccess() {
		return (pResolutionStrategy != null) ? pResolutionStrategy : (pResolutionStrategy = new ResolutionStrategyElements());
	}
	
	public ParserRule getResolutionStrategyRule() {
		return getResolutionStrategyAccess().getRule();
	}

	//ContainerConfiguration:
	//  documentation=DOCUMENTATION? "container" name=ID "agent" type=TypeRef contextBlock=
	//  ContextBlock?;
	public ContainerConfigurationElements getContainerConfigurationAccess() {
		return (pContainerConfiguration != null) ? pContainerConfiguration : (pContainerConfiguration = new ContainerConfigurationElements());
	}
	
	public ParserRule getContainerConfigurationRule() {
		return getContainerConfigurationAccess().getRule();
	}

	//URI returns ecore::EString:
	//  STRING; 
	//	
	//  / * returns types::URI * /
	public URIElements getURIAccess() {
		return (pURI != null) ? pURI : (pURI = new URIElements());
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}

	//Concern:
	//  documentation=DOCUMENTATION? "concern" name=ID concern=ConcernBlock;
	public ConcernElements getConcernAccess() {
		return (pConcern != null) ? pConcern : (pConcern = new ConcernElements());
	}
	
	public ParserRule getConcernRule() {
		return getConcernAccess().getRule();
	}

	//ConcernBlock:
	//  {ConcernBlock} ("extends" superConcerns+=ID ("," superConcerns+=ID)*)? "{" (contexts+=
	//  Context|functions+=Function)* "}";
	public ConcernBlockElements getConcernBlockAccess() {
		return (pConcernBlock != null) ? pConcernBlock : (pConcernBlock = new ConcernBlockElements());
	}
	
	public ParserRule getConcernBlockRule() {
		return getConcernBlockAccess().getRule();
	}

	//Filter:
	//  "(" predicate=Expression ")";
	public FilterElements getFilterAccess() {
		return (pFilter != null) ? pFilter : (pFilter = new FilterElements());
	}
	
	public ParserRule getFilterRule() {
		return getFilterAccess().getRule();
	}

	//PreCondition:
	//  "precondition" "{" asserts+=AssertionExpression+ "}";
	public PreConditionElements getPreConditionAccess() {
		return (pPreCondition != null) ? pPreCondition : (pPreCondition = new PreConditionElements());
	}
	
	public ParserRule getPreConditionRule() {
		return getPreConditionAccess().getRule();
	}

	//PostCondition:
	//  "postcondition" "{" asserts+=AssertionExpression+ "}";
	public PostConditionElements getPostConditionAccess() {
		return (pPostCondition != null) ? pPostCondition : (pPostCondition = new PostConditionElements());
	}
	
	public ParserRule getPostConditionRule() {
		return getPostConditionAccess().getRule();
	}

	//AssertionExpression:
	//  "assert" expr=Expression "," message=STRING ";";
	public AssertionExpressionElements getAssertionExpressionAccess() {
		return (pAssertionExpression != null) ? pAssertionExpression : (pAssertionExpression = new AssertionExpressionElements());
	}
	
	public ParserRule getAssertionExpressionRule() {
		return getAssertionExpressionAccess().getRule();
	}

	//ExpressionList:
	//  (expressions+=Expression ";")+;
	public ExpressionListElements getExpressionListAccess() {
		return (pExpressionList != null) ? pExpressionList : (pExpressionList = new ExpressionListElements());
	}
	
	public ParserRule getExpressionListRule() {
		return getExpressionListAccess().getRule();
	}

	//Function returns be::B3Function:
	//  {be::B3Function} documentation=DOCUMENTATION? visibility=Visibility? executionMode=
	//  ExecutionMode? final?="final"? "function" returnType=TypeRef? name=ID ("(" (parameters
	//  +=ParameterDeclaration ("," parameters+=ParameterDeclaration)*)? ")")? (":" funcExpr=
	//  Expression ";"|funcExpr=BlockExpression); 
	//
	//      
	//	    
	//   	    
	//        	   	
	//   	    
	//   	
	//   	    
	//   	 
	////   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
	//   	                   
	//   	        
	//	
	//	
	////TypeParamDeclaration 
	////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
	////	;
	//		
	/// * EXPRESSIONS * /
	public FunctionElements getFunctionAccess() {
		return (pFunction != null) ? pFunction : (pFunction = new FunctionElements());
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//AssignmentOperator returns ecore::EString:
	//  "="|"+="|"-="|"*="|"/="|"%="; 
	//	
	////TypeParamDeclaration 
	////	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
	////	;
	//		
	/// * EXPRESSIONS * / 
	// 
	//	              	        
	//// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
	////	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>="
	public AssignmentOperatorElements getAssignmentOperatorAccess() {
		return (pAssignmentOperator != null) ? pAssignmentOperator : (pAssignmentOperator = new AssignmentOperatorElements());
	}
	
	public ParserRule getAssignmentOperatorRule() {
		return getAssignmentOperatorAccess().getRule();
	}

	//RelationalOperator returns ecore::EString:
	//  "~="|"=="|"==="|"!="|"!=="|">="|"<="|">"|"<"; 
	//	
	// 
	//	                  
	//	              
	//	
	//
	//// All expressions, including variable and value definitions
	public RelationalOperatorElements getRelationalOperatorAccess() {
		return (pRelationalOperator != null) ? pRelationalOperator : (pRelationalOperator = new RelationalOperatorElements());
	}
	
	public ParserRule getRelationalOperatorRule() {
		return getRelationalOperatorAccess().getRule();
	}

	//TopLevelExpression returns be::BExpression:
	//  VarDeclaration|ValDeclaration|AssignmentExpression; 
	//
	//// All expressions, including variable and value definitions
	//     
	//	           
	//	
	//
	//// All expressions except variable and value definitions
	public TopLevelExpressionElements getTopLevelExpressionAccess() {
		return (pTopLevelExpression != null) ? pTopLevelExpression : (pTopLevelExpression = new TopLevelExpressionElements());
	}
	
	public ParserRule getTopLevelExpressionRule() {
		return getTopLevelExpressionAccess().getRule();
	}

	//Expression returns be::BExpression:
	//  AssignmentExpression; 
	//
	//// All expressions except variable and value definitions
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//AssignmentExpression returns be::BExpression:
	//  CachedExpression ({be::BAssignmentExpression.leftExpr=current} functionName=
	//  AssignmentOperator rightExpr=AssignmentExpression)?; 
	//
	//
	//    
	//	// note: VarDecl | OrExpr is order dependant
	//	      
	//	 	  
	//		
	//
	////AssignmentExpression returns be::BExpression:
	////	// note: VarDecl | OrExpr is order dependant
	////	 (VarDeclaration | ValDeclaration | CachedExpression) ({be::BAssignmentExpression.leftExpr=current} 
	////	 	functionName=AssignmentOperator rightExpr=AssignmentExpression)?
	////	;
	public AssignmentExpressionElements getAssignmentExpressionAccess() {
		return (pAssignmentExpression != null) ? pAssignmentExpression : (pAssignmentExpression = new AssignmentExpressionElements());
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}

	//VarDeclaration returns be::BExpression:
	//  {be::BDefValue} final?="final"? (("var"|type=TypeRef) name=ID) ("=" valueExpr=
	//  Expression)?; 	
	//
	////AssignmentExpression returns be::BExpression:
	////	// note: VarDecl | OrExpr is order dependant
	////	 (VarDeclaration | ValDeclaration | CachedExpression) ({be::BAssignmentExpression.leftExpr=current} 
	////	 	functionName=AssignmentOperator rightExpr=AssignmentExpression)?
	////	;
	public VarDeclarationElements getVarDeclarationAccess() {
		return (pVarDeclaration != null) ? pVarDeclaration : (pVarDeclaration = new VarDeclarationElements());
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}

	//ValDeclaration returns be::BExpression:
	//  {be::BDefValue} final?="final"? immutable?="val" type=TypeRef? name=ID "=" valueExpr=
	//  Expression;
	public ValDeclarationElements getValDeclarationAccess() {
		return (pValDeclaration != null) ? pValDeclaration : (pValDeclaration = new ValDeclarationElements());
	}
	
	public ParserRule getValDeclarationRule() {
		return getValDeclarationAccess().getRule();
	}

	//TypeRef returns be::IType:
	//  ClosureTypeRef|SimpleTypeRef; 
	//		
	//             // TODO: gets lots of warnings from this...
	public TypeRefElements getTypeRefAccess() {
		return (pTypeRef != null) ? pTypeRef : (pTypeRef = new TypeRefElements());
	}
	
	public ParserRule getTypeRefRule() {
		return getTypeRefAccess().getRule();
	}

	//SimpleTypeRef returns be::IType:
	//  {be::B3ParameterizedType} rawType=[be::B3JavaImport] ("<" actualArgumentsList+=[be
	//  ::B3JavaImport] ("," actualArgumentsList+=[be::B3JavaImport])* ">")?;   // TODO: gets lots of warnings from this...
	//    
	//	         
	//		                  
	////		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
	//	 
	//	
	//// TODO: typereference is simplified to only the name of a java type - for model imports
	//// the model is imported with name == namespace, and types in the model are referenced after
	//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
	//// referenced as mymodel::mytype
	//// There is more work required to link a reference to such a type and it is therefore deferred
	//// until we are up on Xtext 0.8 with better scoping and linking.
	//// For now, this is just proof of concept.
	//// 
	//
	//// ClosureTypeRef declares parameters and return type	TODO: use TypeRef instead of direct reference to imported class
	public SimpleTypeRefElements getSimpleTypeRefAccess() {
		return (pSimpleTypeRef != null) ? pSimpleTypeRef : (pSimpleTypeRef = new SimpleTypeRefElements());
	}
	
	public ParserRule getSimpleTypeRefRule() {
		return getSimpleTypeRefAccess().getRule();
	}

	//ClosureTypeRef returns be::IType:
	//  {be::B3FunctionType} ("(" (parameterTypes+=[be::B3JavaImport] ("," parameterTypes+=[
	//  be::B3JavaImport])*)? ")" "=>" returnType=[be::B3JavaImport]); 
	//	
	//// TODO: typereference is simplified to only the name of a java type - for model imports
	//// the model is imported with name == namespace, and types in the model are referenced after
	//// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
	//// referenced as mymodel::mytype
	//// There is more work required to link a reference to such a type and it is therefore deferred
	//// until we are up on Xtext 0.8 with better scoping and linking.
	//// For now, this is just proof of concept.
	//// 
	//
	//// ClosureTypeRef declares parameters and return type	TODO: use TypeRef instead of direct reference to imported class
	public ClosureTypeRefElements getClosureTypeRefAccess() {
		return (pClosureTypeRef != null) ? pClosureTypeRef : (pClosureTypeRef = new ClosureTypeRefElements());
	}
	
	public ParserRule getClosureTypeRefRule() {
		return getClosureTypeRefAccess().getRule();
	}

	//TypeParam returns be::IType:
	//  TypeRefParam|WildcardRefParam;
	public TypeParamElements getTypeParamAccess() {
		return (pTypeParam != null) ? pTypeParam : (pTypeParam = new TypeParamElements());
	}
	
	public ParserRule getTypeParamRule() {
		return getTypeParamAccess().getRule();
	}

	//TypeRefParam returns be::IType:
	//  TypeRef;
	public TypeRefParamElements getTypeRefParamAccess() {
		return (pTypeRefParam != null) ? pTypeRefParam : (pTypeRefParam = new TypeRefParamElements());
	}
	
	public ParserRule getTypeRefParamRule() {
		return getTypeRefParamAccess().getRule();
	}

	//WildcardRefParam returns be::IType:
	//  {be::B3WildcardType} "?" ("extends" upperBoundsList+=TypeRef ("," upperBoundsList+=
	//  TypeRef)*|"super" lowerBoundsList+=TypeRef)?;
	public WildcardRefParamElements getWildcardRefParamAccess() {
		return (pWildcardRefParam != null) ? pWildcardRefParam : (pWildcardRefParam = new WildcardRefParamElements());
	}
	
	public ParserRule getWildcardRefParamRule() {
		return getWildcardRefParamAccess().getRule();
	}

	//CachedExpression returns be::BExpression:
	//  {be::BCachedExpression} "cached" expr=OrExpression|OrExpression;
	public CachedExpressionElements getCachedExpressionAccess() {
		return (pCachedExpression != null) ? pCachedExpression : (pCachedExpression = new CachedExpressionElements());
	}
	
	public ParserRule getCachedExpressionRule() {
		return getCachedExpressionAccess().getRule();
	}

	//OrExpression returns be::BExpression:
	//  AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//AndExpression returns be::BExpression:
	//  RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=
	//  RelationalExpression)*; 
	//	
	//    
	//	      
	//
	//// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language.
	//// BitwiseExpression returns be::BExpression :
	//// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//RelationalExpression returns be::BExpression:
	//  InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
	//  RelationalOperator rightExpr=InstanceOfExpression)*; 
	//
	//// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language.
	//// BitwiseExpression returns be::BExpression :
	//// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//InstanceOfExpression returns be::BExpression:
	//  AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
	//  "instanceof" rightExpr=LiteralType)*; 
	//
	//      
	//	        
	//
	//// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language.	
	//// ShiftExpression returns be::BExpression:
	//// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
	public InstanceOfExpressionElements getInstanceOfExpressionAccess() {
		return (pInstanceOfExpression != null) ? pInstanceOfExpression : (pInstanceOfExpression = new InstanceOfExpressionElements());
	}
	
	public ParserRule getInstanceOfExpressionRule() {
		return getInstanceOfExpressionAccess().getRule();
	}

	//AdditiveExpression returns be::BExpression:
	//  MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
	//  ( "+" | "-" ) rightExpr=MultiplicativeExpression)*; 
	//
	//// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
	//// use the backend for some other language.	
	//// ShiftExpression returns be::BExpression:
	//// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//MultiplicativeExpression returns be::BExpression:
	//  SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=( "*" | "/" |
	//  "%" ) rightExpr=SetExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return (pMultiplicativeExpression != null) ? pMultiplicativeExpression : (pMultiplicativeExpression = new MultiplicativeExpressionElements());
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	//SetExpression returns be::BExpression:
	//  UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=
	//  ".." rightExpr=UnaryOrInfixExpression)*;
	public SetExpressionElements getSetExpressionAccess() {
		return (pSetExpression != null) ? pSetExpression : (pSetExpression = new SetExpressionElements());
	}
	
	public ParserRule getSetExpressionRule() {
		return getSetExpressionAccess().getRule();
	}

	//UnaryOrInfixExpression returns be::BExpression:
	//  PostopExpression|UnaryExpression|PreopExpression; 
	//
	//    
	//	   
	//	  
	//	  
	//	 
	//	
	//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
	//// kept as comment here if someone wants to use thi grammar for other purposes. 
	//// UnaryExpression returns be::BExpression:
	////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
	public UnaryOrInfixExpressionElements getUnaryOrInfixExpressionAccess() {
		return (pUnaryOrInfixExpression != null) ? pUnaryOrInfixExpression : (pUnaryOrInfixExpression = new UnaryOrInfixExpressionElements());
	}
	
	public ParserRule getUnaryOrInfixExpressionRule() {
		return getUnaryOrInfixExpressionAccess().getRule();
	}

	//UnaryExpression returns be::BExpression:
	//  {be::BUnaryOpExpression} functionName=( "!" | "-" ) expr=InfixExpression;  
	//	
	//// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
	//// kept as comment here if someone wants to use thi grammar for other purposes. 
	//// UnaryExpression returns be::BExpression:
	////	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//PreopExpression returns be::BExpression:
	//  {be::BUnaryPreOpExpression} functionName=( "++" | "--" ) expr=InfixExpression;
	public PreopExpressionElements getPreopExpressionAccess() {
		return (pPreopExpression != null) ? pPreopExpression : (pPreopExpression = new PreopExpressionElements());
	}
	
	public ParserRule getPreopExpressionRule() {
		return getPreopExpressionAccess().getRule();
	}

	//PostopExpression returns be::BExpression:
	//  InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName=( "--" | "++"
	//  ))?;
	public PostopExpressionElements getPostopExpressionAccess() {
		return (pPostopExpression != null) ? pPostopExpression : (pPostopExpression = new PostopExpressionElements());
	}
	
	public ParserRule getPostopExpressionRule() {
		return getPostopExpressionAccess().getRule();
	}

	//InfixExpression returns be::BExpression:
	//  CallExpression ({be::BCallExpression.funcExpr=current} "." name=ID "(" parameterList=
	//  ParameterList? ")"|{be::BAtExpression.objExpr=current} "[" indexExpr=Expression "]"|
	//  {be::BFeatureExpression.objExpr=current} "." featureName=ID)*;
	public InfixExpressionElements getInfixExpressionAccess() {
		return (pInfixExpression != null) ? pInfixExpression : (pInfixExpression = new InfixExpressionElements());
	}
	
	public ParserRule getInfixExpressionRule() {
		return getInfixExpressionAccess().getRule();
	}

	//CallExpression returns be::BExpression:
	//  PrimaryExpression ({be::BCallExpression.funcExpr=current} "(" parameterList=
	//  ParameterList? ")")*;
	public CallExpressionElements getCallExpressionAccess() {
		return (pCallExpression != null) ? pCallExpression : (pCallExpression = new CallExpressionElements());
	}
	
	public ParserRule getCallExpressionRule() {
		return getCallExpressionAccess().getRule();
	}

	//PrimaryExpression returns be::BExpression:
	//  FeatureCall|ConstructorCallExpression|VariableValue|Literal|PropertyValue|
	//  KeywordVariables|ParanthesizedExpression|IfExpression|BlockExpression|
	//  SwitchExpression|ThrowExpression|TryCatchExpression|WildcardExpression; 
	//		
	//    
	//	  
	//	  
	//	  
	//	   
	//	  
	//	  
	//	  
	//	  
	//	  
	//	  
	//	  
	//	  
	//	  
	////	| WithExpression
	//	 
	//	
	////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
	////WithClauseExpression returns Expression : {WithClauseExpression} 
	////	withclause=WithClause expr = BlockExpression 
	////	;
	////WithContextExpression returns Expresion : {WithContextExpression } 
	////	"with" "context" context = Expression expr = BlockExpression
	////	;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//WildcardExpression returns be::BExpression:
	//  {be::BLiteralAny} "_"; 
	//	
	////WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
	////WithClauseExpression returns Expression : {WithClauseExpression} 
	////	withclause=WithClause expr = BlockExpression 
	////	;
	////WithContextExpression returns Expresion : {WithContextExpression } 
	////	"with" "context" context = Expression expr = BlockExpression
	////	;
	public WildcardExpressionElements getWildcardExpressionAccess() {
		return (pWildcardExpression != null) ? pWildcardExpression : (pWildcardExpression = new WildcardExpressionElements());
	}
	
	public ParserRule getWildcardExpressionRule() {
		return getWildcardExpressionAccess().getRule();
	}

	//ThrowExpression returns be::BExpression:
	//  {be::BThrowExpression} "throw" expr=Expression;
	public ThrowExpressionElements getThrowExpressionAccess() {
		return (pThrowExpression != null) ? pThrowExpression : (pThrowExpression = new ThrowExpressionElements());
	}
	
	public ParserRule getThrowExpressionRule() {
		return getThrowExpressionAccess().getRule();
	}

	//TryCatchExpression returns be::BExpression:
	//  {be::BTryExpression} "try" tryExpr=Expression catchBlocks+=CatchBlock* ("finally"
	//  finallyExpr=Expression)? "endtry";
	public TryCatchExpressionElements getTryCatchExpressionAccess() {
		return (pTryCatchExpression != null) ? pTryCatchExpression : (pTryCatchExpression = new TryCatchExpressionElements());
	}
	
	public ParserRule getTryCatchExpressionRule() {
		return getTryCatchExpressionAccess().getRule();
	}

	//CatchBlock returns be::BCatch:
	//  {be::BCatch} "catch" exceptionType=TypeRef varname=ID ":" catchExpr=Expression;
	public CatchBlockElements getCatchBlockAccess() {
		return (pCatchBlock != null) ? pCatchBlock : (pCatchBlock = new CatchBlockElements());
	}
	
	public ParserRule getCatchBlockRule() {
		return getCatchBlockAccess().getRule();
	}

	//SwitchExpression returns be::BExpression:
	//  {be::BSwitchExpression} "switch" switchExpression=Expression? caseList+=Case+
	//  "endswitch";
	public SwitchExpressionElements getSwitchExpressionAccess() {
		return (pSwitchExpression != null) ? pSwitchExpression : (pSwitchExpression = new SwitchExpressionElements());
	}
	
	public ParserRule getSwitchExpressionRule() {
		return getSwitchExpressionAccess().getRule();
	}

	//Case returns be::BCase:
	//  {be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression; 
	//			
	//	               
	//
	//// TODO VAREXPR: Blockexpression can have local variables
	public CaseElements getCaseAccess() {
		return (pCase != null) ? pCase : (pCase = new CaseElements());
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}

	//BlockExpression returns be::BExpression:
	//  {be::BChainedExpression} "{" (expressions+=TopLevelExpression ";")* "}"; 
	//
	//// TODO VAREXPR: Blockexpression can have local variables
	public BlockExpressionElements getBlockExpressionAccess() {
		return (pBlockExpression != null) ? pBlockExpression : (pBlockExpression = new BlockExpressionElements());
	}
	
	public ParserRule getBlockExpressionRule() {
		return getBlockExpressionAccess().getRule();
	}

	//IfExpression returns be::BExpression:
	//  {be::BIfExpression} "if" conditionExpr=Expression "then" thenExpr=Expression (
	//  elseExpr=ElseIfExpression|"else" elseExpr=Expression)? "endif";
	public IfExpressionElements getIfExpressionAccess() {
		return (pIfExpression != null) ? pIfExpression : (pIfExpression = new IfExpressionElements());
	}
	
	public ParserRule getIfExpressionRule() {
		return getIfExpressionAccess().getRule();
	}

	//ElseIfExpression returns be::BExpression:
	//  {be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression (
	//  elseExpr=ElseIfExpression|"else" elseExpr=Expression)?;
	public ElseIfExpressionElements getElseIfExpressionAccess() {
		return (pElseIfExpression != null) ? pElseIfExpression : (pElseIfExpression = new ElseIfExpressionElements());
	}
	
	public ParserRule getElseIfExpressionRule() {
		return getElseIfExpressionAccess().getRule();
	}

	//PropertyValue returns be::BExpression:
	//  {be::BVariableExpression} name=PID;
	public PropertyValueElements getPropertyValueAccess() {
		return (pPropertyValue != null) ? pPropertyValue : (pPropertyValue = new PropertyValueElements());
	}
	
	public ParserRule getPropertyValueRule() {
		return getPropertyValueAccess().getRule();
	}

	//VariableValue returns be::BExpression:
	//  {be::BVariableExpression} name=ID;
	public VariableValueElements getVariableValueAccess() {
		return (pVariableValue != null) ? pVariableValue : (pVariableValue = new VariableValueElements());
	}
	
	public ParserRule getVariableValueRule() {
		return getVariableValueAccess().getRule();
	}

	//KeywordVariables returns be::BExpression:
	//  {be::BVariableExpression} name=( InputKeyword | OutputKeyword | "properties" | "unit" );
	public KeywordVariablesElements getKeywordVariablesAccess() {
		return (pKeywordVariables != null) ? pKeywordVariables : (pKeywordVariables = new KeywordVariablesElements());
	}
	
	public ParserRule getKeywordVariablesRule() {
		return getKeywordVariablesAccess().getRule();
	}

	//FeatureCall returns be::BExpression:
	//  OperationCall;
	public FeatureCallElements getFeatureCallAccess() {
		return (pFeatureCall != null) ? pFeatureCall : (pFeatureCall = new FeatureCallElements());
	}
	
	public ParserRule getFeatureCallRule() {
		return getFeatureCallAccess().getRule();
	}

	//OperationCall returns be::BCallExpression:
	//  {be::BCallExpression} name=( ID | PID ) "(" parameterList=ParameterList? ")";
	public OperationCallElements getOperationCallAccess() {
		return (pOperationCall != null) ? pOperationCall : (pOperationCall = new OperationCallElements());
	}
	
	public ParserRule getOperationCallRule() {
		return getOperationCallAccess().getRule();
	}

	//ConstructorCallExpression returns be::BExpression:
	//  {be::BCreateExpression} "new" typeExpr=LiteralType ("(" parameterList=ParameterList?
	//  ")")? ("as" alias=ID)? contextBlock=ContextBlock?;
	public ConstructorCallExpressionElements getConstructorCallExpressionAccess() {
		return (pConstructorCallExpression != null) ? pConstructorCallExpression : (pConstructorCallExpression = new ConstructorCallExpressionElements());
	}
	
	public ParserRule getConstructorCallExpressionRule() {
		return getConstructorCallExpressionAccess().getRule();
	}

	//Context:
	//  "context" selector=ContextSelector block=ContextBlock;
	public ContextElements getContextAccess() {
		return (pContext != null) ? pContext : (pContext = new ContextElements());
	}
	
	public ParserRule getContextRule() {
		return getContextAccess().getRule();
	}

	//ContextSelector:
	//  TypeRefSelector|ExpressionSelector|UnitSelector;
	public ContextSelectorElements getContextSelectorAccess() {
		return (pContextSelector != null) ? pContextSelector : (pContextSelector = new ContextSelectorElements());
	}
	
	public ParserRule getContextSelectorRule() {
		return getContextSelectorAccess().getRule();
	}

	//TypeRefSelector returns ContextSelector:
	//  type=TypeRef;
	public TypeRefSelectorElements getTypeRefSelectorAccess() {
		return (pTypeRefSelector != null) ? pTypeRefSelector : (pTypeRefSelector = new TypeRefSelectorElements());
	}
	
	public ParserRule getTypeRefSelectorRule() {
		return getTypeRefSelectorAccess().getRule();
	}

	//ExpressionSelector:
	//  expr=Expression;
	public ExpressionSelectorElements getExpressionSelectorAccess() {
		return (pExpressionSelector != null) ? pExpressionSelector : (pExpressionSelector = new ExpressionSelectorElements());
	}
	
	public ParserRule getExpressionSelectorRule() {
		return getExpressionSelectorAccess().getRule();
	}

	//UnitSelector:
	//  "unit" interface=QID ("/" (name=UnitName|namePattern=REGULAR_EXPR) ("/" versionRange=
	//  VersionRange)?)?;
	public UnitSelectorElements getUnitSelectorAccess() {
		return (pUnitSelector != null) ? pUnitSelector : (pUnitSelector = new UnitSelectorElements());
	}
	
	public ParserRule getUnitSelectorRule() {
		return getUnitSelectorAccess().getRule();
	}

	//ContextBlock returns be::BExpression:
	//  {be::BChainedExpression} "{" (expressions+=FunctionDefinition|expressions+=
	//  TopLevelExpression ";")* "}"; 
	//
	//         
	//	      
	////		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
	//		     
	////		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
	//		    
	//		
	//					
	////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
	////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = NamedPropertySet ;
	public ContextBlockElements getContextBlockAccess() {
		return (pContextBlock != null) ? pContextBlock : (pContextBlock = new ContextBlockElements());
	}
	
	public ParserRule getContextBlockRule() {
		return getContextBlockAccess().getRule();
	}

	//FunctionDefinition returns be::BExpression:
	//  {be::BDefFunction} function=Function; 
	//					
	////ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
	////PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = NamedPropertySet ;
	//              
	////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
	public FunctionDefinitionElements getFunctionDefinitionAccess() {
		return (pFunctionDefinition != null) ? pFunctionDefinition : (pFunctionDefinition = new FunctionDefinitionElements());
	}
	
	public ParserRule getFunctionDefinitionRule() {
		return getFunctionDefinitionAccess().getRule();
	}

	//Literal returns be::BExpression:
	//  ValueLiteral|RegexpLiteral|LiteralMap|LiteralList|LiteralFunction; 
	////BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//LiteralList returns be::BExpression:
	//  {be::BLiteralListExpression} "[" ("<" entryType=TypeRef ">")? entries+=Expression (","
	//  entries+=Expression)* "]"|{be::BLiteralListExpression} "[" "<" entryType=TypeRef ">"
	//  "]";
	public LiteralListElements getLiteralListAccess() {
		return (pLiteralList != null) ? pLiteralList : (pLiteralList = new LiteralListElements());
	}
	
	public ParserRule getLiteralListRule() {
		return getLiteralListAccess().getRule();
	}

	//LiteralMap returns be::BExpression:
	//  {be::BLiteralMapExpression} "[" ("<" keyType=TypeRef "," valueType=TypeRef ">")?
	//  entries+=MapEntry ("," entries+=MapEntry)* "]"|{be::BLiteralMapExpression} "[" "<"
	//  keyType=TypeRef "," valueType=TypeRef ">" "]";
	public LiteralMapElements getLiteralMapAccess() {
		return (pLiteralMap != null) ? pLiteralMap : (pLiteralMap = new LiteralMapElements());
	}
	
	public ParserRule getLiteralMapRule() {
		return getLiteralMapAccess().getRule();
	}

	//LiteralFunction returns be::BExpression:
	//  {be::B3Function} "{" ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (
	//  "," parameters+=ParameterDeclaration)*)? "|" funcExpr=OneOrManyExpressions "}";
	public LiteralFunctionElements getLiteralFunctionAccess() {
		return (pLiteralFunction != null) ? pLiteralFunction : (pLiteralFunction = new LiteralFunctionElements());
	}
	
	public ParserRule getLiteralFunctionRule() {
		return getLiteralFunctionAccess().getRule();
	}

	//ClosureExpression returns be::BExpression:
	//  {be::B3Function} ("<" returnType=TypeRef ">")? (parameters+=ParameterDeclaration (","
	//  parameters+=ParameterDeclaration)*)? "|" funcExpr=OneOrManyExpressions;
	public ClosureExpressionElements getClosureExpressionAccess() {
		return (pClosureExpression != null) ? pClosureExpression : (pClosureExpression = new ClosureExpressionElements());
	}
	
	public ParserRule getClosureExpressionRule() {
		return getClosureExpressionAccess().getRule();
	}

	//OneOrManyExpressions returns be::BExpression:
	//  BlockExpressionWithoutBrackets|Expression; 
	//
	//    
	//	  
	//	  
	//	
	//// TODO VAREXPR - can have variable definitions
	public OneOrManyExpressionsElements getOneOrManyExpressionsAccess() {
		return (pOneOrManyExpressions != null) ? pOneOrManyExpressions : (pOneOrManyExpressions = new OneOrManyExpressionsElements());
	}
	
	public ParserRule getOneOrManyExpressionsRule() {
		return getOneOrManyExpressionsAccess().getRule();
	}

	//BlockExpressionWithoutBrackets returns be::BExpression:
	//  {be::BChainedExpression} (expressions+=TopLevelExpression ";")+; 
	//// TODO VAREXPR - can have variable definitions
	public BlockExpressionWithoutBracketsElements getBlockExpressionWithoutBracketsAccess() {
		return (pBlockExpressionWithoutBrackets != null) ? pBlockExpressionWithoutBrackets : (pBlockExpressionWithoutBrackets = new BlockExpressionWithoutBracketsElements());
	}
	
	public ParserRule getBlockExpressionWithoutBracketsRule() {
		return getBlockExpressionWithoutBracketsAccess().getRule();
	}

	//MapEntry returns be::BMapEntry:
	//  {be::BMapEntry} key=KeyLiteral ":" value=Expression;
	public MapEntryElements getMapEntryAccess() {
		return (pMapEntry != null) ? pMapEntry : (pMapEntry = new MapEntryElements());
	}
	
	public ParserRule getMapEntryRule() {
		return getMapEntryAccess().getRule();
	}

	//KeyLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=( ID | PID | STRING );
	public KeyLiteralElements getKeyLiteralAccess() {
		return (pKeyLiteral != null) ? pKeyLiteral : (pKeyLiteral = new KeyLiteralElements());
	}
	
	public ParserRule getKeyLiteralRule() {
		return getKeyLiteralAccess().getRule();
	}

	//LiteralType returns be::BExpression:
	//  {be::BLiteralType} type=TypeRef;
	public LiteralTypeElements getLiteralTypeAccess() {
		return (pLiteralType != null) ? pLiteralType : (pLiteralType = new LiteralTypeElements());
	}
	
	public ParserRule getLiteralTypeRule() {
		return getLiteralTypeAccess().getRule();
	}

	//ValueLiteral returns be::BExpression:
	//  BooleanLiteral|RealLiteral|IntegerLiteral|NullLiteral|StringLiteral|UnitLiteral; 
	//
	//     
	//	   
	//	     // SEE ISSUE 297089 - must be placed before IntegerLiteral
	//	    
	//	   
	//	  
	////	| QueryLiteral
	public ValueLiteralElements getValueLiteralAccess() {
		return (pValueLiteral != null) ? pValueLiteral : (pValueLiteral = new ValueLiteralElements());
	}
	
	public ParserRule getValueLiteralRule() {
		return getValueLiteralAccess().getRule();
	}

	//BooleanLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=BooleanValue;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//IntegerLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=IntValue;
	public IntegerLiteralElements getIntegerLiteralAccess() {
		return (pIntegerLiteral != null) ? pIntegerLiteral : (pIntegerLiteral = new IntegerLiteralElements());
	}
	
	public ParserRule getIntegerLiteralRule() {
		return getIntegerLiteralAccess().getRule();
	}

	//UnitLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value="unit";
	public UnitLiteralElements getUnitLiteralAccess() {
		return (pUnitLiteral != null) ? pUnitLiteral : (pUnitLiteral = new UnitLiteralElements());
	}
	
	public ParserRule getUnitLiteralRule() {
		return getUnitLiteralAccess().getRule();
	}

	//StringLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return (pStringLiteral != null) ? pStringLiteral : (pStringLiteral = new StringLiteralElements());
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//RealLiteral returns be::BExpression:
	//  {be::BLiteralExpression} value=RealValue;
	public RealLiteralElements getRealLiteralAccess() {
		return (pRealLiteral != null) ? pRealLiteral : (pRealLiteral = new RealLiteralElements());
	}
	
	public ParserRule getRealLiteralRule() {
		return getRealLiteralAccess().getRule();
	}

	//RegexpLiteral returns be::BExpression:
	//  {be::BRegularExpression} pattern=REGULAR_EXPR;
	public RegexpLiteralElements getRegexpLiteralAccess() {
		return (pRegexpLiteral != null) ? pRegexpLiteral : (pRegexpLiteral = new RegexpLiteralElements());
	}
	
	public ParserRule getRegexpLiteralRule() {
		return getRegexpLiteralAccess().getRule();
	}

	//NullLiteral returns be::BExpression:
	//  {be::BLiteralExpression} "null"; 
	//	          // TODO: check that type is Object
	//
	////ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
	////SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
	//
	//// Has conversion rule
	public NullLiteralElements getNullLiteralAccess() {
		return (pNullLiteral != null) ? pNullLiteral : (pNullLiteral = new NullLiteralElements());
	}
	
	public ParserRule getNullLiteralRule() {
		return getNullLiteralAccess().getRule();
	}

	//BooleanValue returns ecore::EBooleanObject:
	//  "true"|"false";   // TODO: check that type is Object
	//
	////ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
	////SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";
	//
	//// Has conversion rule
	//              
	//
	//// Has conversion rule
	public BooleanValueElements getBooleanValueAccess() {
		return (pBooleanValue != null) ? pBooleanValue : (pBooleanValue = new BooleanValueElements());
	}
	
	public ParserRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}

	//RealValue returns ecore::EDoubleObject:
	//  REAL; 
	//
	//// Has conversion rule
	//        
	//
	//// Has conversion rule that handles dec, oct, and hex values with radix
	public RealValueElements getRealValueAccess() {
		return (pRealValue != null) ? pRealValue : (pRealValue = new RealValueElements());
	}
	
	public ParserRule getRealValueRule() {
		return getRealValueAccess().getRule();
	}

	//IntValue returns ecore::EIntegerObject:
	//  INT|HEX; 
	//
	//// Has conversion rule that handles dec, oct, and hex values with radix
	public IntValueElements getIntValueAccess() {
		return (pIntValue != null) ? pIntValue : (pIntValue = new IntValueElements());
	}
	
	public ParserRule getIntValueRule() {
		return getIntValueAccess().getRule();
	}

	//ParanthesizedExpression returns be::BExpression:
	//  "(" Expression ")";
	public ParanthesizedExpressionElements getParanthesizedExpressionAccess() {
		return (pParanthesizedExpression != null) ? pParanthesizedExpression : (pParanthesizedExpression = new ParanthesizedExpressionElements());
	}
	
	public ParserRule getParanthesizedExpressionRule() {
		return getParanthesizedExpressionAccess().getRule();
	}

	//Version:
	//  version=VersionLiteral;
	public VersionElements getVersionAccess() {
		return (pVersion != null) ? pVersion : (pVersion = new VersionElements());
	}
	
	public ParserRule getVersionRule() {
		return getVersionAccess().getRule();
	}

	//VersionLiteral returns types::Version:
	//  STRING|AlfanumSym;
	public VersionLiteralElements getVersionLiteralAccess() {
		return (pVersionLiteral != null) ? pVersionLiteral : (pVersionLiteral = new VersionLiteralElements());
	}
	
	public ParserRule getVersionLiteralRule() {
		return getVersionLiteralAccess().getRule();
	}

	//VersionRange:
	//  range=VersionRangeLiteral;
	public VersionRangeElements getVersionRangeAccess() {
		return (pVersionRange != null) ? pVersionRange : (pVersionRange = new VersionRangeElements());
	}
	
	public ParserRule getVersionRangeRule() {
		return getVersionRangeAccess().getRule();
	}

	//VersionRangeLiteral returns types::VersionRange:
	//  ("["|"(") (STRING|AlfanumSym) ("," (STRING|AlfanumSym))? ("]"|")")|(STRING|
	//  AlfanumSym); 
	//
	//    
	//	                      
	//	      
	//	
	//
	//// Reference to qualified named item, possibly in unit, this or super, or
	//// this.super, or unit.super
	public VersionRangeLiteralElements getVersionRangeLiteralAccess() {
		return (pVersionRangeLiteral != null) ? pVersionRangeLiteral : (pVersionRangeLiteral = new VersionRangeLiteralElements());
	}
	
	public ParserRule getVersionRangeLiteralRule() {
		return getVersionRangeLiteralAccess().getRule();
	}

	//QIDREF returns ecore::EString:
	//  ("super"|("unit"|"this") ("." "super")?) ("." QID)?|QID; 
	//
	//// Reference to qualified named item, possibly in unit, this or super, or
	//// this.super, or unit.super
	//                        
	//
	//// Qualified name
	public QIDREFElements getQIDREFAccess() {
		return (pQIDREF != null) ? pQIDREF : (pQIDREF = new QIDREFElements());
	}
	
	public ParserRule getQIDREFRule() {
		return getQIDREFAccess().getRule();
	}

	//QID returns ecore::EString hidden ( ):
	//  ID (INT|HEX|ID)* ("." ID (INT|HEX|ID)*)*; 
	//
	//// Qualified name
	public QIDElements getQIDAccess() {
		return (pQID != null) ? pQID : (pQID = new QIDElements());
	}
	
	public ParserRule getQIDRule() {
		return getQIDAccess().getRule();
	}

	//PropertyName returns ecore::EString:
	//  PID;
	public PropertyNameElements getPropertyNameAccess() {
		return (pPropertyName != null) ? pPropertyName : (pPropertyName = new PropertyNameElements());
	}
	
	public ParserRule getPropertyNameRule() {
		return getPropertyNameAccess().getRule();
	}

	//EscapedQualifiedName returns ecore::EString:
	//  STRING|QID;
	public EscapedQualifiedNameElements getEscapedQualifiedNameAccess() {
		return (pEscapedQualifiedName != null) ? pEscapedQualifiedName : (pEscapedQualifiedName = new EscapedQualifiedNameElements());
	}
	
	public ParserRule getEscapedQualifiedNameRule() {
		return getEscapedQualifiedNameAccess().getRule();
	}

	//InterfaceName returns ecore::EString:
	//  QID; 
	//    
	//
	//// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
	//// do not allow being broken across lines.
	////
	public InterfaceNameElements getInterfaceNameAccess() {
		return (pInterfaceName != null) ? pInterfaceName : (pInterfaceName = new InterfaceNameElements());
	}
	
	public ParserRule getInterfaceNameRule() {
		return getInterfaceNameAccess().getRule();
	}

	//CompoundName returns ecore::EString:
	//  EscapedQualifiedName "/" EscapedQualifiedName; 
	//
	//// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
	//// do not allow being broken across lines.
	////
	//          
	//
	//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
	public CompoundNameElements getCompoundNameAccess() {
		return (pCompoundName != null) ? pCompoundName : (pCompoundName = new CompoundNameElements());
	}
	
	public ParserRule getCompoundNameRule() {
		return getCompoundNameAccess().getRule();
	}

	//UnitName returns ecore::EString:
	//  EscapedQualifiedName; 
	//
	//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
	public UnitNameElements getUnitNameAccess() {
		return (pUnitName != null) ? pUnitName : (pUnitName = new UnitNameElements());
	}
	
	public ParserRule getUnitNameRule() {
		return getUnitNameAccess().getRule();
	}

	//PartName returns ecore::EString:
	//  EscapedQualifiedName;
	public PartNameElements getPartNameAccess() {
		return (pPartName != null) ? pPartName : (pPartName = new PartNameElements());
	}
	
	public ParserRule getPartNameRule() {
		return getPartNameAccess().getRule();
	}

	//enum Visibility returns be::Visibility:
	//  public | private;
	public VisibilityElements getVisibilityAccess() {
		return (unknownRuleVisibility != null) ? unknownRuleVisibility : (unknownRuleVisibility = new VisibilityElements());
	}
	
	public EnumRule getVisibilityRule() {
		return getVisibilityAccess().getRule();
	}

	//enum ExecutionMode returns be::ExecutionMode:
	//  parallel | sequential; 
	//   	           
	//
	//
	//// Version, and VersionRange
	//// TODO: uncertain if the set of allowed chars is definitive.
	////
	public ExecutionModeElements getExecutionModeAccess() {
		return (unknownRuleExecutionMode != null) ? unknownRuleExecutionMode : (unknownRuleExecutionMode = new ExecutionModeElements());
	}
	
	public EnumRule getExecutionModeRule() {
		return getExecutionModeAccess().getRule();
	}

	//Separator returns ecore::EString:
	//  "."|"-"|"!"|"@"|"$"|"%"|"&"|"+"|"="|"*"|"<"|">"|":"|"?"; 
	//
	//
	//// Version, and VersionRange
	//// TODO: uncertain if the set of allowed chars is definitive.
	////
	public SeparatorElements getSeparatorAccess() {
		return (pSeparator != null) ? pSeparator : (pSeparator = new SeparatorElements());
	}
	
	public ParserRule getSeparatorRule() {
		return getSeparatorAccess().getRule();
	}

	//AlfanumSym returns ecore::EString:
	//  (ID|INT|HEX|EXT_INT) (Separator|ID|INT|HEX|EXT_INT)*; 
	//                      
	//
	//// --TERMINALS
	//// (Does not use standard terminals to have full control).
	//
	//// TODO: Possibly use some other char instead of ^ as escape mechanism ??
	public AlfanumSymElements getAlfanumSymAccess() {
		return (pAlfanumSym != null) ? pAlfanumSym : (pAlfanumSym = new AlfanumSymElements());
	}
	
	public ParserRule getAlfanumSymRule() {
		return getAlfanumSymAccess().getRule();
	}

	//terminal ID:
	//  "^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "0".."9" | "_")*; 
	//
	//// --TERMINALS
	//// (Does not use standard terminals to have full control).
	//
	//// TODO: Possibly use some other char instead of ^ as escape mechanism ??
	//          
	//
	//// Property Names start with $ and are qualified. Must be handled by lexer as
	//// a.b.c is otherwise ambigous in expressions.
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal PID:
	//  "$" ID ("." ID)*; 
	//
	//// Property Names start with $ and are qualified. Must be handled by lexer as
	//// a.b.c is otherwise ambigous in expressions.
	//              
	//
	//// Java regexp - allows \ before any character == same as unescaped character if character is not an operator
	public TerminalRule getPIDRule() {
		return (tPID != null) ? tPID : (tPID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PID"));
	} 

	//terminal REGULAR_EXPR returns be::RegexpPattern:
	//  "~/" ("\\" !("\t" | "\r" | "\n") | !("\\" | "/" | " " | "\t" | "\r" | "\n"))* "/" ("u" | "m" | "i" | "c" |
	//  "d")*; 
	//
	//// Java regexp - allows \ before any character == same as unescaped character if character is not an operator
	//      
	//	        
	//			      
	//			
	//
	//// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
	//// A string converter may need to handle the u, x, and octal escapes.
	//// Regular java string handles XXXX , and gives syntax error if
	//// format is not ok, the other two remains, and possibly the null.
	public TerminalRule getREGULAR_EXPRRule() {
		return (tREGULAR_EXPR != null) ? tREGULAR_EXPR : (tREGULAR_EXPR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REGULAR_EXPR"));
	} 

	//terminal STRING:
	//  "\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "x" | "0" | "\"" | "\'" | "\\") | !("\\" | "\"" | "\r" | "\n")
	//  )* "\"" | "\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "x" | "0" | "\"" | "\'" | "\\") | !("\\" | "\'" |
	//  "\r" | "\n"))* "\'"; 
	//
	//// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
	//// A string converter may need to handle the u, x, and octal escapes.
	//// Regular java string handles XXXX , and gives syntax error if
	//// format is not ok, the other two remains, and possibly the null.
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal DOCUMENTATION:
	//  "/ **"->"* /";
	public TerminalRule getDOCUMENTATIONRule() {
		return (tDOCUMENTATION != null) ? tDOCUMENTATION : (tDOCUMENTATION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOCUMENTATION"));
	} 

	//terminal ML_COMMENT:
	//  "/ *" !"*"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//terminal SL_COMMENT:
	//  "//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//  (" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal HEX:
	//  "0" ("x" | "X") ("0".."9" | "a".."f" | "A".."F")+;
	public TerminalRule getHEXRule() {
		return (tHEX != null) ? tHEX : (tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX"));
	} 

	//terminal INT:
	//  "0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//REAL returns ecore::EString hidden ( ):
	//  INT? "." (EXT_INT|INT);
	public REALElements getREALAccess() {
		return (pREAL != null) ? pREAL : (pREAL = new REALElements());
	}
	
	public ParserRule getREALRule() {
		return getREALAccess().getRule();
	}

	//terminal EXT_INT:
	//  INT ("e" | "E") ("-" | "+") INT;
	public TerminalRule getEXT_INTRule() {
		return (tEXT_INT != null) ? tEXT_INT : (tEXT_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EXT_INT"));
	} 

	//terminal ANY_OTHER:
	//  .;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 
}
