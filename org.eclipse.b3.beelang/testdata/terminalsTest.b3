
unit a.b0x.a2 {

	properties numbers {
		// INT
		$a = 1;
		$a = 10;
		
		// HEX
		$a = 0x34;
		$a = 0x0aA;
		$a = 0x7fffffffffffffff;
		
		// $a = 0x; // uncomment to test syntax error
		// $a = 0xghijk; // uncomment to test syntax error
		
		// REAL
		$a = 1.0;
		$a = .0;
		$a = 1.;
		
		$a = 1e+10;
		$a = 1E+10;
		$a = 1e-10;
		$a = 1E-10;

		$a = 1.0e+10;
		$a = 1.0E+10;
		$a = 1.0e-10;
		$a = 1.0E-10;

		$a = .1e+10;
		$a = .1E+10;
		$a = .1e-10;
		$a = .1E-10;

		$a = 1.e+10;
		$a = 1.1E+10;
		$a = 1.1e-10;
		$a = 1.1E-10;
	
		$a = 0.2e+2;
		$a = 3/4/3;
		$b = 0.3e+3;
		}
		
	properties strings {
		$a = "string";
		$a = 'string';
		$a ='33\u0000\x00\00aaa';
		
//		$a = " // uncomment to test error - strings can not contain \r or \n
//		";

		$a = "aba \\";
		$a = "~/pattern/g";
		}
		
	properties patterns {
		// a prefix of ~ is required, JS does not need a ~
		// regexp supports JS regexp syntax (?) - Java's has more features.
		$a = ~/([Jj]ava([Ss]cript))\sis\s(fun\w*)/g;
		$a = ~/pattern/g;
		
		// a prefix of ~ to {} creates a literal query
		$literalQuery = query {:**[name=="fred"]};
		}
	properties naming {
		// hex in name
		$a10x23 = 2;
		$a1.a2 = 10;
		$a1234.ea2e = 0.2e+2;
		
		// potential REAL clash - must check result to detect parsing error
		$a = $a1.e+2;
		$a.unit_ = 2;
		}
	properties _null {
		$a = null;
		}
}