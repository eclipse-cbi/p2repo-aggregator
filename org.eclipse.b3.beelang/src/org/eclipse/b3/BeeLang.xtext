/*
 * Copyright (c) 2009, Cloudsmith Inc and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * Contributors:
 * - Cloudsmith Inc - initial API and implementation.
 */

// define the grammar. Do not use defaults terminals to get full control.
grammar org.eclipse.b3.BeeLang // with org.eclipse.xtext.common.Terminals

// enables use of ecore types
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// backend model defines general expressions
import "platform:/resource/org.eclipse.b3.backend/model/B3Backend.ecore" as be

// build model defines build specific expression
import "platform:/resource/org.eclipse.b3.build/model/B3Build.ecore" as build

generate beeLang "http://www.eclipse.org/b3/BeeLang"

BeeModel hidden(WS, SL_COMMENT, ML_COMMENT): 
	(imports += Import)* 
	(	(functions += Function) 
	| 	(concern += Concern_Named)
	|	('properties'  propertySets += PropertySet_Named)
	)* 
	(body = BuildUnit)? 
	;

Import returns be::IType : {be::B3JavaImport}
	(reexport ?='reexport')? "import" qualifiedName = QID ("as" name=ID)? ';' 
	;

// Wanted later 
//Import : (reexport ?='reexport')? 
//		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
//	; 

//JavaImporter 	: qualifiedName=QID ;
//NativeImporter 	: uriString = STRING ;
		
BuildUnit returns build::BuildUnit hidden(WS, ML_COMMENT, SL_COMMENT) : {build::BuildUnit}
	(documentation = DOCUMENTATION)?
	(executionMode = ExecutionMode)?
	'unit' (name=UnitName)? ('version' version = VersionLiteral)?
		('implements' implements += SimpleTypeRef (',' implements+=SimpleTypeRef)*)? 
	'{'
		(	//-- PROPERTIES
			// goes first, because they may be used in the other clauses. TODO: can probably be relaxed
			// since linking will find them anyway.
			//
			  ('default' 'properties'  defaultProperties = PropertySet)
		)?
		( 	//-- PROVIDES
			  ('provides' '{' (providedCapabilities += ProvidedCapability ';')+ '}')
			| ('provides' providedCapabilities += ProvidedCapability ';')
			//-- REQUIRES & META REQUIRES
			| ('requires' '{' (requiredCapabilities += AliasedRequiredCapability ';')+ '}')
			| ('requires' requiredCapabilities += AliasedRequiredCapability ';')
			| ('env' 'requires' '{' (metaRequiredCapabilities += RequiredCapability ';')+ '}' )
			| ('env' 'requires' metaRequiredCapabilities += RequiredCapability ';')
			//--CONCERNS
			| (concerns += Concern_Named)
			//--SYNCHRONIZE
			| ('sequential' '{' (synchronizations += Synchronization )+  '}' )
			| ('sequential' synchronizations += Synchronization  )
			//--BUILDERS & FUNCTIONS
			| (functions += Builder )			
			| (functions += Function )			
			//-- REPOSITORIES
			| ('repositories' '{' (repositories+=RepositoryConfiguration)* '}' )
			| ('properties'  propertySets += PropertySet_Named)
			| ('containers' '{' containers += ContainerConfiguration* '}' )
		)*
	'}';

ProvidedCapability returns build::VersionedCapability : {build::VersionedCapability}
	('when' '(' condExpr=Expression ')')?  
	nameSpace=InterfaceName '/' name=CapabilityName 
	('/' version=VersionLiteral)?  
	;

// Capability required by a unit - always refers to capabilities with at least ns/name
// or the keyword "unit" instead of the namespace for buildunits
AliasedRequiredCapability returns build::RequiredCapability : {build::AliasedRequiredCapability} 
	('when' '(' condExpr=Expression ')')?  
	((nameSpace=InterfaceName) | "unit") '/' name=CapabilityName 
	('/' versionRange=VersionRangeLiteral)?  ("as" alias = ID)?
	;
	
// Capability required by a unit - always refers to capabilities with at least ns/name
// or the keyword "unit" instead of the namespace for buildunits
RequiredCapability returns build::RequiredCapability : {build::RequiredCapability} 
	('when' '(' condExpr=Expression ')')?  
	((nameSpace=InterfaceName) | "unit") '/' name=CapabilityName 
	('/' versionRange=VersionRangeLiteral)?  
	;
	
// Capability required by a unit - always refers to capabilities with at least ns/name
// or the keyword "unit" instead of the namespace for buildunits
RequiredCapability_Unfiltered returns build::RequiredCapability : {build::RequiredCapability} 
	((nameSpace=InterfaceName) | "unit") '/' name=CapabilityName 
	('/' versionRange=VersionRangeLiteral)?  
	;
	
// An optionally named sequence of property statements
PropertySet_Named returns be::BPropertySet : {be::BPropertySet} 
	name = ID ("extends" extends=[be::BPropertySet | QIDREF])? '{' (operations += PropertyOperation )* '}' 
	;

// Sequence of possibly filtered property statements	
PropertySet returns be::BPropertySet :  {be::BPropertySet}
	("extends" extends=[be::BPropertySet | QIDREF])?  '{' (operations += PropertyOperation )*  '}'
	;

// For model generation, to get supertype correct
PropertyOperation returns be::BPropertyOperation
	: ConditionalPropertyOperation 
	| PropertyDefinitionOperation 
	| PropertySetOperation
	;

ConditionalPropertyOperation returns be::BPropertyOperation : {be::BConditionalPropertyOperation}
	'when' '(' condExpr=Expression ')' 
		(body=PropertyDefinitionOperation | body=PropertySetOperation) 
	;
PropertyDefinitionOperation returns be::BPropertyOperation : {be::BPropertyDefinitionOperation}
	(definition = PropertyValDeclaration | definition = PropertyVarDeclaration)
	;
		
// property values, must be assigned (but can be assigned null).
PropertyValDeclaration returns be::BDefProperty : {be::BDefProperty} 
	( final ?= "final")? type=TypeRef? name=PID '=' valueExpr = Expression ';'
	;
	
// property variables, value optionally assigned
PropertyVarDeclaration returns be::BDefProperty : {be::BDefProperty}
	( final ?= "final")? (mutable ?= "mutable")  type=TypeRef? name=PID ('=' valueExpr = Expression)? ';'
	;
	
PropertySetOperation returns be::BPropertyOperation : {be::BPropertySetOperation} 
	propertySet = PropertySet
	;

Synchronization returns build::Synchronization : {build::Synchronization}
	(builders += SynchronizedBuilder)(',' builders += SynchronizedBuilder)+ ';'
	;

// TODO: This is really a builder reference (which could be reused/refactored)	
SynchronizedBuilder returns build::SynchronizedBuilder : {build::SynchronizedBuilder}
	nameSpace=EscapedQualifiedName '/' name=EscapedQualifiedName ('#' builderName = BuilderName)?
	| builderName = BuilderName
	;
	
PathGroup returns build::PathGroup: {build::PathGroup}
	pathVectors+=PathVector+ ('annotations' annotations = PropertySet)?
	;

PathVector returns build::PathVector
	: BasePathVector
	| UnbasedPathVector
	| CompoundPathVector
	;
	
BasePathVector returns build::PathVector : {build::PathVectorElement}
	("when" '(' condExpr=Expression ')')?
	basePath=Path '[' ( paths+=Path (',' paths+=Path)*)? ']' ';'
	;

UnbasedPathVector returns build::PathVector : {build::PathVectorElement}
	("when" '(' condExpr=Expression ')')?
	paths+=Path (',' paths+=Path)* ';'
	;
	
CompoundPathVector returns build::PathVector : {build::CompoundPathVector}
	"when" '(' condExpr=Expression ')'
	'{' (pathVectors += PathVector)* '}' 
	;

// A path can be written without quotes if it consists of safe chars 
Path hidden()
	: STRING
	| ('/')? QID ('/' QID)* ('/')? 
	;

Prerequisite returns build::Prerequisite : {build::Prerequisite} 
	('when' '(' condExpr=Expression ')' )?
	(withExpr = WithClause)?
	buildResult=BuildResultReference
	("as" alias=ID)? ';'
	;

// Validation checks that there is at least one of references, properties or concern.
WithClause returns be::BWithExpression : {be::BWithExpression}
		'with'
		( '(' referencedAdvice += [be::BAdvice | ID] (',' referencedAdvice += [be::BAdvice | ID])* ')' )? 
		(( 'properties' propertySets += PropertySet ) | ( 'concern' concerns += Concern_Anonymous ))*
		;
			
BuildResultReference returns build::BuildResultReference
	: UnitBuildResultReference
	| CapabilityBuildResultReference
	| IndirectCapabilityBuildResultReference
	| CompoundBuildResultReference
	;

// A reference to a builder in the same unit
UnitBuildResultReference returns build::BuildResultReference : {build::BuilderReference} 
	("unit")? '#' builderName=BuilderName ('(' parameters = ParameterList ')')? ; 

// A reference to a builder in a unit providing a capability (or if build name is omitted to the
// builder that provides the capability in that unit).
CapabilityBuildResultReference returns build::BuildResultReference : {build::BuilderReference}
	requiredCapability = RequiredCapability_Unfiltered ('#' builderName=BuilderName) ?
	('(' parameters = ParameterList ')')?	 
	;
	
// A reference to a builder in a unit providing a referenced capability (or if build name is omitted to the
// builder that provides the capability in that unit).
IndirectCapabilityBuildResultReference returns build::BuildResultReference : {build::BuilderReference}
	requiredCapabilityReference = [build::AliasedRequiredCapability | ID] ('#' builderName=BuilderName) ?
	('(' parameters = ParameterList ')')?	 
	;

CompoundBuildResultReference returns build::BuildResultReference : {build::CompoundBuildResultReference}
	'{' (prerequisites += Prerequisite)* '}'
	;
	
Builder returns build::Builder : {build::Builder}
	(documentation = DOCUMENTATION)? 
	(visibility = Visibility)?
    (executionMode = ExecutionMode)?
  	(final ?= "final")?
//	(cached ?= "cached")?
    "builder"
	name=BuilderName
	('(' 
		(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
			(',' varArgs?="..." parameters += ParameterDeclaration)?)
		| 	(    varArgs?="..." parameters += ParameterDeclaration)
	')')?
	("when" guard = GuardExpression)?
	('provides' providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)*  )?
	("precondition" ((':' precondExpr = Expression ';' )|( precondExpr = BlockExpression)))?
	("postcondition" ((':' postcondExpr = Expression ';' )|( postcondExpr = BlockExpression)))?
	 '{'
		('default' 'properties' defaultProperties = PropertySet)?
	     ( input = BuilderInput )? 
	     ( "output" '{' output = PathGroup '}' )? 
	     (funcExpr = BlockExpressionWithoutBrackets)?
	 '}'
	;

ParameterList returns be::BParameterList : {be::BParameterList} 
	parameters += FirstParameter ("," parameters += FirstParameter)*
	;
	
FirstParameter returns be::BParameter 
	: ClosureParameter
	| Parameter
	;
	
Parameter returns be::BParameter : {be::BParameter} 
	expr = Expression 
	;
	
ClosureParameter returns be::BParameter : {be::BParameter} 
	(expr = ClosureExpression) 
	;

ParameterDeclaration returns be::BParameterDeclaration : {be::BParameterDeclaration} 
	((type=TypeRef)? name = ID) 
	;

BuilderInput returns build::BuilderInput : {build::BuilderInput}
	"input"
		("precondition"  ((':' precondExpr  = Expression ';' )|( precondExpr  = BlockExpression)))?
		("postcondition" ((':' postcondExpr = Expression ';' )|( postcondExpr = BlockExpression)))?
		'{' (prerequisites += Prerequisite)+ '}'
	;

RepositoryConfiguration returns build::RepositoryConfiguration 
	: RepositoryDeclaration
	| ResolutionStrategy 
	;

RepositoryDeclaration returns build::RepositoryDeclaration : {build::RepositoryDeclaration}
	(documentation = DOCUMENTATION)?
	(location=URI | ('repository' resolverType=TypeRef) ) (contextBlock = ContextBlock_Creation)?
	;

ResolutionStrategy returns build::ResolutionStrategy 
	: ResolutionStrategyFirst
	| ResolutionStrategyBest
	;
	
ResolutionStrategyFirst returns build::ResolutionStrategyFirst : {build::ResolutionStrategyFirst}
	 "select-first" '{' (repositories += RepositoryConfiguration)* '}'
	;
	
ResolutionStrategyBest returns build::ResolutionStrategyBest : {build::ResolutionStrategyBest}
	"select-best" '{' (repositories += RepositoryConfiguration)* '}'
	;

ContainerConfiguration returns build::ContainerConfiguration: {build::ContainerConfiguration} 
	(documentation=DOCUMENTATION)? 
	"container" name=ID "agent" agentType=TypeRef (contextBlock = ContextBlock_Creation)? 
	;
	
URI returns build::URI : 
	STRING
	;

Concern_Named returns be::BConcern : {be::BConcern} 
	(documentation = DOCUMENTATION)? "concern" name=ID
	("extends" superConcerns += [be::BConcern | ID] (',' superConcerns += [be::BConcern | ID])*)? 
	'{' (
			("properties" propertySets += PropertySet) 
		| 	(functions+=Function)
		|	(contexts += BuildConcernContext)
		)* '}' 
	;


Concern_Anonymous returns be::BConcern : {be::BConcern}
	("extends" superConcerns+= [be::BConcern | ID] (',' superConcerns += [be::BConcern | ID])*)? 
	'{' (
			("properties" propertySets += PropertySet) 
		| 	(functions+=Function)
		|	(contexts += BuildConcernContext)		
		)* '}' 
	;

Function returns be::B3Function : {be::B3Function}
	(documentation = DOCUMENTATION)?
   	(visibility = Visibility)?
    (executionMode = ExecutionMode)?	   	
   	(final ?= "final")?
   	"function"
   	(returnType = TypeRef)?
   	name=ID 
//   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
   	('(' (
   		(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* (',' varArgs?="..." parameters += ParameterDeclaration)?)
   		| (varArgs ?= "..." parameters += ParameterDeclaration)
   		)? ')' )?
   	("when" guard = GuardExpression)?
   	((':' funcExpr=Expression ';') | (funcExpr=BlockExpression))
	;
	
GuardExpression returns be::BGuardExpression : {be::BGuardExpression}
	(':' guardExpr = Expression ';') | (guardExpr = BlockExpression)
	;
//TypeParamDeclaration 
//	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
//	;
		
/* EXPRESSIONS */
AssignmentOperator 
	: '=' | '+=' | '-=' | '*='	| '/=' | "%=" 
// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
//	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>=" 
	;
	
RelationalOperator 
	: "~=" | "==" | "===" | "!=" | "!=="
	| ">=" | "<=" | ">" | "<"
	;

// All expressions, including variable and value definitions. Note: order of rules is significant.
TopLevelExpression returns be::BExpression 
	: VarDeclaration 
	| ValDeclaration
	| AssignmentExpression 
	;

// All expressions except variable and value definitions	 
Expression returns be::BExpression
	: AssignmentExpression 
	;

AssignmentExpression returns be::BExpression :
	  CachedExpression ({be::BAssignmentExpression.leftExpr=current} 
	 	functionName=AssignmentOperator rightExpr=AssignmentExpression)?
	;	

VarDeclaration returns be::BExpression : {be::BDefValue} 
	(final ?= "final")? 
	(( "var" |  type=TypeRef ) name=ID) 
	('=' valueExpr = Expression)? 
	;

ValDeclaration returns be::BExpression : {be::BDefValue}
	(final ?= "final")? 
	immutable ?= "val" (type=TypeRef)? name=ID 
	'=' valueExpr = Expression
	;

// TODO: typereference is simplified to only the name of a java type - for model imports
// the model is imported with name == namespace, and types in the model are referenced after
// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
// referenced as mymodel::mytype
// There is more work required to link a reference to such a type and it is therefore deferred
// until we are up on Xtext 0.8 with better scoping and linking.
// For now, this is just proof of concept.
// 
		
TypeRef returns be::IType 
	: ClosureTypeRef 
	| SimpleTypeRef
	; 
	
SimpleTypeRef returns be::IType : {be::B3ParameterizedType} 
	rawType=[be::B3JavaImport | ID] 
		('<' actualArgumentsList+=[be::B3JavaImport | ID] (',' actualArgumentsList+=[be::B3JavaImport | ID])* '>' )?
//		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
	;
	

// ClosureTypeRef declares parameters and return type	
// TODO: use TypeRef instead of direct reference to imported class
ClosureTypeRef returns be::IType : {be::B3FunctionType} 
	('('(
		(parameterTypes += [be::B3JavaImport | ID] (',' parameterTypes += [be::B3JavaImport | ID])* 
			(',' varArgs ?= "..." parameterTypes += [be::B3JavaImport | ID])?)
		| 	(    varArgs ?= "..." parameterTypes += [be::B3JavaImport | ID])
		)? 
	')' '=>' returnType = [be::B3JavaImport | ID] )
	;

// TODO: TypeParam's and Wildcard refs currently unused. Support should be added
//	
TypeParam returns be::IType: TypeRefParam | WildcardRefParam ;
TypeRefParam returns be::IType: TypeRef ;
WildcardRefParam returns be::IType: 
	{be::B3WildcardType}'?' ( ("extends" upperBoundsList+=TypeRef (',' upperBoundsList+=TypeRef)*) | "super" lowerBoundsList+=TypeRef )?;

CachedExpression returns be::BExpression  : 
	({be::BCachedExpression} "cached" expr = OrExpression)
	| OrExpression
	;
	
OrExpression returns be::BExpression :
	AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*
	;
	
AndExpression returns be::BExpression :
	RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=RelationalExpression)*
	;

// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
// use the backend for some other language with a different grammar).
// BitwiseExpression returns be::BExpression :
// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
	
RelationalExpression returns be::BExpression :
	InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} 
		functionName=RelationalOperator rightExpr=InstanceOfExpression)*
	;

InstanceOfExpression returns be::BExpression :
	AdditiveExpression ({be::BBinaryOpExpression.leftExpr =current} functionName="instanceof" rightExpr=LiteralType)*
	;

// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
// use the backend for some other language with a different grammar).
// ShiftExpression returns be::BExpression:
// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
	
AdditiveExpression returns be::BExpression :
	MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("+" | "-") rightExpr=MultiplicativeExpression)*
	;

MultiplicativeExpression returns be::BExpression :
	SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("*" | "/" | "%") rightExpr=SetExpression)*
	;

SetExpression returns be::BExpression:
	UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=".." rightExpr=UnaryOrInfixExpression)*
	;

UnaryOrInfixExpression returns be::BExpression
	: PostopExpression 
	| UnaryExpression
	| PreopExpression
	; 
	
// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
// use the backend for some other language with a different grammar).
// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
// UnaryExpression returns be::BExpression:
//	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;

UnaryExpression returns be::BExpression : {be::BUnaryOpExpression} 
	functionName=("!" | "-") expr=InfixExpression
	;

PreopExpression returns be::BExpression : {be::BUnaryPreOpExpression}
	functionName=("++" | "--") expr=InfixExpression
	;

PostopExpression returns be::BExpression :
	InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName = ("--" | "++"))?
	;

InfixExpression returns be::BExpression :
	CallExpression ( 
	  	({be::BCallExpression.funcExpr=current} "." name=ID  "(" (parameterList = ParameterList)? ")")
	  |	({be::BAtExpression.objExpr=current} '[' indexExpr=Expression ']' )
	  | ({be::BFeatureExpression.objExpr=current} "." featureName=ID)
	)*;
	
CallExpression returns be::BExpression : 
	PrimaryExpression ({be::BCallExpression.funcExpr=current}"(" (parameterList = ParameterList)? ")")*
	;
		
PrimaryExpression returns be::BExpression
	: FeatureCall
	| ConstructorCallExpression
	| VariableValue
	| Literal 
	| PropertyValue
	| KeywordVariables
	| ParanthesizedExpression
	| IfExpression
	| BlockExpression
	| SwitchExpression
	| ThrowExpression
	| TryCatchExpression
	| WildcardExpression
//	| WithExpression
	;
	
//WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
//WithClauseExpression returns Expression : {WithClauseExpression} 
//	withclause=WithClause expr = BlockExpression 
//	;
//WithContextExpression returns Expresion : {WithContextExpression } 
//	"with" "context" context = Expression expr = BlockExpression
//	;
		
WildcardExpression returns be::BExpression : {be::BLiteralAny} 
	'_' 
	;

ThrowExpression returns be::BExpression : {be::BThrowExpression} 
	"throw"  expr=Expression 
	;
TryCatchExpression returns be::BExpression : {be::BTryExpression} 
	"try" tryExpr=Expression (catchBlocks+=CatchBlock)*
	("finally" finallyExpr=Expression)? "endtry" 
	;
		
CatchBlock	returns be::BCatch  : {be::BCatch} 
	"catch" exceptionType=TypeRef varname=ID ':' catchExpr=Expression 
	;
	
SwitchExpression returns be::BExpression : {be::BSwitchExpression}
	"switch" switchExpression=Expression? (caseList+=Case)+  "endswitch" 
	;
			
Case returns be::BCase : {be::BCase} 
	"case" conditionExpr=Expression ":" thenExpr=Expression
	;

BlockExpression returns be::BExpression: {be::BChainedExpression} 
	'{' (expressions += TopLevelExpression ';')* '}' 
	;

IfExpression returns be::BExpression : {be::BIfExpression} 
	"if" conditionExpr=Expression
	"then" thenExpr=Expression 
	((elseExpr = ElseIfExpression | "else" elseExpr = Expression ))?
	"endif"
	;

ElseIfExpression returns be::BExpression : {be::BIfExpression} 
	"elseif" conditionExpr=Expression 
	"then" thenExpr=Expression 
	((elseExpr = ElseIfExpression | "else" elseExpr = Expression ))?
	;
	
PropertyValue returns  be::BExpression : {be::BVariableExpression}
	name = PID
	;
	
VariableValue returns  be::BExpression : {be::BVariableExpression} 
	name = ID 
	;
	
KeywordVariables returns  be::BExpression : {be::BVariableExpression} 
	name = ("input" | "output" | "properties" | "unit")
	;

FeatureCall returns be::BExpression :
	OperationCall
	;
	
OperationCall returns be::BCallExpression : {be::BCallExpression}
	name=(ID|PID) 
	'(' (parameterList = ParameterList)? ')' 
	;

ConstructorCallExpression returns be::BExpression : {be::BCreateExpression} 
	"new" typeExpr=LiteralType 
	('(' (parameterList=ParameterList)? ')')?
	("as" alias=ID)? 
	(contextBlock = ContextBlock_Creation)?
	;

// Used in a concern to describe pointcuts/advice for units and/or builders
BuildConcernContext returns be::BConcernContext : 
	  UnitConcernContext
	| BuilderConcernContext
	;
	
// Advice for units consists of Builders, and advice for Builders
UnitConcernContext returns build::UnitConcernContext : {build::UnitConcernContext}
	"context" "unit" query = UnitOrExpression
	'{'
	( (functions += Builder)
	| (builderContexts += BuilderConcernContext)
	| ('+' 'requires' '{' (requiredCapabilities += AliasedRequiredCapability ';')+ '}')
	| ('+' 'requires' requiredCapabilities += AliasedRequiredCapability ';')
	| ('-' requiresRemovals += RequiresPredicate ';')
	| ('+' 'provides' '{' (providedCapabilities += ProvidedCapability ';')+ '}')
	| ('+' 'provides' providedCapabilities += ProvidedCapability ';')
	| ('-' providesRemovals += ProvidesPredicate ';')	
	)*
	'}'
	;
	
// Advice for Builders	
BuilderConcernContext returns build::BuilderConcernContext : {build::BuilderConcernContext}
	"context" "builder" query = BuilderOrExpression 
	'{' ( ('+' "input" inputAdditions += Prerequisite) 
		| ('-' inputRemovals += InputPredicate ';')
		)*
		( ('+' "output" outputAdditions += PathVector)
		| ('-' "output" outputRemovals += OutputPredicate ';'))*
		// TODO: annotations
		(funcExpr = BlockExpression)? // replaces the builder's funcExpression TODO: around? etc?
	'}'
	;

UnitOrExpression returns be::BExpression :
	UnitAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=UnitAndExpression)*
	;
	
UnitAndExpression returns be::BExpression :
	UnitNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=UnitNotOrPrimaryExpression)*
	;
	
UnitNotOrPrimaryExpression returns be::BExpression :
	UnitNotExpression | UnitPrimaryExpression 
	;
		
UnitNotExpression returns be::BExpression : {be::BUnaryOpExpression} 
	functionName=("!") expr=UnitPrimaryExpression
	;
UnitPrimaryExpression returns be::BExpression :
	  RequiresPredicate
	| ImplementsPredcicate
	| ProvidesPredicate
	| UnitNamePredicate
	| GroupedUnitPrimaryExpression
	;
GroupedUnitPrimaryExpression returns be::BExpression : '(' UnitOrExpression ')' ;

	
RequiresPredicate returns build::RequiresPredicate : {build::RequiresPredicate}
	(meta ?= "env")? "requires" capabilityPredicate = CapabilityPredicate 
	;
	
ImplementsPredcicate returns be::BExpression: {build::ImplementsPredicate}
	"implements" type = TypeRef 
	;
	
ProvidesPredicate returns build::ProvidesPredicate : {build::ProvidesPredicate}
	"provides" capabilityPredicate = CapabilityPredicate 
	;
	
UnitNamePredicate returns build::CapabilityPredicate : {build::UnitNamePredicate}
	namePredicate = NamePredicate
	('/' versionRange = VersionRangeLiteral)?
	;
	
BuilderNamePredicate returns build::BuilderNamePredicate : {build::BuilderNamePredicate}
	namePredicate = NamePredicate
	;
	
InputPredicate returns build::InputPredicate: {build::InputPredicate}
	"input"
	( (capabilityPredicate = CapabilityPredicate)
	| (capabilityPredicate = UnitNamePredicate)
	| ("unit")?
	)
	'#' builderPredicate = NamePredicate
	;
	
OutputPredicate returns build::OutputPredicate : {build::OutputPredicate}
	  pathVector = BasePathPredicate
	| pathVector = PathPredicate
	| pathPattern = RegexpLiteral
	;
	
BasePathPredicate returns build::PathVectorElement : {build::PathVectorElement}
	basePath = Path '[' paths += Path (',' paths += Path)* ']'
	;
PathPredicate returns build::PathVectorElement : {build::PathVectorElement}
	paths += Path (',' paths += Path)*
	;

CapabilityPredicate returns build::CapabilityPredicate : {build::CapabilityPredicate} 
	nameSpacePredicate = NamePredicate
	'/' namePredicate = NamePredicate
	('/' versionRange=VersionRangeLiteral)? 
	;
	 
NamePredicate returns build::NamePredicate : {build::NamePredicate}
	(name=EscapedQualifiedName  | namePattern = RegexpLiteral | namePattern = WildcardExpression)
	;
	
BuilderOrExpression returns be::BExpression :
	BuilderAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=BuilderAndExpression)*
	;
	
BuilderAndExpression returns be::BExpression :
	BuilderNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=BuilderNotOrPrimaryExpression)*
	;
	
BuilderNotOrPrimaryExpression returns be::BExpression :
	BuilderNotExpression | BuilderPrimaryExpression 
	;
		
BuilderNotExpression returns be::BExpression : {be::BUnaryOpExpression} 
	functionName=("!") expr=BuilderPrimaryExpression
	;
	
BuilderPrimaryExpression returns be::BExpression :
	  InputPredicate
	| ProvidesPredicate
	| BuilderNamePredicate
	| GroupedBuilderPrimaryExpression
	;
	
GroupedBuilderPrimaryExpression returns be::BExpression : '(' BuilderOrExpression ')' ;


ContextBlock returns be::BExpression : {be::BChainedExpression} 
	'{'  ((expressions +=Function) 
//		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		| (expressions+=TopLevelExpression ';')
//		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		)* '}' 
		;

ContextBlock_Creation returns be::BExpression : {be::BChainedExpression} 
	'{' (expressions+=TopLevelExpression ';')* '}' 
	;
					
//ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
//PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = PropertySet_Named ;
//FunctionDefinition returns be::BExpression : {be::BDefFunction} function = Function;
//BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;

Literal returns be::BExpression
	: ValueLiteral
	| RegexpLiteral
	| LiteralMap
	| LiteralList
	| LiteralFunction
	;
	
LiteralList returns  be::BExpression
	: {be::BLiteralListExpression} '[' ('<' entryType=TypeRef '>')? entries += Expression (',' entries += Expression)*  ']' 
	| {be::BLiteralListExpression} '[''<' entryType=TypeRef '>' ']' 
	;
	
LiteralMap returns  be::BExpression
	: {be::BLiteralMapExpression} '['  ('<' keyType=TypeRef ',' valueType=TypeRef '>')? entries += MapEntry (',' entries += MapEntry)* ']' 
	| {be::BLiteralMapExpression} '[' '<' keyType=TypeRef ',' valueType=TypeRef '>' ']' 
	;

// A lambda enclosed in { }
LiteralFunction returns be::BExpression :
	'{' ClosureExpression '}'
	;

//LiteralFunction returns be::BExpression : {be::B3Function} 
//	'{' ('<' returnType=TypeRef '>')?
//	(
//	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
//		(',' varArgs?="..." parameters += ParameterDeclaration)?)
//	| 	(    varArgs?="..." parameters += ParameterDeclaration)
//	)? 
//	'|' funcExpr=OneOrManyExpressions '}'
//	;

// A lambda (without delimiters)
ClosureExpression returns be::BExpression: {be::B3Function} 
	('<' returnType=TypeRef '>')?
	(
	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
		(',' varArgs?="..." parameters += ParameterDeclaration)?)
	| 	(    varArgs?="..." parameters += ParameterDeclaration)
	)? 
	'|' funcExpr=OneOrManyExpressions
	;

OneOrManyExpressions returns be::BExpression
	: BlockExpressionWithoutBrackets
	| Expression
	;
	
BlockExpressionWithoutBrackets returns be::BExpression : {be::BChainedExpression} 
	(expressions += TopLevelExpression ';')+ 
	;
	
MapEntry returns be::BMapEntry: {be::BMapEntry} 
	key = KeyLiteral ':' value= Expression 
	;

KeyLiteral returns be::BExpression : {be::BLiteralExpression} 
	value = (ID|PID|STRING) 
	;

LiteralType returns be::BExpression : {be::BLiteralType} 
	type=TypeRef 
	;

ValueLiteral returns be::BExpression 
	: BooleanLiteral 
	| RealLiteral  // SEE ISSUE 297089 - must be placed before IntegerLiteral
	| IntegerLiteral 
	| NullLiteral 
	| StringLiteral
//	| QueryLiteral
	| UnitLiteral
	;
	
BooleanLiteral returns  be::BExpression : {be::BLiteralExpression} 
	value = BooleanValue
	;
	
IntegerLiteral returns  be::BExpression : {be::BLiteralExpression} 
	value= IntValue
	;
	
UnitLiteral returns  be::BExpression : {be::BLiteralExpression} 
	value="unit"
	;
	
StringLiteral returns  be::BExpression : {be::BLiteralExpression} 
	value = STRING
	;
	
RealLiteral	returns  be::BExpression : {be::BLiteralExpression}
	value = RealValue
	;
	
RegexpLiteral returns be::BExpression : {be::BRegularExpression}
	pattern = REGULAR_EXPR
	;

// Note: NullLiteral has a java null value as its value
NullLiteral	returns  be::BExpression : {be::BLiteralExpression} 
	"null"
	;

//ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
//SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";

// Has conversion rule
BooleanValue returns ecore::EBooleanObject : ("true" | "false" );

// Has conversion rule
RealValue returns ecore::EDoubleObject: REAL ;

// Has conversion rule that handles decimal, octal, and hexadecimal values with radix
IntValue returns ecore::EIntegerObject : INT | HEX ;
	
ParanthesizedExpression returns be::BExpression : 
	'(' Expression ')'
	;	

// Has conversion rule
VersionLiteral returns build::Version
	: STRING  
	| AlfanumSym
	;

// Has conversion rule
VersionRangeLiteral returns build::VersionRange
	: ('[' | '(') (STRING | AlfanumSym) (',' (STRING | AlfanumSym))? (']'|')')
	| (STRING | AlfanumSym)
	;

// Reference to qualified named item, possibly in unit, this or super, or
// this.super, or unit.super
// TODO: super, unit, this - not yet handled - subject to change?
QIDREF : (("super" |(("unit" | "this") ('.' "super")?)) ('.' QID)?) | QID ;

// Qualified name
QID hidden(): ID (INT|HEX|ID)* ('.' ID (INT|HEX|ID)*)* ; 

// Allows a qualified name, or a string to be used as a name
EscapedQualifiedName:  STRING | QID;
InterfaceName	: QID ;

// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
UnitName 		: EscapedQualifiedName ;
BuilderName 	: EscapedQualifiedName ;
CapabilityName 	: EscapedQualifiedName ;

enum Visibility 	returns be::Visibility : public | private ;
enum ExecutionMode 	returns be::ExecutionMode: parallel | sequential ;


// Version, and VersionRange
// TODO: uncertain if the set of allowed chars is definitive.
//
Separator : '.' | '-' | '!' | '@' | '$' | '%' | '&' |'+' | '=' | '*' | '<' | '>' | ':' | '?';
AlfanumSym : (ID | INT | HEX | EXT_INT) (Separator|ID|INT|HEX |EXT_INT)* ;

// --TERMINALS
// (NOTE: Does not use standard terminals to have full control).

// TODO: Possibly use some other char instead of ^ as escape mechanism for keywords??
terminal ID : ('^')?(('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|('0'..'9')|'_')* ;

// Property Names start with $ and are qualified. Must be handled by lexer as
// a.b.c is otherwise ambigous in expressions.
terminal PID : '$' ID ('.' ID)* ;

// Java regexp - allows \ before any character == same as unescaped character if character is not an operator
terminal REGULAR_EXPR returns be::RegexpPattern
	: "~/" ( '\\' (!('\t'|'\r'|'\n'))
			| (!('\\'|'/'|' '|'\t'|'\r'|'\n')))* "/" ('u'|'m'|'i'|'c'|'d')*
			;

// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
// A string converter may need to handle the u, x, and octal escapes.
// Regular java string handles XXXX , and gives syntax error if
// format is not ok, the other two remains, and possibly the null.
// TODO: check STRING grammar
terminal STRING :
'"' ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|'"'|'\r'|'\n') )* '"' |
"'" ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|"'"|'\r'|'\n') )* "'";

terminal DOCUMENTATION : '/**' -> '*/' ;
terminal ML_COMMENT : '/*' (!'*') -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS : (' '|'\t'|'\r'|'\n')+ ;
terminal HEX : '0' ('x'|'X')(('0'..'9')|('a'..'f')|('A'..'F'))+ ;
terminal INT : ('0'..'9')+;
REAL hidden(): INT ? '.' (EXT_INT | INT);
terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
 
terminal ANY_OTHER : . ;

