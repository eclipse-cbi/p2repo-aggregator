
grammar org.eclipse.b3.BeeLang // with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.eclipse.b3.backend/model/B3Backend.ecore" as be
//import "platform:/resource/org.eclipse.b3.beelang/src/org/eclipse/b3/BeeLangTypes.ecore" as types
generate beeLang "http://www.eclipse.org/b3/BeeLang"

BeeModel hidden(WS, SL_COMMENT, ML_COMMENT): 
	(imports += Import)* 
	((functions+=Function) | (concern+=Concern))* 
	(body = Unit)? ;

Import returns be::B3JavaImport: {be::B3JavaImport}(reexport ?='reexport')? "import" qualifiedName = QID ("as" name=ID)? ';' ;

// Wanted later 
//Import : (reexport ?='reexport')? 
//		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
//	; 

//JavaImporter 	: qualifiedName=QID ;
//NativeImporter 	: uriString = STRING ;
		
Unit returns BuildUnit hidden(WS, ML_COMMENT, SL_COMMENT) : {BuildUnit}
	(documentation = DOCUMENTATION)?
	(executionMode = ExecutionMode)?
	'unit' (name=UnitName)? ('version' version = Version)?
		('implements' implements += InterfaceName (',' implements+=InterfaceName)*)? 
	'{'
		(	//-- PROPERTIES
			// goes first, because they may be used in the other clauses.
			//
			  ('default' 'properties'  defaultProperties = PropertySet)
		)?
		( 	//-- PROVIDES
			  ('provides' '{' (providedCapabilities += ProvidedCapability ';')+ '}')
			| ('provides' providedCapabilities += ProvidedCapability ';')
			//-- REQUIRES & META REQUIRES
			| ('requires' '{' (requiredCapabilities += RequiredCapability ';')+ '}')
			| ('requires' requiredCapabilities += RequiredCapability ';')
			| ('env' 'requires' '{' (metaRequiredCapabilities += RequiredCapability ';')+ '}' )
			| ('env' 'requires' metaRequiredCapabilities += RequiredCapability ';')
			//--CONCERNS
			| (concerns+=Concern )
			//--SYNCHRONIZE
			| ('sequential' '{' (synchronizations += Synchronization )+  '}' )
			| ('sequential' synchronizations += Synchronization  )
			//--BUILD METHODS & FUNCTIONS
			| (builders += Builder )			
			| (functions += Function )			
			//-- REPOSITORIES
			| ('repositories' '{' (repositoryConfigurations+=RepositoryConfiguration)* '}' )
			| ('properties'  propertySets += NamedPropertySet)
			| ('containers' '{' containers += ContainerConfiguration* '}' )
		)*
	'}';
	

	
ProvidedCapability : capability=FilteredCapability  ('/' version=Version)?  ;
RequiredCapability : capability=FilteredCapability ('/' range=VersionRange)?  ;
FilteredCapability : ('when' filter=Filter)? capability = Capability ;
Capability : interface=InterfaceName '/' name=UnitName ;

// An optionally named sequence of property statements
NamedPropertySet returns NamedPropertySet
	: name = ID body = PropertySet 
	;

// Sequence of possibly filtered property statements	
PropertySet returns PropertySet
	:  {PropertySet} ("extends" extends=QIDREF)? '{' (operations += PropertyOperation)* '}'
//	:  ("extends" extends=[NamedPropertySet | QIDREF])? '{' (operations += PropertyOperation)* '}'
	;

// For model generation, to get supertype correct
PropertyOperation 
	: FilteredPropertyOperation 
	| SetPropertyOperation 
	| UnsetPropertyOperation 
	| PropertySet
	;

FilteredPropertyOperation returns FilteredPropertyOperation
	: 'when' filter=Filter
		body=(SetPropertyOperation | UnsetPropertyOperation | PropertySet) 
	;

SetPropertyOperation returns SetPropertyOperation
	: ( (final ?= 'final')? key=PropertyName op=AssignmentOperator value=Expression ';')
	;

UnsetPropertyOperation returns UnsetPropertyOperation
	: ('unset' key = PropertyName ';' )
	;

Synchronization 
	: (partrefs += SynchronizedPart)(',' partrefs += SynchronizedPart)+ ';' // TODO: verify at least 2 partrefs
	;
	
SynchronizedPart
	: CompoundName ('#' PartName)?
	| PartName
	;
	
PathGroup : paths+=PathVectorElement+ ('annotations' annotations = PropertySet)? ;

PathVectorElement returns PathVectorElement
	: FilteredPathVector
	| BasePathVector
	| UnbasedPathVector
	;
	
FilteredPathVector returns FilteredPathVector 
	: 'when' filter=Filter body=(BasePathVector|UnbasedPathVector|CompoundPathVector) 
	;

BasePathVector returns PathVector
	: basePath=Path '[' ( paths+=Path (',' paths+=Path)*)? ']' ';'
	;

UnbasedPathVector returns PathVector
	: paths+=Path (',' paths+=Path)* ';'
	;
	
CompoundPathVector returns CompoundPathVector: {CompoundPathVector} '{' body+=PathVectorElement* '}' ;

// A path can be written without quotes if it consists of safe chars 
Path hidden()
	: STRING
	| ('/')? QID ('/' QID)* ('/')?  HIDDENBUG
	;

Prerequisite : 
		('when' filter=Filter )?
		(withClause = WithClause)?
		partReference=PrerequisiteEntry 
		("as" alias=ID)? ';'
	;

// Validation checks that there is at least one of references, properties or concern.
WithClause : {WithClause}
		'with'
		( '(' references += Expression (',' references += Expression)* ')' )? 
		(( 'properties' properties += PropertySet ) 
		| ( 'concern' concern += ConcernBlock ))*
		;
			
PrerequisiteEntry 
	: DirectPartReferemce
	| CapabilityReferencedPart
	| CompoundReferences
	;
	
DirectPartReferemce	: ((unit=QID)|(unit="unit"))? '#' builder=PartName  (parameters = ParameterList)?; 
	
CapabilityReferencedPart : 
	capability=Capability ('/' range=VersionRange)? ('#' partName=PartName) ?
	(parameters = ParameterList)?	 
	;
	
CompoundReferences
	: {CompounddReferences} '{' (prerequisites += Prerequisite)* '}'
	;
	
Builder returns Builder : {Builder}
	(documentation = DOCUMENTATION)? 
	(visibility = Visibility)?
    (executionMode = ExecutionMode)?
  	(final ?= "final")?
	(cached ?= "cached")?
    "builder"
	name=PartName
	('(' params = ParameterDeclarationList ')')?
	('provides' providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)*  )?
	(preCondition = PreCondition)?
	(postCondition = PostCondition)?
	 '{'
		('default' 'properties' properties = PropertySet)?
	     ( input = BuilderInput )? 
	     ( output = BuilderOutput )?
	     (expressionList = ExpressionList)?
	 '}'
	;

Parameter returns be::BParameter: {be::BParameter} expr = Expression ;
ParameterList returns be::BParameterList: {be::BParameterList} (parameters+=Parameter ("," parameters+=Parameter)*) 
	  | (parameters+=ClosureParameter)  ;

ClosureParameter returns be::BParameter : {be::BParameter} expr = ClosureExpression;

ParameterDeclarationList : 
	( params += ParameterDeclaration (',' params+=ParameterDeclaration)*(',' params+=ParameterDeclarationEllipse)?) 
	| (params+= ParameterDeclarationEllipse)
	;
ParameterDeclaration returns be::BParameterDeclaration: {be::BParameterDeclaration} type=TypeRef? name = ID ;
ParameterDeclarationEllipse returns ParameterDeclaration : 
	{VarargParameterDeclaration} "..." (type=TypeRef)? name=ID
	;
 
InputKeyword : 'input' ; 
OutputKeyword : 'output'; 
	
BuilderOutput returns BuilderOutput
	: OutputKeyword '{' body = PathGroup '}' 
	;
	

BuilderInput
	: InputKeyword (preCondition = PreCondition)? (postCondition = PostCondition)?	 
		'{' (prerequisites += Prerequisite)+ '}'
	;

RepositoryConfiguration : RepositoryDeclaration | ResolutionStrategy ;

RepositoryDeclaration : 
	(documentation = DOCUMENTATION)?
	(location=URI | 'repository' type=TypeRef ) (context=ContextBlock)?
	;

ResolutionStrategy : 
	strategy = ("select-first" | "select-best") 
	'{' (repositoryConfig += RepositoryConfiguration)* '}'
	;

ContainerConfiguration : 
	(documentation=DOCUMENTATION)? 
	"container" name=ID "agent" type=TypeRef (contextBlock = ContextBlock)? 
	;
	
URI /* returns types::URI */: STRING
	;

Concern : (documentation = DOCUMENTATION)? "concern" name=ID concern = ConcernBlock ;

ConcernBlock : {ConcernBlock}
	("extends" superConcerns+= ID (',' superConcerns += ID)*)? 
	'{' ((contexts+=Context) | (functions+=Function))* '}' 
	;

Query : "query" ('{' selector=QueryPath '}') ;	
QueryPath : (absolute?=':')? selectors+=Selector (':' selectors+=Selector)* ;
Selector returns Selector
	: (name=QID | op=SelectorOperator | pattern=REGULAR_EXPR) ('[' predicate=Expression ']')? 
	;
enum SelectorOperator : THIS = '.' | PARENT = '..' | CHILDREN = '*' | ANSCESTORS = '**' ;

Filter : '(' predicate = Expression ')' ;

PreCondition : "precondition" '{' (asserts += AssertionExpression)+ '}' ;
PostCondition : "postcondition" '{' (asserts += AssertionExpression)+ '}' ;
AssertionExpression : 'assert' expr=Expression ',' message=STRING ';' ;

ExpressionList : (expressions += Expression ';')+ ;

// Validation makes sure a Function is stated with "function", and Method with "method"
//Function returns Function: {Function} func=FunctionOrMethod ;
//Method returns Method: {Method} method=FunctionOrMethod ;

// "method" variant will probbly be removed
Function returns be::B3Function: {be::B3Function}
	(documentation = DOCUMENTATION)?
   	(visibility = Visibility)?
    (executionMode = ExecutionMode)?	   	
   	(final ?= "final")?
   	(cached ?= "cached")?
   	"function"
//   	form=("function"|"method")
   	(returnType = TypeRef)?
   	name=ID 
//   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
   	('(' (parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)*)? ')' )?
   	((':' funcExpr=Expression ';') | (funcExpr=BlockExpression))
	;
	
//TypeParamDeclaration 
//	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
//	;
		
/* EXPRESSIONS */
AssignmentOperator 
	: '=' 		| '+='	| '-=' | '*='	| '/='
	| "%=" 	| "&=" 	| "^=" | "|=" 
	| "<<=" | ">>=" | ">>>=" 
	;
	
RelationalOperator 
	: "~=" | "==" | "===" | "!=" | "!=="
	| ">=" | "<=" | ">" | "<"
	| "instanceof" 
	;

Expression returns be::BExpression: AssignmentExpression ;

// ReturnExpression returns Expression : {ReturnExpression} "return" expr = AssignmentExpression ; 

AssignmentExpression returns be::BExpression:
	 (OrExpression | VarDeclaration) ({be::BAssignmentExpression.leftExpr=current} 
	 	functionName=AssignmentOperator rightExpr=AssignmentExpression)?
	;

VarDeclaration returns be::BExpression: {be::BDefValue} ('var' | type=TypeRef) name=ID ;
TypeRef returns be::IType: SimpleTypeRef | ClosureTypeRef;
SimpleTypeRef returns be::IType
	: {be::B3ParameterizedType} rawType=Import 
		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? 
	;
	
// TODO: typereference is simplified to only the name of a java type - for model imports
// the model is imported with name == namespace, and types in the model are referenced after
// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
// referenced as mymodel::mytype
// There is more work required to link a reference to such a type and it is therefore deferred
// until we are up on Xtext 0.8 with better scoping and linking.
// For now, this is just proof of concept.
// 

// ClosureTypeRef declares parameters and return type	
ClosureTypeRef returns be::IType
	: {be::B3FunctionType}( '(' parameterTypes+=TypeRef (',' parameterTypes+=TypeRef)* ')')? 
		'=>' returnType = TypeRef
	;
	
TypeParam returns be::IType: TypeRefParam | WildcardRefParam ;
TypeRefParam returns be::IType: TypeRef ;
WildcardRefParam returns be::IType: 
	{be::B3WildcardType}'?' ( ("extends" upperBoundsList+=TypeRef (',' upperBoundsList+=TypeRef)*) | "super" lowerBoundsList+=TypeRef )?;
	 
OrExpression returns be::BExpression:
	AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*;
	
AndExpression returns be::BExpression:
	BitwiseExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=BitwiseExpression)*;

BitwiseExpression returns be::BExpression :
	RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
	
RelationalExpression returns be::BExpression:
	ShiftExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=RelationalOperator rightExpr=ShiftExpression)*;

ShiftExpression returns be::BExpression:
	AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
	
AdditiveExpression returns be::BExpression:
	MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("+" | "-") rightExpr=MultiplicativeExpression)*;

MultiplicativeExpression returns be::BExpression:
	SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("*" | "/" | "%") rightExpr=SetExpression)*;

SetExpression returns be::BExpression:
	UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=".." rightExpr=UnaryOrInfixExpression)*;

UnaryOrInfixExpression returns be::BExpression
	: UnaryExpression 
	| PostopExpression
	| PreopExpression
	; 

UnaryExpression returns be::BExpression:
	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=PostopExpression;

PreopExpression returns be::BExpression:
	 {be::BUnaryPreOpExpression} functionName=("++" | "--") expr=PostopExpression;

PostopExpression returns be::BExpression:
	InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName = ("--" | "++"))?
	;

	
InfixExpression returns be::BExpression:
	CallExpression ( 
	  	({be::BCallExpression.funcExpr=current} "." name=ID  "(" parameterList = ParameterList? ")")
	  |	({be::BAtExpression.objExpr=current} '[' indexExpr=Expression ']'
//	  		("(" parameterList = ParameterList ")")? // TODO: this looks really odd - a chain of [] followed by call s probbly broken
	  		) 	  
	  | ({be::BFeatureExpression.objExpr=current} "." featureName=ID)
	)*;
	
CallExpression returns be::BExpression: 
	PrimaryExpression ({be::BCallExpression.funcExpr=current}"(" (parameterList = ParameterList)? ")")*
		;
PrimaryExpression returns be::BExpression
	: VariableValue
	| Literal 
	| FeatureCall 
	| ConstructorCallExpression
	| PropertyValue
	| KeywordVariables
	| ParanthesizedExpression
	| IfExpression
	| BlockExpression
	| SwitchExpression
	| ThrowExpression
	| TryCatchExpression
	| WildcardExpression
//	| WithExpression
	;
	
//WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
//WithClauseExpression returns Expression : {WithClauseExpression} 
//	withclause=WithClause expr = BlockExpression 
//	;
//WithContextExpression returns Expresion : {WithContextExpression } 
//	"with" "context" context = Expression expr = BlockExpression
//	;
		
WildcardExpression returns be::BExpression: {be::BLiteralAny} '_' ;

ThrowExpression returns be::BExpression: {be::BThrowExpression} "throw"  expr=Expression ';' ;
TryCatchExpression returns be::BExpression : {be::BTryExpression} 
	"try" tryExpr=Expression (catchBlocks+=CatchBlock)*
	("finally" finallyExpr=Expression)? "endtry" 
	;
		
CatchBlock	returns be::BCatch 
	: {be::BCatch} "catch" exceptionType=TypeRef varname=ID ':' catchExpr=Expression ;
	
// FinallyBlock	: "finally" Expression ;
SwitchExpression returns be::BExpression
	: {be::BSwitchExpression} "switch" switchExpression=Expression? (caseList+=Case)+  "endswitch" ;
			
Case	returns be::BCase : {be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression;

BlockExpression returns be::BExpression: {be::BChainedExpression} '{' (expressions += Expression ';')* '}' ;

IfExpression returns be::BExpression
	: {be::BIfExpression} 'if'  conditionExpr=Expression "then" thenExpr=Expression 
	((elseExpr = ElseIfExpression | "else" elseExpr = Expression ))?
	"endif"
	;

// for typing	
// IfExpressionTail : ElseIfExpression | ElseExpression ;	
ElseIfExpression returns be::BExpression 
	: {be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression 
		((elseExpr = ElseIfExpression | "else" elseExpr = Expression ))?
	;
	
//ElseExpression returns be::BExpression 
//	:  "else" Expression ;

PropertyValue returns  be::BExpression: {be::BVariableExpression} name = PID;
VariableValue returns  be::BExpression: {be::BVariableExpression} name = ID ;
KeywordVariables returns  be::BExpression: {be::BVariableExpression} 
	name = (InputKeyword | OutputKeyword | "properties" | "unit") ;

FeatureCall returns be::BExpression:
	OperationCall
	;
	
OperationCall returns be::BCallExpression
	: {be::BCallExpression} name=(ID|PID) '(' (parameterList = ParameterList)? ')' 
//	| target= SuperLiteral '.' name=ID '(' (parameters = ParameterList)? ')'
	;

ConstructorCallExpression returns be::BExpression
	: {be::BCreateExpression} "new" type=TypeRef ('(' (parameterList=ParameterList)? ')')?
		("as" alias=ID)? (contextBlock = ContextBlock)?
	;

Context : "context" selector = ContextSelector block = ContextBlock ;
ContextSelector : TypeRefSelector | ExpressionSelector | UnitSelector ;
TypeRefSelector returns ContextSelector: type = TypeRef ;
ExpressionSelector : expr = Expression ;
UnitSelector : 
	"unit" interface=QID 
	('/' (name=UnitName | namePattern = REGULAR_EXPR) ('/' versionRange=VersionRange)? )? 
	;

ContextBlock returns be::BExpression : {be::BChainedExpression} 
	'{'  ((expressions +=FunctionDefinition) 
//		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		| (expressions+=Expression)
//		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		)* '}' ;
					
//ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
//PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = NamedPropertySet ;
FunctionDefinition returns be::BExpression : {be::BDefFunction} function = Function;
//BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;

Literal returns be::BExpression
	: ValueLiteral
//	| RegexpLiteral
	| LiteralList
	| LiteralMap
//	| LiteralFunction
	;
	
LiteralList returns  be::BExpression
	: {be::BLiteralListExpression} '[' entries += Expression (',' entries += Expression)*  ']' ('<' entryType=TypeRef '>')?
	| {be::BLiteralListExpression} '[' ']' '<' entryType=TypeRef '>'
	;
LiteralMap returns  be::BExpression
	: {be::BLiteralMapExpression} '[' entries += MapEntry (',' entries += MapEntry)* ']' ('<' keyType=TypeRef ',' valueType=TypeRef '>')? 
	| {be::BLiteralMapExpression} '[' ']' '<' keyType=TypeRef ',' valueType=TypeRef '>'
	;
// TODO: only needs the ClosureExpression == B3Function 
//LiteralFunction returns be::BExpression: {LiteralFunction} '{' closure = ClosureExpression '}' ;

ClosureExpression returns be::BExpression: {be::B3Function} 
	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)*)? '|' funcExpr=Expression 
	;
	
MapEntry returns be::BMapEntry: {be::BMapEntry} key = KeyLiteral ':' value= Expression ;

KeyLiteral returns be::BExpression : {be::BLiteralExpression} value = (ID|PID|STRING) ;

ValueLiteral returns be::BExpression 
	: BooleanLiteral 
	| IntegerLiteral 
//	| NullLiteral // TODO: 
	| StringLiteral
	| RealLiteral
//	| QueryLiteral
//	| ThisLiteral // TODO: remove?
//	| SuperLiteral // TODO: remove ?
	| UnitLiteral
	;
	
BooleanLiteral returns  be::BExpression: {be::BLiteralExpression} value = BooleanValue;
IntegerLiteral returns  be::BExpression: {be::BLiteralExpression} value= IntValue;
UnitLiteral returns  be::BExpression: {be::BLiteralExpression} value="unit";
StringLiteral returns  be::BExpression: {be::BLiteralExpression} value = STRING;
RealLiteral	returns  be::BExpression: {be::BLiteralExpression} value = RealValue;
RegexpLiteral returns be::BExpression: {be::BRegularExpression} patternString = REGULAR_EXPR;
//QueryLiteral returns be::BExpression: {be::BLiteralExpression} value=Query ;

NullLiteral	returns  be::BExpression: {be::BLiteralExpression} "null"; // TODO: check that type is Object
//ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
//SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";

BooleanValue returns ecore::EBooleanObject : ("true" | "false" );
RealValue returns ecore::EDouble: REAL ;
// handles dec, oct, and hex values with radix
IntValue /*returns types::RadixInteger */: INT | HEX ;
	
ParanthesizedExpression returns be::BExpression
	:  "(" Expression ")"
	;	

//--
Version : version = VersionLiteral;

VersionLiteral /* returns types::Version */
	: STRING  
	| AlfanumSym
	;

VersionRange : range = VersionRangeLiteral ;

VersionRangeLiteral /* returns types::VersionRange  */
	: ('[' | '(') (STRING | AlfanumSym) (',' (STRING | AlfanumSym))? (']'|')')
	| (STRING | AlfanumSym)
	;

// Reference to qualified named item, possibly in unit, this or super, or
// this.super, or unit.super
QIDREF : (("super" |(("unit" | "this") ('.' "super")?)) ('.' QID)?) | QID ;

// Qualified name
// TODO: Needs to disallow white space between ID and '.', and no embedded comments. 
// A bug in xtext prevents using hidden() here without the using the magic HIDDENBUG.
//
QID hidden(): ID (INT|HEX|ID)* ('.' ID (INT|HEX|ID)*)* HIDDENBUG;
HIDDENBUG hidden(WS, SL_COMMENT, ML_COMMENT): ('~~~~~')? ; // TODO: REPLACE HACK WHEN HIDDEN WORKS.

PropertyName : PID ;
EscapedQualifiedName:  STRING | QID;
InterfaceName: QID ;

// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
// do not allow being broken across lines.
//
CompoundName : EscapedQualifiedName '/' EscapedQualifiedName ;

// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
UnitName : EscapedQualifiedName;
PartName : EscapedQualifiedName;

enum Visibility 	returns be::Visibility : public | private ;
enum ExecutionMode 	returns be::ExecutionMode: parallel | sequential ;


// Version, and VersionRange
// TODO: uncertain if the set of allowed chars is definitive.
//
Separator : '.' | '-' | '!' | '@' | '$' | '%' | '&' |'+' | '=' | '*' | '<' | '>' | ':' | '?';
AlfanumSym : (ID | INT | HEX | EXT_INT) (Separator|ID|INT|HEX |EXT_INT)* ;

// --TERMINALS

// Redeclare the default ID with some other char instead of ^ as escape mechanism ??
terminal ID : ('^')?(('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|('0'..'9')|'_')* ;

// Property Names start with $ and are qualified. Must be handled by lexer as
// a.b.c is otherwise ambigous in expressions.
terminal PID : '$' ID ('.' ID)* ;

// Initially specified for JS Regexp
// Java regexp: TODO:
// - allows \ before any character == same as unescaped character if character is not an operator
// - flags are different (already specified)
terminal REGULAR_EXPR
	: "~/" ( '\\' ('/'|'f'|'n'|'r'|'t'|'v'|'\\'|'.'|'*'|'+'|'?'
					| 'w'|'W'|'s'|'S'|'d'|'D'|'b'
					|'|'|'{'|'}'|'['|']'|'('|')'
					| (('0'..'7')('0'..'7')('0'..'7')) 
					| ('x' (('0'..'9')|('a'..'f')|('A'..'F')) (('0'..'9')|('a'..'f')|('A'..'F'))) 
					| ('c' ('A'..'Z'))
				)
			| (!('\\'|'/'|' '|'\t'|'\r'|'\n')))* "/" ('u'|'m'|'i'|'c'|'d')? // TODO: * at end
			;

// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
// A string converter may need to handle the u, x, and octal escapes.
// Regular java string handles XXXX , and gives syntax error if
// format is not ok, the other two remains, and possibly the null.
terminal STRING :
'"' ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|'"'|'\r'|'\n') )* '"' |
"'" ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|"'"|'\r'|'\n') )* "'";

terminal DOCUMENTATION : '/**' -> '*/' ;
terminal ML_COMMENT : '/*' (!'*') -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS : (' '|'\t'|'\r'|'\n')+ ;

// Uses special type to retain hex formatting.
terminal HEX : '0' ('x'|'X')(('0'..'9')|('a'..'f')|('A'..'F'))+ ;

//terminal REAL : ( ((('0'..'9') '.' ('0'..'9')) |('.' ('0'..'9'))) (('e'|'E')('-'|'+')INT)?) | (INT ('e'|'E')('-'|'+')INT) ;

//terminal REAL : (INT? '.' INT) (('e'|'E')('-'|'+')INT)? ;
terminal INT : ('0'..'9')+;
REAL hidden(): INT ? '.' (EXT_INT | INT) HIDDENBUG;
terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
 
//terminal REAL : ((INT '.' INT)|(INT '.')|('.' INT) | INT) (('e'|'E')('-'|'+')INT)? ;

terminal ANY_OTHER : . ;

