/*
 * Copyright (c) 2009-2010, Cloudsmith Inc and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * Contributors:
 * - Cloudsmith Inc - initial API and implementation.
 */

// define the grammar. Do not use defaults terminals to get full control.
grammar org.eclipse.b3.BeeLang // with org.eclipse.xtext.common.Terminals

// enables use of ecore types
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// backend model defines general expressions
import "platform:/resource/org.eclipse.b3.backend/model/B3Backend.ecore" as be

// build model defines build specific expression
import "platform:/resource/org.eclipse.b3.build/model/B3Build.ecore" as build

// uncomments if things are needed that should not be in backend or build
// generate beeLang "http://www.eclipse.org/b3/BeeLang"

BeeModel returns build::BeeModel hidden(WS, SL_COMMENT, ML_COMMENT) : {build::BeeModel}
	(imports += Import)* 
	( (functions += Function)  //* 
	| (concerns += Concern_Named) //*
	| (propertySets += PropertySet_Named) //*
	| (buildUnits += BuildUnit) //*
	| (providers += TopLevelUnitProvider) //?
	| (repositories += Repository) //*
	| (defaultProperties = PropertySetDefault) //?
	)* 
	;

Import returns be::IType : {be::B3JavaImport}
	(reexport ?='reexport')? "use" qualifiedName = QID ("as" name=ID)? ';' 
	;

// Wanted later 
//Import : (reexport ?='reexport')? 
//		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
//	; 

//JavaImporter 	: qualifiedName=QID ;
//NativeImporter 	: uriString = STRING ;
		
BuildUnit returns build::BuildUnit hidden(WS, ML_COMMENT, SL_COMMENT) : {build::BuildUnit}
	(documentation = DOCUMENTATION)?
	(executionMode = ExecutionMode)?
	'unit' (name=EscapedQualifiedName)? ('version' version = VersionLiteral)?
		('is' implements += SimpleTypeRef (',' implements+=SimpleTypeRef)*)? 
	((
	'{'
		( ('source' ':' sourceLocation = Path ';') //?
		| ('output' ':' outputLocation = Path ';') //?
		| ('provides' ':' (
			('[' providedCapabilities += ProvidedCapability 
				(',' providedCapabilities += ProvidedCapability)* ']') 
			| providedCapabilities += ProvidedCapability ) 
			';') //?
		| ('requires' ':' (
			( '[' requiredCapabilities += AliasedRequiredCapability 
				(',' requiredCapabilities += AliasedRequiredCapability)* ']')
			| requiredCapabilities += AliasedRequiredCapability) 
			';') //?
		| ('requires' 'env' ':' (
			('[' metaRequiredCapabilities += RequiredCapability 
				(',' metaRequiredCapabilities += RequiredCapability)* ']')
			| metaRequiredCapabilities += RequiredCapability) 
			';') //?
		| ((functions += Builder ) | (functions += Function )) //*
		| (providers += TopLevelUnitProvider) //?
		| (concerns += Concern_Named) //*
		| (propertySets += PropertySet_Named) //*
		| (containers += ContainerConfiguration ';' ) //*
		| (synchronizations += Synchronization ) //*
		| (repositories += Repository) //*
		| (defaultProperties = PropertySetDefault) //?
		)*
	'}' 
	) | ';' )
	;

ProvidedCapability returns build::VersionedCapability : {build::VersionedCapability}
	("unit" | "capability")
		('{'
		( ('when' ':' condExpr = Expression ';')?
		& ("name" ':' name = STRING ';')?		  
		& ("name-space" ':' nameSpace = CapabilityInterface ';')?
		& ("version" ':' version = VersionLiteral ';')?
	  	)
	'}')
	;
	
// Capability required by a unit - always refers to capabilities with at least ns/name
// or the keyword "unit" instead of the namespace for buildunits
AliasedRequiredCapability returns build::RequiredCapability : {build::AliasedRequiredCapability} 
	("unit" | "capability") 
	('{'
		( ('when' ':' condExpr=Expression ';')?  
		& ("name" ':' name = STRING ';')?
		& ("name-space" ':' nameSpace = CapabilityInterface ';')?
		& (greedy ?= "greedy" ';')? 
		& ("requires-min" ':' min = IntValue ';' )? 
		& ("requires-max" ':' max  = IntValue ';')?
		& ("version" ':' versionRange = VersionRangeLiteral ';')?
	  	)
	'}') ("as" alias = ID)?
	;
	
// Capability required by a unit - always refers to capabilities with at least ns/name
// or the keyword "unit" instead of the namespace for buildunits
RequiredCapability returns build::RequiredCapability : {build::RequiredCapability} 
	("unit" | "capability")
	('{'
		( ('when' ':' condExpr=Expression ';')?  
		& ("name" ':' name = STRING ';')?
		& ("name-space" ':' nameSpace = CapabilityInterface ';')?
		& (greedy ?= "greedy" ';')? 
		& ("requires-min" ':' min = IntValue ';' )? 
		& ("requires-max" ':' max  = IntValue ';')?
		& ("version" ':' versionRange = VersionRangeLiteral ';')?
	  	)
	'}') 
	;
	
// Capability required by a unit - always refers to capabilities with at least ns/name
// (can not refer to "unit")
// TODO: Interface should be a proper java interface
RequiredCapability_Unfiltered returns build::RequiredCapability : {build::RequiredCapability}
	("unit"|"capability")
	('{'
		( (greedy ?= "greedy" ';')? 
		& ("name" ':' name = STRING ';')?
		& ("name-space" ':' nameSpace = CapabilityInterface ';')?
		& ("requires-min" ':' min = IntValue ';' )? 
		& ("requires-max" ':' max  = IntValue ';')?
		& ("version" ':' versionRange = VersionRangeLiteral ';')?
	  	)
	'}') 
	;
	
// A named sequence of property statements
PropertySet_Named returns be::BPropertySet : {be::BPropertySet} 
	"properties" name = ID ("extends" extends=[be::BPropertySet | QIDREF])? 
	(('{' (operations += PropertyOperation )* '}' )
	|(':' "load-from" ':' propertiesFile = URI ';')
	)
	;

// Sequence of possibly filtered property statements
PropertySet returns be::BPropertySet :  {be::BPropertySet}
	"properties" ("extends" extends=[be::BPropertySet | QIDREF])? 
	(('{' (operations += PropertyOperation )* '}' )
	|(':' "load-from" ':' propertiesFile = URI ';')
	)
	;
	
AnnotationSet returns be::BPropertySet: PropertySet_noKw ;

// Sequence of possibly filtered property statements (same as property set but withput kw)
PropertySet_noKw returns be::BPropertySet :  {be::BPropertySet}
	("extends" extends=[be::BPropertySet | QIDREF])? 
	(('{' (operations += PropertyOperation )* '}' )
	|(':' "load-from" ':' propertiesFile = URI ';')
	)
	;
	
// Sequence of possibly filtered property statements (with default semantics)	
// - no loading from file = meaningsless as only declared properties can be references,
// they would need  to be in a different default set, or declared (in which case defaults are not
// really needed
// - only extension of other default sets
// - default sets can not have conditional declaration of properties
// TODO: only allowed to extend another default property set
PropertySetDefault returns be::BPropertySet :  {be::BDefaultPropertySet}
	"default-properties" ("extends" extends=[be::BPropertySet | QIDREF])?
	'{' (operations += PropertyOperationDefault )*  '}'
	;
	
// TODO: only allowed to extend another default property set
PropertySetDefault_noKw returns be::BPropertySet :  {be::BPropertySet}
	("extends" extends=[be::BPropertySet | QIDREF])? 
	'{' (operations += PropertyOperation )* '}'
	;

PropertyOperationDefault returns be::BPropertyOperation
	: PropertyDefinitionOperation 
	| PropertySetOperationDefault
	;

PropertyOperation returns be::BPropertyOperation
	: ConditionalPropertyOperation 
	| PropertyDefinitionOperation 
	| PropertySetOperation
	;

ConditionalPropertyOperation returns be::BPropertyOperation : {be::BConditionalPropertyOperation}
	'when' '(' condExpr=Expression ')' 
		(body=PropertyDefinitionOperation | body=PropertySetOperation) 
	;
	
PropertyDefinitionOperation returns be::BPropertyOperation : {be::BPropertyDefinitionOperation}
	(definition = PropertyValDeclaration | definition = PropertyVarDeclaration)
	;
		
// property values, must be assigned (but can be assigned null).
PropertyValDeclaration returns be::BDefProperty : {be::BDefProperty} 
	( final ?= "final")? type=TypeRef? name=PID '=' valueExpr = Expression ';'
	;
	
// property variables, value optionally assigned
PropertyVarDeclaration returns be::BDefProperty : {be::BDefProperty}
	( final ?= "final")? (mutable ?= "mutable")  type=TypeRef? name=PID ('=' valueExpr = Expression)? ';'
	;
	
PropertySetOperation returns be::BPropertyOperation : {be::BPropertySetOperation} 
	propertySet = PropertySet_noKw
	;
PropertySetOperationDefault returns be::BPropertyOperation : {be::BPropertySetOperation} 
	propertySet = PropertySetDefault_noKw
	;

Synchronization returns build::Synchronization : {build::Synchronization}
	"sequential" ':''[' (builderQueries += BuilderQuery)(',' builderQueries += BuilderQuery)* ']' ';'
	;
	
BuilderQuery returns build::BuilderQuery : {build::BuilderQuery}
	("unit" unitQuery = UnitOrExpression)?
	("builder" builderQueries += BuilderOrExpression)(',' builderQueries += BuilderOrExpression)*
	;

// one path vector, or [ , separated list of path vectors + annotation ]	
PathGroup returns build::PathGroup: {build::PathGroup}
	('[' (pathVectors += ConditionalPathVector 
		(',' pathVectors += ConditionalPathVector)* )?
		('annotations' annotations = AnnotationSet)?
	 ']') | (pathVectors += ConditionalPathVector)
	;
	
PathVector returns build::PathVector: (BasePathVector | UnbasedPathVector) ;

BasePathVector returns build::PathVector : {build::PathVector}
	basePath=Path '[' ( paths+=Path (',' paths+=Path)*)? ']' //';'
	;

UnbasedPathVector returns build::PathVector : {build::PathVector}
	paths+=Path // (',' paths+=Path)* ';'
	;
	
ConditionalPathVector returns build::ConditionalPathVector : {build::ConditionalPathVector}
		("when" '(' condExpr=Expression ')' 
			'[' pathVectors += PathVector (',' pathVectors += PathVector)* ']' )
	| 	(("when" '(' condExpr=Expression ')')? pathVectors += PathVector )
	;

//// a path as a string (i.e. ID, QID, "..." or /QID/..
//PathString 
//	: STRING
//	| ('/')? QID ('/' QID)* ('/')? 
//	;
	
// A path can be written without quotes if it consists of safe chars 
Path returns be::URI hidden()
	: STRING
	| ('/')? QID ('/' QID)* ('/')? 
	;

BuilderInputCondition returns build::BuilderInput : {build::BuilderInputCondition}
	"when" '(' condExpr = Expression ')'
		builderInput += BuilderInputUnnamed
	;
	
BuilderInputContext returns build::BuilderInput : {build::BuilderInputContextDecorator}
	withExpr = WithClause ':' builderInput += BuilderInputUnnamed
	;
	
BuilderInputNamed returns build::BuilderInput :
	BuilderInputUnnamed ({build::BuilderInputNameDecorator.builderInput+=current} "as" name=ID )?
;	

//Prerequisite returns build::Prerequisite : {build::Prerequisite} 
//	('when' '(' condExpr=Expression ')' )?
//	(withExpr = WithClause ':')?
//	buildResult=BuilderInputUnnamed
//	("as" name=ID)? // ';'
//	;

// Validation checks that there is at least one of references, properties or concern.
WithClause returns be::BWithExpression : {be::BWithExpression}
		"with"
		( referencedAdvice += [be::BAdvice | ID] (',' referencedAdvice += [be::BAdvice | ID])* )? 
		( ( propertySets += PropertySet )
		| ( propertySets += PropertySetDefault)
		| ( "concern" concerns += Concern_Anonymous )
		)*
		;
			
BuilderInputUnnamed returns build::BuilderInput
	: BuilderInputCondition
	| BuilderInputContext
	| BuildCallOnUnitRequirement
	| BuildCallOnCapabilityRequirement
	| BuildCallOnReferencedRequirement
	| BuildCallOnSelectedRequirement
	| BuilderInputGroup
	;

// A reference to a builder in the same unit
BuildCallOnUnitRequirement returns build::BuilderInput : {build::BuildCallOnDeclaredRequirement} 
	"unit" '.' builderName=EscapedQualifiedName ('(' parameters = ParameterList? ')') ; 

// A reference to a builder in a unit providing a capability (or if build name is omitted to the
// builder that provides the capability in that unit).
BuildCallOnCapabilityRequirement returns build::BuilderInput : {build::BuildCallOnDeclaredRequirement}
	requiredCapabilityDeclaration = RequiredCapability_Unfiltered ('.' builderName=EscapedQualifiedName)?
	('(' parameters = ParameterList? ')')	 
	;
	
// A reference to a builder in a unit providing a referenced capability (or if build name is omitted to the
// builder that provides the capability in that unit).
// TODO: validate that a referenced capability of unit has builderName set
BuildCallOnReferencedRequirement returns build::BuilderInput : {build::BuildCallOnReferencedRequirement}
	requiredCapabilityReference = [build::AliasedRequiredCapability | ID] ('.' builderName=EscapedQualifiedName) ?
	('(' parameters = ParameterList? ')')	 
	;
	
BuildCallOnSelectedRequirement returns build::BuilderInput : {build::BuildCallOnSelectedRequirements}
	"select-required" requiredPredicate = CapabilityPredicate ('.' builderName=EscapedQualifiedName)?
	('(' parameters = ParameterList? ')')	
	;
	
BuilderInputGroup returns build::BuilderInput : {build::BuilderInputGroup}
	'[' (builderInput += BuilderInput (',' builderInput += BuilderInput)*)? ']'
	;
	
Builder returns build::Builder : {build::Builder}
	(documentation = DOCUMENTATION)? 
	(visibility = Visibility)?
    (executionMode = ExecutionMode)?
  	(final ?= "final")?
    "builder"
	name=EscapedQualifiedName
	('(' 
		// first parameter is always "unit", but is implied to "this unit" if builder is specified in
		// a build unit
		// TODO: validation and relevant content proposal
		(( ((explicitUnitType = ParameterDeclarationUnit) | (parameters += ParameterDeclarationNotUnit))
			(',' parameters += ParameterDeclarationNotUnit)* 
			(',' varArgs?="..." parameters += ParameterDeclarationNotUnit)?)
		| 	(    varArgs?="..." parameters += ParameterDeclarationNotUnit))?
	')' )?
//	(guard = GuardExpression)?
	(precondExpr = PreCondition)?
	(postcondExpr = PostCondition)?
	 '{'
		(('provides' ':' ( ('[' providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)* 
			        	    ']'
			        	  ) |  (providedCapabilities += ProvidedCapability) 
			        	 )';')?
		& (defaultProperties = PropertySetDefault)?
		)?
	     ("input" ':' (input = BuilderInputGroup) ';' (postinputcondExpr = PostInputCondition)? )? 
	     ("source" ':' source = PathGroup ';' )?
	     ("output" ':' output = PathGroup ';' )? 
	     ("result" ':' funcExpr = Expression ';')?
	 '}'
	;

PreCondition returns be::BExpression :  "@precondition" ':' Expression ';' ;
PostCondition returns be::BExpression : "@postcondition" ':' Expression ';' ;
PostInputCondition returns be::BExpression : "@postinputcondition" ':' Expression ';' ;
	
ParameterList returns be::BParameterList : {be::BParameterList} 
	parameters += ParameterOrClosure ("," parameters += ParameterOrClosure)*
	;
	
ParameterOrClosure returns be::BParameter 
	: ClosureParameter
	| Parameter
	;
	
Parameter returns be::BParameter : {be::BParameter} 
	expr = Expression 
	;
	
ClosureParameter returns be::BParameter : {be::BParameter} 
	(expr = ClosureExpression) 
	;

ParameterDeclarationOptType returns be::BParameterDeclaration : {be::BParameterDeclaration} 
	((type=TypeRef)? name = (ID_or_KW)) 
	;
	
ParameterDeclaration returns be::BParameterDeclaration : {be::BParameterDeclaration} 
	type=TypeRef name = ID_or_KW 
	;

ParameterDeclarationUnit returns be::BParameterDeclaration : {be::BParameterDeclaration} 
	type=TypeRef name = "unit" 
	;
	
// Used in Builder where the first paramter can be called unit, but not others	
ParameterDeclarationNotUnit returns be::BParameterDeclaration : {be::BParameterDeclaration} 
	type=TypeRef name = ID_or_KW_NO_UNIT 
	;

BuilderInput returns build::BuilderInput :
	BuilderInputNamed
	;
//	prerequisites += Prerequisite (',' prerequisites += Prerequisite)*
//	;
	
Repository returns build::Repository : {build::Repository}
	(documentation = DOCUMENTATION)?
	"repository" handlerType = ID name = ID
		((':' "connection" ':' address = Expression ';')
		|('{'
			("connection" ':' address = Expression ';')?
			(options += RepoOption)*
			("branches" ':' '[' (branches += Branch) (',' branches += Branch)* ']' ';')?
	  	  '}')
	  	 )
	;
enum BranchPointTypeLatest returns build::BranchPointType :  Latest="latest" ;
enum BranchPointTypeOther returns build::BranchPointType : Latest="latest" | Revision="revision" | Tag="tag" | Timestamp = "timestamp";
//enum BranchPointTypeTs returns build::BranchPointType : Timestamp="timestamp" ;
//enum
MergeStrategy returns build::MergeConflictStrategy : ID_or_KW;
TriState returns  build::TriState : "true" | "false" | "default" ;

//	  FailModified = "fail-modified"
//	| KeepModified = "keep-modified"
//	| Merge = "merge-modified"
//	| NoUpdate = "no-update"
//	| ReplaceModified = "replace-modified"
//	| BranchPointDefault = "default"
//;
	
//		  | (branchPointType = BranchPointTypeTs branchPointTs = TIMESTAMP ';') 

Branch returns build::Branch : {build::Branch}
  	(documentation = DOCUMENTATION)?
	"branch"
	name = EscapedQualifiedName
	'{'	(
		  ( (branchPointType = BranchPointTypeLatest ';') |
		   (branchPointType = BranchPointTypeOther ':' branchPoint = Expression ';')
		  )?
		& ("policy" ':' '{' 
			( 	("checkout-content" ':' checkout = TriState ';')?
				(( 	("accept-dirty" ':' acceptDirty = TriState ';')?
				  & ("update-content" ':' update = TriState ';')?
				  & ("on-merge-conflict" ':' mergeStrategy = MergeStrategy ';')?
				) | ("replace-content" ':' replace = TriState ';'))
			)? 
			'}' ';')?
		& ("exclude" ':' '[' (exclude += NamePredicate) (',' exclude += NamePredicate)* ']' ';')?
		& ("include" ':' '[' (include += NamePredicate) (',' include += NamePredicate)* ']' ';')?
		)
	'}'
	;
// Branches and revisions have string form (they can be very long), and can be a string or INT/HEX
// The physical type of a revision is determined by a repository type.
BranchPointString : EscapedQualifiedName | INT | HEX ;
	
UnitProvider returns build::UnitProvider 
	: FirstFoundUnitProvider
	| BestFoundUnitProvider 
	| SwitchUnitProvider
	| RepositoryUnitProvider
	;

RepositoryUnitProvider returns build::RepositoryUnitProvider : {build::RepositoryUnitProvider}
	(documentation = DOCUMENTATION)?
	'repository' repository = [build::Repository | ID] 
		('{' (options += RepoOption)*  '}')?
	;
RepoOption returns build::RepoOption : {build::RepoOption}
	name = ID ':' expr = Expression ';'
	;
	
TopLevelUnitProvider returns build::FirstFoundUnitProvider : {build::FirstFoundUnitProvider}
	(documentation = DOCUMENTATION)?
	"resolution" ':' '[' providers += UnitProvider (',' providers += UnitProvider)* ']' ';'
	;
	
FirstFoundUnitProvider returns build::FirstFoundUnitProvider : {build::FirstFoundUnitProvider}
	(documentation = DOCUMENTATION)?
	 "select-first" ':' '[' providers += UnitProvider (',' providers += UnitProvider)* ']' 
	;
	
BestFoundUnitProvider returns build::BestFoundUnitProvider : {build::BestFoundUnitProvider}
	(documentation = DOCUMENTATION)?
	"select-best" ':' '[' providers += UnitProvider (',' providers += UnitProvider)* ']'
	;
	
SwitchUnitProvider returns build::SwitchUnitProvider : {build::SwitchUnitProvider}
	(documentation = DOCUMENTATION)?
	"select-switch" repoSwitch=SelectSwitchExpression
	; 
	
SelectSwitchExpression returns be::BSwitchExpression : {be::BSwitchExpression}
	(switchExpression=Expression)? (caseList+=RepositorySelectCase)+  "endswitch" 
	;
			
RepositorySelectCase returns be::BCase : {be::BCase} 
	(("case" conditionExpr=Expression) | "default") ':' thenExpr = UnitProvider
	;
	
ContainerConfiguration returns build::ContainerConfiguration: {build::ContainerConfiguration} 
	(documentation=DOCUMENTATION)? 
	"container" agentType=TypeRef name=ID ((contextBlock = BlockExpression) | ';') 
	;
	
URI returns be::URI : 
	STRING
	;

Concern_Named returns be::BConcern : {be::BConcern} 
	(documentation = DOCUMENTATION)? "concern" name=ID
	("extends" superConcerns += [be::BConcern | ID] (',' superConcerns += [be::BConcern | ID])*)? 
	'{' (
			(propertySets += PropertySet) 
		|	(propertySets += PropertySetDefault) 
		| 	(functions+=Function)
		| 	(functions+=Builder)
		|	(contexts += BuildConcernContext)
		)* '}' 
	;


Concern_Anonymous returns be::BConcern : {be::BConcern}
	("extends" superConcerns+= [be::BConcern | ID] (',' superConcerns += [be::BConcern | ID])*)? 
	'{' (
			(propertySets += PropertySet) 
		|	(propertySets += PropertySetDefault) 			
		| 	(functions+=Function)
		| 	(functions+=Builder)
		|	(contexts += BuildConcernContext)		
		)* '}' 
	;

Function returns be::B3Function : {be::B3Function}
	(documentation = DOCUMENTATION)?
   	(visibility = Visibility)?
//    (executionMode = ExecutionMode)?	   	
   	(final ?= "final")?
   	"function"
   	(returnType = TypeRef)?
   	name=ID 
//   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
   	('(' (
   		(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* (',' varArgs?="..." parameters += ParameterDeclaration)?)
   		| (varArgs ?= "..." parameters += ParameterDeclaration)
   		)? ')' )?
//   	(guard = GuardExpression)?
   	((':' funcExpr=Expression ';') | (funcExpr=BlockExpression))
	;

// TODO: redesign into "static calculation"
//GuardExpression returns be::BGuardExpression : {be::BGuardExpression} 
//	"@callguard" ':' guardExpr = Expression ';' ;
	
//TypeParamDeclaration 
//	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
//	;
		
/* EXPRESSIONS */
AssignmentOperator 
	: '=' | '+=' | '-=' | '*='	| '/=' | "%=" 
// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
//	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>=" 
	;
	
RelationalOperator 
	: "~=" | "==" | "===" | "!=" | "!=="
	| ">=" | "<=" | ">" | "<"
	;

// All expressions, including variable and value definitions. Note: order of rules is significant.
TopLevelExpression returns be::BExpression 
	: VarDeclaration 
	| ValDeclaration
	| AssignmentExpression 
	;

// All expressions except variable and value definitions	 
Expression returns be::BExpression
	: AssignmentExpression 
	;

AssignmentExpression returns be::BExpression :
	  CachedExpression ({be::BAssignmentExpression.leftExpr=current} 
	 	functionName=AssignmentOperator rightExpr=AssignmentExpression)?
	;	

VarDeclaration returns be::BExpression : {be::BDefValue} 
	(final ?= "final")? 
	(( "var" |  type=TypeRef ) name=ID) 
	('=' valueExpr = Expression)? 
	;

ValDeclaration returns be::BExpression : {be::BDefValue}
	(final ?= "final")? 
	immutable ?= "val" (type=TypeRef)? name=ID 
	'=' valueExpr = Expression
	;

// TODO: typereference is simplified to only the name of a java type - for model imports
// the model is imported with name == namespace, and types in the model are referenced after
// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
// referenced as mymodel::mytype
// There is more work required to link a reference to such a type and it is therefore deferred
// until we are up on Xtext 0.8 with better scoping and linking.
// For now, this is just proof of concept.
// 
		
TypeRef returns be::IType 
	: ClosureTypeRef 
	| SimpleTypeRef
	; 
	
SimpleTypeRef returns be::IType : {be::B3ParameterizedType} 
	rawType=[be::B3JavaImport | ID] 
		('<' actualArgumentsList+=[be::B3JavaImport | ID] (',' actualArgumentsList+=[be::B3JavaImport | ID])* '>' )?
//		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
	;
	

// ClosureTypeRef declares parameters and return type	
// TODO: use TypeRef instead of direct reference to imported class
ClosureTypeRef returns be::IType : {be::B3FunctionType} 
	('('(
		(parameterTypes += [be::B3JavaImport | ID] (',' parameterTypes += [be::B3JavaImport | ID])* 
			(',' varArgs ?= "..." parameterTypes += [be::B3JavaImport | ID])?)
		| 	(    varArgs ?= "..." parameterTypes += [be::B3JavaImport | ID])
		)? 
	')' '=>' returnType = [be::B3JavaImport | ID] )
	;

// TODO: TypeParam's and Wildcard refs currently unused. Support should be added
//	
TypeParam returns be::IType: TypeRefParam | WildcardRefParam ;
TypeRefParam returns be::IType: TypeRef ;
WildcardRefParam returns be::IType: 
	{be::B3WildcardType}'?' ( ("extends" upperBoundsList+=TypeRef (',' upperBoundsList+=TypeRef)*) | "super" lowerBoundsList+=TypeRef )?;

CachedExpression returns be::BExpression  : 
	({be::BCachedExpression} "cached" expr = OrExpression)
	| OrExpression
	;
	
OrExpression returns be::BExpression :
	AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*
	;
	
AndExpression returns be::BExpression :
	RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=RelationalExpression)*
	;

// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
// use the backend for some other language with a different grammar).
// BitwiseExpression returns be::BExpression :
// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
	
RelationalExpression returns be::BExpression :
	InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} 
		functionName=RelationalOperator rightExpr=InstanceOfExpression)*
	;

InstanceOfExpression returns be::BExpression :
	AdditiveExpression ({be::BBinaryOpExpression.leftExpr =current} functionName="instanceof" rightExpr=LiteralType)*
	;

// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
// use the backend for some other language with a different grammar).
// ShiftExpression returns be::BExpression:
// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
	
AdditiveExpression returns be::BExpression :
	MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("+" | "-") rightExpr=MultiplicativeExpression)*
	;

MultiplicativeExpression returns be::BExpression :
	SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("*" | "/" | "%") rightExpr=SetExpression)*
	;

SetExpression returns be::BExpression:
	UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=".." rightExpr=UnaryOrInfixExpression)*
	;

UnaryOrInfixExpression returns be::BExpression
	: PostopExpression 
	| UnaryExpression
	| PreopExpression
	; 
	
// DEPRECATED - bitwise operators available as system functions (still available in backend if someone wants to
// use the backend for some other language with a different grammar).
// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
// UnaryExpression returns be::BExpression:
//	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;

UnaryExpression returns be::BExpression : {be::BUnaryOpExpression} 
	functionName=("!" | "-") expr=InfixExpression
	;

PreopExpression returns be::BExpression : {be::BUnaryPreOpExpression}
	functionName=("++" | "--") expr=InfixExpression
	;

PostopExpression returns be::BExpression :
	InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName = ("--" | "++"))?
	;

InfixExpression returns be::BExpression :
	CallExpression ( 
	  	({be::BCallFeature.funcExpr=current} "." name=ID_or_KW  "(" (parameterList = ParameterList)? ")")
	  |	({be::BAtExpression.objExpr=current} '[' indexExpr=Expression ']' )
	  | ({be::BFeatureExpression.objExpr=current} "." featureName=ID_or_KW)
	)*;
	
CallExpression returns be::BExpression : 
	PrimaryExpression ({be::BCallFunction.funcExpr=current}"(" (parameterList = ParameterList)? ")")*
	;
		
PrimaryExpression returns be::BExpression
	: FeatureCall
	| ConstructorCallExpression
	| VariableValue
	| Literal 
	| PropertyValue
	| ParanthesizedExpression
	| IfExpression
	| BlockExpression
	| SwitchExpression
	| ThrowExpression
	| TryCatchExpression
	| ProceedExpression
	| WithExpression
	| WithContextExpression
	;

// Validation checks that there is at least one of references, properties or concern.
WithExpression returns be::BWithExpression : {be::BWithExpression}
		'with'
		( referencedAdvice += [be::BAdvice | ID] (',' referencedAdvice += [be::BAdvice | ID])* )? 
//		( '(' referencedAdvice += [be::BAdvice | ID] (',' referencedAdvice += [be::BAdvice | ID])* ')' )? 
		( ( propertySets += PropertySet )
		| ( propertySets += PropertySetDefault ) 
		| ( 'concern' concerns += Concern_Anonymous )
		)*
		( (':' funcExpr = Expression ) | ('{' funcExpr = BlockExpressionWithoutBrackets '}' ) )
		;
		
WithContextExpression returns be::BWithContextExpression : {be::BWithContextExpression}
	"with" "context" expr = Expression ("as" name = ID )? contextBlock = BlockExpression
	;	

ProceedExpression returns be::BExpression : {be::BProceedExpression}
	"proceed"
	;
	
WildcardExpression returns be::BLiteralAny : {be::BLiteralAny} 
	'_' 
	;

ThrowExpression returns be::BExpression : {be::BThrowExpression} 
	"throw"  expr=Expression 
	;
TryCatchExpression returns be::BExpression : {be::BTryExpression} 
	"try" tryExpr=Expression (catchBlocks+=CatchBlock)*
	("finally" finallyExpr=Expression)? "endtry" 
	;
		
CatchBlock	returns be::BCatch  : {be::BCatch} 
	"catch" type=TypeRef name=ID ':' catchExpr=Expression 
	;
	
SwitchExpression returns be::BExpression : {be::BSwitchExpression}
	"switch" switchExpression=Expression? (caseList+=Case)+  "endswitch" 
	;
			
Case returns be::BCase : {be::BCase} 
	(("case" conditionExpr=Expression)|"default") ":" thenExpr=Expression
	;

BlockExpression returns be::BExpression: {be::BChainedExpression} 
	'{' (expressions +=TopLevelExpression ';')* '}' 
	;

IfExpression returns be::BExpression : {be::BIfExpression} 
	"if" conditionExpr=Expression
	"then" thenExpr=Expression 
	((elseExpr = ElseIfExpression | "else" elseExpr = Expression ))?
	"endif"
	;

ElseIfExpression returns be::BExpression : {be::BIfExpression} 
	"elseif" conditionExpr=Expression 
	"then" thenExpr=Expression 
	((elseExpr = ElseIfExpression | "else" elseExpr = Expression ))?
	;
	
PropertyValue returns  be::BExpression : {be::BVariableExpression}
	namedValue = [be::INamedValue | PID]
//	name = PID
	;
	
VariableValue returns  be::BExpression : {be::BVariableExpression}
	namedValue = [be::INamedValue | ID_or_KW] 
	;
	
ID_or_KW : ID | KW ;
ID_or_KW_NO_UNIT : ID | KW_NO_UNIT ;
KW : KW_NO_UNIT | "unit" ; 
KW_NO_UNIT : "input" | "output" | "source" | "result" | "properties" | "builder" | "this"
	| "name" | "modify" | "greedy" | "version" | "requires" | "provides"
	;
	
FeatureCall returns be::BExpression :
	OperationCall
// DEPRECATED: calling ".feature" with implicit 'this'
//	| ({be::BCallFeature} "." name=ID_or_KW  "(" (parameterList = ParameterList)? ")")
//	| ({be::BFeatureExpression} "." featureName=ID_or_KW)
	;
	
OperationCall returns be::BCallExpression : {be::BCallNamedFunction}
	funcRef = [be::IFunction | ID]
	'(' (parameterList = ParameterList)? ')' 
	;

ConstructorCallExpression returns be::BExpression : {be::BCreateExpression} 
	"new" typeExpr=LiteralType 
	('(' (parameterList=ParameterList)? ')')?
	("as" name=ID)? 
	(contextBlock = InitializationBlockExpression)?
	;
InitializationBlockExpression returns be::BExpression : {be::BChainedExpression}
	'{'  (expressions += InitializationExpression ';')* '}'
	;

InitializationExpression returns be::BExpression : {be::BAssignmentExpression}
	leftExpr = FeatureOfThis functionName=":" rightExpr = Expression
	;
FeatureOfThis returns be::BExpression : {be::BFeatureExpression}
	// TODO: objExpr = null, means use "this" (cheat)
	featureName = ID_or_KW 
	; 
// Used in a concern to describe pointcuts/advice for units and/or builders
BuildConcernContext returns be::BConcernContext : 
	  UnitConcernContext
	| BuilderConcernContext
	| FunctionConcernContext
	;
	
FunctionConcernContext returns be::BFunctionConcernContext: {be::BFunctionConcernContext} 
	(documentation = DOCUMENTATION) ?
	"context" "function" namePredicate = FunctionNamePredicate 
   	('(' (
   		(parameters += ParameterPredicate (',' parameters += ParameterPredicate)* 
   		   (',' varArgs ?= "..." parameters += ParameterVarargsPredicate)?)
   		|  (    varArgs ?= "..." parameters += ParameterVarargsPredicate)
   		)? matchParameters ?= ')' )?
   	funcExpr = BlockExpression
	;
FunctionNamePredicate returns be::BFunctionNamePredicate : {be::BFunctionNamePredicate }
	namePredicate = NamePredicate
	;	
ParameterPredicate returns be::BParameterPredicate : {be::BParameterPredicate}
	  ('_' typePredicateOp = TypePredicateOp?)
	| (type=TypeRef ((typePredicateOp = TypePredicateOp) | (name = ID))?) 
	;
	
// Varargs can only be last, and it only makes sense to skip the type (not to use ?*+)	
ParameterVarargsPredicate returns be::BParameterPredicate : {be::BParameterPredicate}
	  ('_')
	| (type=TypeRef (name = ID)?) 
	;
	
TypePredicateOp : '?' | '*' | '+' ;

// Advice for units consists of Builders, and advice for Builders
UnitConcernContext returns build::UnitConcernContext : {build::UnitConcernContext}
	(documentation = DOCUMENTATION) ?
	"unit-context"
	'{'
		"select-units" ':'  query = UnitOrExpression ';'
		"modify-selected" ':' '{'
			("source" ':' sourceLocation = URI ';')?	
			("output" ':' outputLocation = URI ';')?	
			("provides" ':' '{'
				( ('-' providesRemovals += ProvidesPredicate ';')
				| ('+' providedCapabilities += ProvidedCapability ';')
			)* '}' ';')?
			("requires" ':' '{'
				( ('-' requiresRemovals += RequiresPredicate ';')
				| ('+' requiredCapabilities += AliasedRequiredCapability ';')
			)* '}' ';')?

			( (functions += Builder)
			| (builderContexts += BuilderConcernContext)
			)*
	// TODO - this is sort of bogus, can not remove a default property, changing the default is the same as
	// specifying the value of a property... If introducing new functions those functions may need to see
	// different properties, and those may need to be default - rethink
	('-'  defaultPropertiesRemovals += PID (',' defaultPropertiesRemovals += PID)* ';')?
	('+'  defaultPropertiesAdditions = PropertySetDefault )?
	'}' ';'
	'}'
	;
	
// Advice for Builders	
BuilderConcernContext returns build::BuilderConcernContext : {build::BuilderConcernContext}
	(documentation = DOCUMENTATION) ?
	"builder-context" '{' 
		"select-builders" ':' query = BuilderOrExpression ';'
	 	("having-parameters" matchParameters ?= ':' '(' 
	   		((parameters += ParameterPredicate (',' parameters += ParameterPredicate)* 
	   		   (',' varArgs ?= "..." parameters += ParameterVarargsPredicate)?)
	   		|  (    varArgs ?= "..." parameters += ParameterVarargsPredicate)
	   		)? ')' ';' )?
  		"modify-selected" ':' '{'
  			("conditions" ':' '{' 			
				('-' removePreCondition ?="precondition" ';' )?
				('+' "precondition" ':' precondExpr = Expression ';' )?
				('-' removePostInputCondition ?="postinputcondition" ';')?
				('+' "postinputcondition" ':' postinputcondExpr = Expression ';' )?
				('-' removePostCondition ?="postcondition" ';')?
				('+' "postcondition" ':' postcondExpr = Expression ';' )?
			'}' ';')?

			("provides" ':' '{'
				( ('-' providesRemovals += ProvidesPredicate ';')
				| ('+' providedCapabilities += ProvidedCapability ';')
			)* '}' ';')?

				// TODO: rethink advice of default properties
				('-' defaultPropertiesRemovals += PID (',' defaultPropertiesRemovals += PID)* ';')?
				('+' defaultPropertiesAdditions = PropertySetDefault )?
			
			("input" ':' '{'
				( ('+' inputAdditions += BuilderInput ';') 
				| ('-' inputRemovals += InputPredicate ';')
			)* '}' ';')?
	
			("source" ':' '{'
				( ('+' sourceAdditions += ConditionalPathVector ';')
				| ('-' "source" '~=' sourceRemovals += SourcePredicate ';')
				)* 
				// TODO : rethink advice of annotations
				('-' "annotations" '~=' '[' sourceAnnotationsRemovals += PID (',' outputAnnotationsRemovals += PID)* ']' ';')?
				('+' "annotations" ':' sourceAnnotationAdditions = AnnotationSet )?
			'}' ';')?
			
			("output" ':' '{'
				( ('+' outputAdditions += ConditionalPathVector ';')
				| ('-' "output" '~=' outputRemovals += OutputPredicate ';')
				)* 
				// TODO : rethink advice of annotations
				('-' "annotations" '~=' '[' outputAnnotationsRemovals += PID (',' outputAnnotationsRemovals += PID)* ']' ';')?
				('+' "annotations" ':' outputAnnotationAdditions = AnnotationSet )?
			'}' ';')?
						
			("result" ':' funcExpr = Expression ';')? // replaces the builder's funcExpression
		'}' ';'
	'}'
	;

UnitOrExpression returns be::BExpression :
	UnitAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=UnitAndExpression)*
	;
	
UnitAndExpression returns be::BExpression :
	UnitNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=UnitNotOrPrimaryExpression)*
	;
	
UnitNotOrPrimaryExpression returns be::BExpression :
	UnitNotExpression | UnitPrimaryExpression 
	;
		
UnitNotExpression returns be::BExpression : {be::BUnaryOpExpression} 
	functionName=("!") expr=UnitPrimaryExpression
	;
	
UnitPrimaryExpression returns be::BExpression :
	  RequiresPredicate
	| ImplementsPredcicate
	| ProvidesPredicate
	| UnitNamePredicate
	| GroupedUnitPrimaryExpression
	;
	
GroupedUnitPrimaryExpression returns be::BExpression : '(' UnitOrExpression ')' ;

	
RequiresPredicate returns build::RequiresPredicate : {build::RequiresPredicate}
	"requires" (meta ?= "env")?  "~=" capabilityPredicate = CapabilityPredicate 
	;
	
ImplementsPredcicate returns be::BExpression: {build::ImplementsPredicate}
	"is" "==" type = TypeRef 
	;
	
ProvidesPredicate returns build::ProvidesPredicate : {build::ProvidesPredicate}
	"provides"  "~=" capabilityPredicate = CapabilityPredicate 
	;
	
UnitNamePredicate returns build::CapabilityPredicate : {build::UnitNamePredicate}
	"unit" "~=" '{' 
		("name"  namePredicate = QualifiedNamePredicate ';')
		("version" '~=' versionRange=VersionRangeLiteral ';')?
	'}' 
	;

BuilderNamePredicate returns build::BuilderNamePredicate : {build::BuilderNamePredicate}
	"builder" "~=" '{' ("name"  namePredicate = QualifiedNamePredicate ';') '}'
	;
	
InputPredicate returns build::InputPredicate: {build::InputPredicate}
	"input" "~=" '{'
	( (capabilityPredicate = CapabilityPredicate)
	| (capabilityPredicate = UnitNamePredicate)
	| ("unit")?
	)
	"called-builder" builderPredicate = QualifiedNamePredicate ';'
	'}'
	;
	
SourcePredicate returns build::SourcePredicate : {build::SourcePredicate}
	  pathVector = BasePathPredicate
	| pathVector = PathPredicate
	| pathPattern = PatternLiteral
	;

OutputPredicate returns build::OutputPredicate : {build::OutputPredicate}
	  pathVector = BasePathPredicate
	| pathVector = PathPredicate
	| pathPattern = PatternLiteral
	;
	
BasePathPredicate returns build::PathVector : {build::PathVector}
	basePath = Path '[' paths += Path (',' paths += Path)* ']'
	;
	
PathPredicate returns build::PathVector : {build::PathVector}
	paths += Path (',' paths += Path)*
	;

CapabilityPredicate returns build::CapabilityPredicate : {build::CapabilityPredicate} 
	"capability" '{' 
		("name-space"  nameSpacePredicate = QualifiedNamePredicate ';')
		("name"  namePredicate = QualifiedNamePredicate ';')
		("version" '~=' versionRange=VersionRangeLiteral ';')?
	'}' 
	;

QualifiedNamePredicate	 returns be::BNamePredicate : {be::BNamePredicate}
	('==' name=EscapedQualifiedName)  | ('~=' namePattern = PatternLiteral)
	;

NamePredicate returns be::BNamePredicate : {be::BNamePredicate}
	(name=EscapedQualifiedName)  | (namePattern = PatternLiteral)
	;
	
BuilderOrExpression returns be::BExpression :
	BuilderAndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=BuilderAndExpression)*
	;
	
BuilderAndExpression returns be::BExpression :
	BuilderNotOrPrimaryExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=BuilderNotOrPrimaryExpression)*
	;
	
BuilderNotOrPrimaryExpression returns be::BExpression :
	BuilderNotExpression | BuilderPrimaryExpression 
	;
		
BuilderNotExpression returns be::BExpression : {be::BUnaryOpExpression} 
	functionName=("!") expr=BuilderPrimaryExpression
	;
	
BuilderPrimaryExpression returns be::BExpression :
	  InputPredicate
	| ProvidesPredicate
	| BuilderNamePredicate
	| GroupedBuilderPrimaryExpression
	;
	
GroupedBuilderPrimaryExpression returns be::BExpression : '(' BuilderOrExpression ')' ;
					
Literal returns be::BExpression
	: ValueLiteral
	| PatternLiteral
	| LiteralMap
	| LiteralList
	| LiteralFunction
	;
PatternLiteral returns be::BPatternLiteralExpression 
	: RegexpLiteral
	| SimplePatternLiteral
	| WildcardExpression
	;
		
LiteralList returns  be::BExpression
	: {be::BLiteralListExpression} '[' ('<' entryType=TypeRef '>')? entries += Expression (',' entries += Expression)*  ']' 
	| {be::BLiteralListExpression} '[''<' entryType=TypeRef '>' ']' 
	;
	
LiteralMap returns  be::BExpression
	: {be::BLiteralMapExpression} '['  ('<' keyType=TypeRef ',' valueType=TypeRef '>')? entries += MapEntry (',' entries += MapEntry)* ']' 
	| {be::BLiteralMapExpression} '[' '<' keyType=TypeRef ',' valueType=TypeRef '>' ']' 
	;

// A lambda enclosed in { }
LiteralFunction returns be::BExpression :
	'{' ClosureExpression '}'
	;

//LiteralFunction returns be::BExpression : {be::B3Function} 
//	'{' ('<' returnType=TypeRef '>')?
//	(
//	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* 
//		(',' varArgs?="..." parameters += ParameterDeclaration)?)
//	| 	(    varArgs?="..." parameters += ParameterDeclaration)
//	)? 
//	'|' funcExpr=OneOrManyExpressions '}'
//	;

// A lambda (without delimiters)
ClosureExpression returns be::BExpression: {be::B3Function} 
	('<' returnType=TypeRef '>')?
	( '|'?
	(parameters += ParameterDeclarationOptType (',' parameters += ParameterDeclarationOptType)* 
		(',' varArgs?="..." parameters += ParameterDeclarationOptType)?)
	| 	(    varArgs?="..." parameters += ParameterDeclarationOptType)
	)? 
	'|' funcExpr=OneOrManyExpressions
	;

OneOrManyExpressions returns be::BExpression
	: BlockExpressionWithoutBrackets
	| Expression
	;
	
BlockExpressionWithoutBrackets returns be::BExpression : {be::BChainedExpression} 
	(expressions += TopLevelExpression ';')* // should be +, but produces markers that are no good 
	;
	
MapEntry returns be::BMapEntry: {be::BMapEntry} 
	key = KeyLiteral ':' value= Expression 
	;

KeyLiteral returns be::BExpression : {be::BLiteralExpression} 
	value = (ID|PID|STRING) 
	;

LiteralType returns be::BLiteralType : {be::BLiteralType} 
	type=TypeRef 
	;

ValueLiteral returns be::BExpression 
	: BooleanLiteral 
	| RealLiteral  // SEE ISSUE 297089 - must be placed before IntegerLiteral
	| IntegerLiteral 
	| NullLiteral 
	| StringLiteral
//	| QueryLiteral
	| UnitLiteral
	;
	
BooleanLiteral returns  be::BExpression : {be::BLiteralExpression} 
	value = BooleanValue
	;
	
IntegerLiteral returns  be::BExpression : {be::BLiteralExpression} 
	value= IntValue
	;
	
UnitLiteral returns  be::BExpression : {be::BLiteralExpression} 
	value="unit"
	;
	
StringLiteral returns  be::BExpression : {be::BLiteralExpression} 
	value = STRING
	;
	
RealLiteral	returns  be::BExpression : {be::BLiteralExpression}
	value = RealValue
	;
	
RegexpLiteral returns be::BRegularExpression : {be::BRegularExpression}
	pattern = REGULAR_EXPR
	;
	
SimplePatternLiteral returns be::BSimplePatternExpression : {be::BSimplePatternExpression}
	pattern = SIMPLE_PATTERN
	;
	
	
// Note: NullLiteral has a java null value as its value
NullLiteral	returns  be::BExpression : {be::BLiteralExpression} 
	"null"
	;

//ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
//SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";

// Has conversion rule
BooleanValue returns ecore::EBooleanObject : ("true" | "false" );

// Has conversion rule
RealValue returns ecore::EDoubleObject: REAL ;

// Has conversion rule that handles decimal, octal, and hexadecimal values with radix
IntValue returns ecore::EIntegerObject : INT | HEX ;
	
ParanthesizedExpression returns be::BExpression : 
	'(' Expression ')'
	;	

// Has conversion rule
VersionLiteral returns build::Version
	: STRING  
	| AlfanumSym
	;

// Has conversion rule
VersionRangeLiteral returns build::VersionRange
	: ('[' | '(') (STRING | AlfanumSym) (',' (STRING | AlfanumSym))? (']'|')')
	| (STRING | AlfanumSym)
	;

// Reference to qualified named item, possibly in unit, this or super, or
// this.super, or unit.super (ONLY USED BY PROPERTY SET - CLEAN THIS UP)
// TODO: super, unit, this - not yet handled - subject to change?
QIDREF : (("super" |(("unit" | "this") ('.' "super")?)) ('.' QID)?) | QID ;

// Qualified name
QID hidden(): ID_or_KW (INT|HEX|ID_or_KW)* ('.' ID_or_KW (INT|HEX|ID_or_KW)*)* ; 

// Allows a qualified name, or a string to be used as a name
EscapedQualifiedName:  STRING | QID;
CapabilityInterface	: QID ;

//// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
//BuilderName 	: EscapedQualifiedName ;
//CapabilityName 	: STRING ; // although nice to just write a.b.c it clashes with a.b.c.builder()

enum Visibility 	returns be::Visibility : public | private ;
enum ExecutionMode 	returns be::ExecutionMode: parallel | sequential ;

// RULE 'TERMINALS'

TIMESTAMP returns ecore::EDate : STRING ;

// Version, and VersionRange use these
// TODO: uncertain if the set of allowed chars is definitive.
//
Separator :  '-' | '!' | '@' | '$' | '%' | '&' |'+' | '=' | '*' | '<' | '>' | ':' | '?';
AlfanumSym hidden() : (ID | INT | HEX | EXT_INT) ('.'?(Separator|ID|INT|HEX |EXT_INT))* ;

DOCUMENTATION : TEXT | JAVADOC ;

// --TERMINALS
// (NOTE: Does not use standard terminals to have full control).

// TODO: Possibly use some other char instead of ^ as escape mechanism for keywords??
terminal ID : ('^')?(('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|('0'..'9')|'_')* ;

// Property Names start with $ and are qualified. Must be handled by lexer as
// a.b.c is otherwise ambigous in expressions.
terminal PID : '$' '{' ID ('.' ID)* '}';

// Java regexp - allows \ before any character == same as unescaped character if character is not an operator
terminal REGULAR_EXPR returns be::RegexpPattern
	: "~/" ( '\\' (!('\t'|'\r'|'\n'))
			| (!('\\'|'/'|' '|'\t'|'\r'|'\n')))* "/" ('u'|'m'|'i'|'c'|'d')*
			;
			
terminal SIMPLE_PATTERN returns be::SimplePattern
	: '~' STRING
	;
	
// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
// A string converter may need to handle the u, x, and octal escapes.
// Regular java string handles XXXX , and gives syntax error if
// format is not ok, the other two remains, and possibly the null.
// TODO: check STRING grammar
terminal STRING :
'"' ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|'"'|'\r'|'\n') )* '"' |
"'" ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|"'"|'\r'|'\n') )* "'";

terminal TEXT : '«' -> '»';
terminal JAVADOC : '/**' -> '*/' ;
terminal ML_COMMENT : '/*' (!'*') -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS : (' '|'\t'|'\r'|'\n')+ ;
terminal HEX : '0' ('x'|'X')(('0'..'9')|('a'..'f')|('A'..'F'))+ ;
terminal INT : ('0'..'9')+;
REAL hidden(): INT ? '.' (EXT_INT | INT);
terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
 
terminal ANY_OTHER : . ;

