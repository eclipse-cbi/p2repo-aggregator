
grammar org.eclipse.b3.BeeLang // with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.eclipse.b3.backend/model/B3Backend.ecore" as be
import "platform:/resource/org.eclipse.b3.beelang/src/org/eclipse/b3/BeeLangTypes.ecore" as types
generate beeLang "http://www.eclipse.org/b3/BeeLang"

BeeModel hidden(WS, SL_COMMENT, ML_COMMENT): 
	(imports += Import)* 
	((functions+=Function) | (concern+=Concern))* 
	(body = Unit)? ;

Import returns be::IType: {be::B3JavaImport}(reexport ?='reexport')? "import" qualifiedName = QID ("as" name=ID)? ';' ;

// Wanted later 
//Import : (reexport ?='reexport')? 
//		'import' importer=(JavaImporter | NativeImporter) ("as" name=ID)? ';' 
//	; 

//JavaImporter 	: qualifiedName=QID ;
//NativeImporter 	: uriString = STRING ;
		
Unit returns BuildUnit hidden(WS, ML_COMMENT, SL_COMMENT) : {BuildUnit}
	(documentation = DOCUMENTATION)?
	(executionMode = ExecutionMode)?
	'unit' (name=UnitName)? ('version' version = Version)?
		('implements' implements += InterfaceName (',' implements+=InterfaceName)*)? 
	'{'
		(	//-- PROPERTIES
			// goes first, because they may be used in the other clauses. TODO: can probably be relaxed
			// since linking will find them anyway.
			//
			  ('default' 'properties'  defaultProperties = PropertySet)
		)?
		( 	//-- PROVIDES
			  ('provides' '{' (providedCapabilities += ProvidedCapability ';')+ '}')
			| ('provides' providedCapabilities += ProvidedCapability ';')
			//-- REQUIRES & META REQUIRES
			| ('requires' '{' (requiredCapabilities += RequiredCapability ';')+ '}')
			| ('requires' requiredCapabilities += RequiredCapability ';')
			| ('env' 'requires' '{' (metaRequiredCapabilities += RequiredCapability ';')+ '}' )
			| ('env' 'requires' metaRequiredCapabilities += RequiredCapability ';')
			//--CONCERNS
			| (concerns+=Concern )
			//--SYNCHRONIZE
			| ('sequential' '{' (synchronizations += Synchronization )+  '}' )
			| ('sequential' synchronizations += Synchronization  )
			//--BUILD METHODS & FUNCTIONS
			| (builders += Builder )			
			| (functions += Function )			
			//-- REPOSITORIES
			| ('repositories' '{' (repositoryConfigurations+=RepositoryConfiguration)* '}' )
			| ('properties'  propertySets += NamedPropertySet)
			| ('containers' '{' containers += ContainerConfiguration* '}' )
		)*
	'}';
	

	
ProvidedCapability : capability=FilteredCapability  ('/' version=Version)?  ;
RequiredCapability : capability=FilteredCapability ('/' range=VersionRange)?  ;
FilteredCapability : ('when' filter=Filter)? capability = Capability ;
Capability : interface=InterfaceName '/' name=UnitName ;

// An optionally named sequence of property statements
NamedPropertySet returns NamedPropertySet
	: name = ID body = PropertySet 
	;

// Sequence of possibly filtered property statements	
PropertySet returns PropertySet
	:  {PropertySet} ("extends" extends=QIDREF)? '{' (operations += PropertyOperation)* '}'
//	:  ("extends" extends=[NamedPropertySet | QIDREF])? '{' (operations += PropertyOperation)* '}'
	;

// For model generation, to get supertype correct
PropertyOperation 
	: FilteredPropertyOperation 
	| SetPropertyOperation 
	| UnsetPropertyOperation 
	| PropertySet
	;

FilteredPropertyOperation returns FilteredPropertyOperation
	: 'when' filter=Filter
		body=(SetPropertyOperation | UnsetPropertyOperation | PropertySet) 
	;

SetPropertyOperation returns SetPropertyOperation
	: ( (final ?= 'final')? key=PropertyName op=AssignmentOperator value=Expression ';')
	;

UnsetPropertyOperation returns UnsetPropertyOperation
	: ('unset' key = PropertyName ';' )
	;

Synchronization 
	: (partrefs += SynchronizedPart)(',' partrefs += SynchronizedPart)+ ';' // TODO: verify at least 2 partrefs
	;
	
SynchronizedPart
	: CompoundName ('#' PartName)?
	| PartName
	;
	
PathGroup : paths+=PathVectorElement+ ('annotations' annotations = PropertySet)? ;

PathVectorElement returns PathVectorElement
	: FilteredPathVector
	| BasePathVector
	| UnbasedPathVector
	;
	
FilteredPathVector returns FilteredPathVector 
	: 'when' filter=Filter body=(BasePathVector|UnbasedPathVector|CompoundPathVector) 
	;

BasePathVector returns PathVector
	: basePath=Path '[' ( paths+=Path (',' paths+=Path)*)? ']' ';'
	;

UnbasedPathVector returns PathVector
	: paths+=Path (',' paths+=Path)* ';'
	;
	
CompoundPathVector returns CompoundPathVector: {CompoundPathVector} '{' body+=PathVectorElement* '}' ;

// A path can be written without quotes if it consists of safe chars 
Path hidden()
	: STRING
	| ('/')? QID ('/' QID)* ('/')? 
	;

Prerequisite : 
		('when' filter=Filter )?
		(withClause = WithClause)?
		partReference=PrerequisiteEntry 
		("as" alias=ID)? ';'
	;

// Validation checks that there is at least one of references, properties or concern.
WithClause : {WithClause}
		'with'
		( '(' references += Expression (',' references += Expression)* ')' )? 
		(( 'properties' properties += PropertySet ) 
		| ( 'concern' concern += ConcernBlock ))*
		;
			
PrerequisiteEntry 
	: DirectPartReferemce
	| CapabilityReferencedPart
	| CompoundReferences
	;
	
DirectPartReferemce	: ((unit=QID)|(unit="unit"))? '#' builder=PartName  (parameters = ParameterList)?; 
	
CapabilityReferencedPart : 
	capability=Capability ('/' range=VersionRange)? ('#' partName=PartName) ?
	(parameters = ParameterList)?	 
	;
	
CompoundReferences
	: {CompounddReferences} '{' (prerequisites += Prerequisite)* '}'
	;
	
Builder returns Builder : {Builder}
	(documentation = DOCUMENTATION)? 
	(visibility = Visibility)?
    (executionMode = ExecutionMode)?
  	(final ?= "final")?
	(cached ?= "cached")?
    "builder"
	name=PartName
	('(' params = ParameterDeclarationList ')')?
	('provides' providedCapabilities += ProvidedCapability (',' providedCapabilities += ProvidedCapability)*  )?
	(preCondition = PreCondition)?
	(postCondition = PostCondition)?
	 '{'
		('default' 'properties' properties = PropertySet)?
	     ( input = BuilderInput )? 
	     ( output = BuilderOutput )?
	     (expressionList = ExpressionList)?
	 '}'
	;

ParameterList returns be::BParameterList: {be::BParameterList} 
	parameters += FirstParameter ("," parameters += FirstParameter)*
	;
	
FirstParameter returns be::BParameter 
	: ClosureParameter
	| Parameter
	;
	
Parameter returns be::BParameter: {be::BParameter} expr = Expression ;
ClosureParameter returns be::BParameter : {be::BParameter} (expr = ClosureExpression) ;

ParameterDeclarationList : 
	(( params += ParameterDeclaration (',' params+=ParameterDeclaration)*(',' params+=ParameterDeclarationEllipse)?) 
	| (params+= ParameterDeclarationEllipse))
	;
ParameterDeclaration returns be::BParameterDeclaration: {be::BParameterDeclaration} ((type=TypeRef)? name = ID) ;
ParameterDeclarationEllipse returns ParameterDeclaration : 
	{VarargParameterDeclaration} "..." (type=TypeRef)? name=ID
	;
 
InputKeyword : 'input' ; 
OutputKeyword : 'output'; 
	
BuilderOutput returns BuilderOutput
	: OutputKeyword '{' body = PathGroup '}' 
	;
	

BuilderInput
	: InputKeyword (preCondition = PreCondition)? (postCondition = PostCondition)?	 
		'{' (prerequisites += Prerequisite)+ '}'
	;

RepositoryConfiguration : RepositoryDeclaration | ResolutionStrategy ;

RepositoryDeclaration : 
	(documentation = DOCUMENTATION)?
	(location=URI | 'repository' type=TypeRef ) (context=ContextBlock)?
	;

ResolutionStrategy : 
	strategy = ("select-first" | "select-best") 
	'{' (repositoryConfig += RepositoryConfiguration)* '}'
	;

ContainerConfiguration : 
	(documentation=DOCUMENTATION)? 
	"container" name=ID "agent" type=TypeRef (contextBlock = ContextBlock)? 
	;
	
URI /* returns types::URI */: STRING
	;

Concern : (documentation = DOCUMENTATION)? "concern" name=ID concern = ConcernBlock ;

ConcernBlock : {ConcernBlock}
	("extends" superConcerns+= ID (',' superConcerns += ID)*)? 
	'{' ((contexts+=Context) | (functions+=Function))* '}' 
	;

Query : "query" ('{' selector=QueryPath '}') ;	
QueryPath : (absolute?=':')? selectors+=Selector (':' selectors+=Selector)* ;
Selector returns Selector
	: (name=QID | op=SelectorOperator | pattern=REGULAR_EXPR) ('[' predicate=Expression ']')? 
	;
enum SelectorOperator : THIS = '.' | PARENT = '..' | CHILDREN = '*' | ANSCESTORS = '**' ;

Filter : '(' predicate = Expression ')' ;

PreCondition : "precondition" '{' (asserts += AssertionExpression)+ '}' ;
PostCondition : "postcondition" '{' (asserts += AssertionExpression)+ '}' ;
AssertionExpression : 'assert' expr=Expression ',' message=STRING ';' ;

ExpressionList : (expressions += Expression ';')+ ;

Function returns be::B3Function: {be::B3Function}
	(documentation = DOCUMENTATION)?
   	(visibility = Visibility)?
    (executionMode = ExecutionMode)?	   	
   	(final ?= "final")?
   	"function"
   	(returnType = TypeRef)?
   	name=ID 
//   	( '<' typeParams+= TypeParamDeclaration (',' typeParams+=TypeParamDeclaration)* '>')? // TODO: add support for this in the model
   	('(' (parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)*)? ')' )?
   	((':' funcExpr=Expression ';') | (funcExpr=BlockExpression))
	;
	
//TypeParamDeclaration 
//	: ID ( ("extends" type+= TypeRef ('&' type+=TypeRef)*) | ("super" superType=TypeRef))?
//	;
		
/* EXPRESSIONS */
AssignmentOperator 
	: '=' | '+=' | '-=' | '*='	| '/=' | "%=" 
// bitwise assignment deprecated, but available in backend if backend is used for some other grammar		
//	| "&=" 	| "^=" | "|=" | "<<=" | ">>=" | ">>>=" 
	;
	
RelationalOperator 
	: "~=" | "==" | "===" | "!=" | "!=="
	| ">=" | "<=" | ">" | "<"
	;

Expression returns be::BExpression: AssignmentExpression ;

AssignmentExpression returns be::BExpression:
	// note: VarDecl | OrExpr is order dependant
	 (VarDeclaration | ValDeclaration | CachedExpression) ({be::BAssignmentExpression.leftExpr=current} 
	 	functionName=AssignmentOperator rightExpr=AssignmentExpression)?
	;	
VarDeclaration returns be::BExpression 
	: {be::BDefValue} ( final ?= "final")? (( "var" |  type=TypeRef ) name=ID) ('=' valueExpr = Expression)? ;

ValDeclaration returns be::BExpression 
	: {be::BDefValue} ( final ?= "final")? immutable ?= "val" (type=TypeRef)? name=ID '=' valueExpr = Expression;
		
TypeRef returns be::IType:  ClosureTypeRef | SimpleTypeRef; // TODO: gets lots of warnings from this...
SimpleTypeRef returns be::IType
	: {be::B3ParameterizedType} rawType=[be::B3JavaImport | ID] 
		('<' actualArgumentsList+=[be::B3JavaImport | ID] (',' actualArgumentsList+=[be::B3JavaImport | ID])* '>' )?
//		('<' actualArgumentsList+=TypeParam (',' actualArgumentsList+=TypeParam)* '>' )? // TODO: Support wildcard as well
	;
	
// TODO: typereference is simplified to only the name of a java type - for model imports
// the model is imported with name == namespace, and types in the model are referenced after
// '::' e.g. "resource:a resouceURi.ecore" as mymodel, and a classifier in this model is
// referenced as mymodel::mytype
// There is more work required to link a reference to such a type and it is therefore deferred
// until we are up on Xtext 0.8 with better scoping and linking.
// For now, this is just proof of concept.
// 

// ClosureTypeRef declares parameters and return type	TODO: use TypeRef instead of direct reference to imported class
ClosureTypeRef returns be::IType
	: {be::B3FunctionType} ('(' (parameterTypes += [be::B3JavaImport | ID] (',' parameterTypes += [be::B3JavaImport | ID])*)? ')'
		'=>' returnType = [be::B3JavaImport | ID] )
	;
	
TypeParam returns be::IType: TypeRefParam | WildcardRefParam ;
TypeRefParam returns be::IType: TypeRef ;
WildcardRefParam returns be::IType: 
	{be::B3WildcardType}'?' ( ("extends" upperBoundsList+=TypeRef (',' upperBoundsList+=TypeRef)*) | "super" lowerBoundsList+=TypeRef )?;

CachedExpression returns be::BExpression 
	: {be::BCachedExpression} "cached" 	expr = OrExpression
	| OrExpression
	;
	
OrExpression returns be::BExpression:
	AndExpression ({be::BOrExpression.leftExpr=current} "||" rightExpr=AndExpression)*;
	
AndExpression returns be::BExpression:
	RelationalExpression ({be::BAndExpression.leftExpr=current} "&&" rightExpr=RelationalExpression)*;

// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
// use the backend for some other language.
// BitwiseExpression returns be::BExpression :
// RelationalExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("&" | "^" | "|") rightExpr=RelationalExpression)*;
	
RelationalExpression returns be::BExpression:
	InstanceOfExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=RelationalOperator rightExpr=InstanceOfExpression)*;

InstanceOfExpression returns be::BExpression :
	AdditiveExpression ({be::BBinaryOpExpression.leftExpr =current} functionName="instanceof" rightExpr=LiteralType)*;

// Deprecated - bitwise operators available as system functions (still available in backend if someone wants to
// use the backend for some other language.	
// ShiftExpression returns be::BExpression:
// AdditiveExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("<<" | ">>" | ">>>") rightExpr=AdditiveExpression)*;
	
AdditiveExpression returns be::BExpression:
	MultiplicativeExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("+" | "-") rightExpr=MultiplicativeExpression)*;

MultiplicativeExpression returns be::BExpression:
	SetExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=("*" | "/" | "%") rightExpr=SetExpression)*;

SetExpression returns be::BExpression:
	UnaryOrInfixExpression ({be::BBinaryOpExpression.leftExpr=current} functionName=".." rightExpr=UnaryOrInfixExpression)*;

UnaryOrInfixExpression returns be::BExpression
	: PostopExpression 
	| UnaryExpression
	| PreopExpression
	; 
	
// Bitwise unary expression ~ for 2's complement deprecated, b3 language uses a system function instead
// kept as comment here if someone wants to use thi grammar for other purposes. 
// UnaryExpression returns be::BExpression:
//	 {be::BUnaryOpExpression} functionName=("!" | "-" | "~") expr=InfixExpression;

UnaryExpression returns be::BExpression:
	 {be::BUnaryOpExpression} functionName=("!" | "-") expr=InfixExpression;

PreopExpression returns be::BExpression:
	 {be::BUnaryPreOpExpression} functionName=("++" | "--") expr=InfixExpression;

PostopExpression returns be::BExpression:
	InfixExpression ({be::BUnaryPostOpExpression.expr=current} functionName = ("--" | "++"))?
	;

	
InfixExpression returns be::BExpression:
	CallExpression ( 
	  	({be::BCallExpression.funcExpr=current} "." name=ID  "(" (parameterList = ParameterList)? ")")
	  |	({be::BAtExpression.objExpr=current} '[' indexExpr=Expression ']' )
	  | ({be::BFeatureExpression.objExpr=current} "." featureName=ID)
	)*;
	
CallExpression returns be::BExpression: 
	PrimaryExpression ({be::BCallExpression.funcExpr=current}"(" (parameterList = ParameterList)? ")")*
		;
		
PrimaryExpression returns be::BExpression
	: FeatureCall
	| ConstructorCallExpression
	| VariableValue
	| Literal 
	| PropertyValue
	| KeywordVariables
	| ParanthesizedExpression
	| IfExpression
	| BlockExpression
	| SwitchExpression
	| ThrowExpression
	| TryCatchExpression
	| WildcardExpression
//	| WithExpression
	;
	
//WithExpression returns Expression: WithClauseExpression | WithContextExpression ;
//WithClauseExpression returns Expression : {WithClauseExpression} 
//	withclause=WithClause expr = BlockExpression 
//	;
//WithContextExpression returns Expresion : {WithContextExpression } 
//	"with" "context" context = Expression expr = BlockExpression
//	;
		
WildcardExpression returns be::BExpression: {be::BLiteralAny} '_' ;

ThrowExpression returns be::BExpression: {be::BThrowExpression} "throw"  expr=Expression ;
TryCatchExpression returns be::BExpression : {be::BTryExpression} 
	"try" tryExpr=Expression (catchBlocks+=CatchBlock)*
	("finally" finallyExpr=Expression)? "endtry" 
	;
		
CatchBlock	returns be::BCatch 
	: {be::BCatch} "catch" exceptionType=TypeRef varname=ID ':' catchExpr=Expression ;
	
SwitchExpression returns be::BExpression
	: {be::BSwitchExpression} "switch" switchExpression=Expression? (caseList+=Case)+  "endswitch" ;
			
Case	returns be::BCase : {be::BCase} "case" conditionExpr=Expression ":" thenExpr=Expression;

BlockExpression returns be::BExpression: {be::BChainedExpression} '{' (expressions += Expression ';')* '}' ;


IfExpression returns be::BExpression
	: {be::BIfExpression} 'if'  conditionExpr=Expression "then" thenExpr=Expression 
	((elseExpr = ElseIfExpression | "else" elseExpr = Expression ))?
	"endif"
	;

ElseIfExpression returns be::BExpression 
	: {be::BIfExpression} "elseif" conditionExpr=Expression "then" thenExpr=Expression 
		((elseExpr = ElseIfExpression | "else" elseExpr = Expression ))?
	;
	
PropertyValue returns  be::BExpression: {be::BVariableExpression} name = PID;
VariableValue returns  be::BExpression: {be::BVariableExpression} name = ID ;
KeywordVariables returns  be::BExpression: {be::BVariableExpression} 
	name = (InputKeyword | OutputKeyword | "properties" | "unit") ;

FeatureCall returns be::BExpression:
	OperationCall
	;
	
OperationCall returns be::BCallExpression
	: {be::BCallExpression} name=(ID|PID) '(' (parameterList = ParameterList)? ')' 
	;

ConstructorCallExpression returns be::BExpression
	: {be::BCreateExpression} "new" typeExpr=LiteralType ('(' (parameterList=ParameterList)? ')')?
		("as" alias=ID)? (contextBlock = ContextBlock)?
	;

Context : "context" selector = ContextSelector block = ContextBlock ;
ContextSelector : TypeRefSelector | ExpressionSelector | UnitSelector ;
TypeRefSelector returns ContextSelector: type = TypeRef ;
ExpressionSelector : expr = Expression ;
UnitSelector : 
	"unit" interface=QID 
	('/' (name=UnitName | namePattern = REGULAR_EXPR) ('/' versionRange=VersionRange)? )? 
	;

ContextBlock returns be::BExpression : {be::BChainedExpression} 
	'{'  ((expressions +=FunctionDefinition) 
//		| (expressions+=BuilderDefinition)   // TODO: How to handle Builder definitions as expressions
		| (expressions+=Expression ';')
//		| (expressions+=PropertiesStatement) // TODO: How to handle Properties statements as expressions
		)* '}' 
		;
					
//ExpressionStatement returns Statement : {ExpressionStatement} val=Expression ';' ;
//PropertiesStatement returns Statement : {PropertiesStatement} "properties" properties = NamedPropertySet ;
FunctionDefinition returns be::BExpression : {be::BDefFunction} function = Function;
//BuilderDefinition returns Statement : {BuilderStatement} builder = Builder;

Literal returns be::BExpression
	: ValueLiteral
	| RegexpLiteral
	| LiteralMap
	| LiteralList
	| LiteralFunction
	;
	
LiteralList returns  be::BExpression
	: {be::BLiteralListExpression} '[' ('<' entryType=TypeRef '>')? entries += Expression (',' entries += Expression)*  ']' 
	| {be::BLiteralListExpression} '[''<' entryType=TypeRef '>' ']' 
	;
LiteralMap returns  be::BExpression
	: {be::BLiteralMapExpression} '['  ('<' keyType=TypeRef ',' valueType=TypeRef '>')? entries += MapEntry (',' entries += MapEntry)* ']' 
	| {be::BLiteralMapExpression} '[' '<' keyType=TypeRef ',' valueType=TypeRef '>' ']' 
	;

LiteralFunction returns be::BExpression: {be::B3Function} '{' ('<' returnType=TypeRef '>')?
	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)*)? 
	'|' funcExpr=OneOrManyExpressions '}'
	;

ClosureExpression returns be::BExpression: {be::B3Function} 
	('<' returnType=TypeRef '>')?
	(parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)*)? 
	'|' funcExpr=OneOrManyExpressions
	;

OneOrManyExpressions returns be::BExpression
	: BlockExpressionWithoutBrackets
	| Expression
	;
BlockExpressionWithoutBrackets returns be::BExpression : {be::BChainedExpression} (expressions += Expression ';')+ ;
	
MapEntry returns be::BMapEntry: {be::BMapEntry} key = KeyLiteral ':' value= Expression ;

KeyLiteral returns be::BExpression : {be::BLiteralExpression} value = (ID|PID|STRING) ;

LiteralType returns be::BExpression : {be::BLiteralType} type=TypeRef ;

ValueLiteral returns be::BExpression 
	: BooleanLiteral 
	| RealLiteral  // SEE ISSUE 297089 - must be placed before IntegerLiteral
	| IntegerLiteral 
	| NullLiteral 
	| StringLiteral
//	| QueryLiteral
	| UnitLiteral
	;
	
BooleanLiteral returns  be::BExpression: {be::BLiteralExpression} value = BooleanValue;
IntegerLiteral returns  be::BExpression: {be::BLiteralExpression} value= IntValue;
UnitLiteral returns  be::BExpression: {be::BLiteralExpression} value="unit";
StringLiteral returns  be::BExpression: {be::BLiteralExpression} value = STRING;
RealLiteral	returns  be::BExpression: {be::BLiteralExpression} value = RealValue;
RegexpLiteral returns be::BExpression: {be::BRegularExpression} pattern = REGULAR_EXPR;

//QueryLiteral returns be::BExpression: {be::BLiteralExpression} value=Query ;

NullLiteral	returns  be::BExpression: {be::BLiteralExpression} "null"; // TODO: check that type is Object
//ThisLiteral	returns  be::BExpression: {ThisLiteral} val="this";
//SuperLiteral returns  be::BExpression: {SuperLiteral} val="super";

// Has conversion rule
BooleanValue returns ecore::EBooleanObject : ("true" | "false" );

// Has conversion rule
RealValue returns ecore::EDoubleObject: REAL ;

// Has conversion rule that handles dec, oct, and hex values with radix
IntValue returns ecore::EIntegerObject : INT | HEX ;
	
ParanthesizedExpression returns be::BExpression
	:  "(" Expression ")"
	;	


Version : version = VersionLiteral;

VersionLiteral returns types::Version
	: STRING  
	| AlfanumSym
	;

VersionRange : range = VersionRangeLiteral ;

VersionRangeLiteral returns types::VersionRange
	: ('[' | '(') (STRING | AlfanumSym) (',' (STRING | AlfanumSym))? (']'|')')
	| (STRING | AlfanumSym)
	;

// Reference to qualified named item, possibly in unit, this or super, or
// this.super, or unit.super
QIDREF : (("super" |(("unit" | "this") ('.' "super")?)) ('.' QID)?) | QID ;

// Qualified name
QID hidden(): ID (INT|HEX|ID)* ('.' ID (INT|HEX|ID)*)* ; 

PropertyName : PID ;
EscapedQualifiedName:  STRING | QID;
InterfaceName: QID ;

// CompoundName (whitespace and comments allowed, as sequence can be very long. name parts
// do not allow being broken across lines.
//
CompoundName : EscapedQualifiedName '/' EscapedQualifiedName ;

// Aliases that help with unified naming (good for experiments - the indirection can be removed later)
UnitName : EscapedQualifiedName;
PartName : EscapedQualifiedName;

enum Visibility 	returns be::Visibility : public | private ;
enum ExecutionMode 	returns be::ExecutionMode: parallel | sequential ;


// Version, and VersionRange
// TODO: uncertain if the set of allowed chars is definitive.
//
Separator : '.' | '-' | '!' | '@' | '$' | '%' | '&' |'+' | '=' | '*' | '<' | '>' | ':' | '?';
AlfanumSym : (ID | INT | HEX | EXT_INT) (Separator|ID|INT|HEX |EXT_INT)* ;

// --TERMINALS
// (Does not use standard terminals to have full control).

// TODO: Possibly use some other char instead of ^ as escape mechanism ??
terminal ID : ('^')?(('a'..'z')|('A'..'Z')|'_') (('a'..'z')|('A'..'Z')|('0'..'9')|'_')* ;

// Property Names start with $ and are qualified. Must be handled by lexer as
// a.b.c is otherwise ambigous in expressions.
terminal PID : '$' ID ('.' ID)* ;

// Java regexp - allows \ before any character == same as unescaped character if character is not an operator
terminal REGULAR_EXPR returns be::RegexpPattern
	: "~/" ( '\\' (!('\t'|'\r'|'\n'))
			| (!('\\'|'/'|' '|'\t'|'\r'|'\n')))* "/" ('u'|'m'|'i'|'c'|'d')*
			;

// JS String support escaped b,t,n,f,r, and u HEX*4, x HEX*2, and (deprecated (0-7)), 
// A string converter may need to handle the u, x, and octal escapes.
// Regular java string handles XXXX , and gives syntax error if
// format is not ok, the other two remains, and possibly the null.
terminal STRING :
'"' ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|'"'|'\r'|'\n') )* '"' |
"'" ('\\'('b'|'t'|'n'|'f'|'r'|'u'|'x'|'0'|'"'|"'"|'\\') | !('\\'|"'"|'\r'|'\n') )* "'";

terminal DOCUMENTATION : '/**' -> '*/' ;
terminal ML_COMMENT : '/*' (!'*') -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS : (' '|'\t'|'\r'|'\n')+ ;
terminal HEX : '0' ('x'|'X')(('0'..'9')|('a'..'f')|('A'..'F'))+ ;
terminal INT : ('0'..'9')+;
REAL hidden(): INT ? '.' (EXT_INT | INT);
terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
 
terminal ANY_OTHER : . ;

